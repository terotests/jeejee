var jeejee_prototype = function() {
  'use strict';
  var _promise_prototype = function() {
    'use strict';
    var later_prototype = function() {;
      (function(_myTrait_) {
        var _initDone;
        var _callers;
        var _oneTimers;
        var _everies;
        var _framers;
        _myTrait_.add = function(fn, thisObj, args) {
          if (thisObj || args) {
            var tArgs;
            if (Object.prototype.toString.call(args) === '[object Array]') {
              tArgs = args;
            } else {
              tArgs = Array.prototype.slice.call(arguments, 2);
              if (!tArgs) tArgs = [];
            }
            _callers.push([thisObj, fn, tArgs]);
          } else {
            _callers.push(fn);
          }
        }
        _myTrait_.after = function(seconds, fn, name) {

          if (!name) {
            name = "time" + (new Date()).getTime() + Math.random(10000000);
          }

          _everies[name] = {
            step: Math.floor(seconds * 1000),
            fn: fn,
            nextTime: 0,
            remove: true
          };
        }
        _myTrait_.asap = function(fn) {
          this.add(fn);

        }
        _myTrait_.every = function(seconds, fn, name) {

          if (!name) {
            name = "time" + (new Date()).getTime() + Math.random(10000000);
          }

          _everies[name] = {
            step: Math.floor(seconds * 1000),
            fn: fn,
            nextTime: 0
          };
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(interval, fn) {
          if (!_initDone) {

            this.polyfill();

            var frame, cancelFrame;
            if (typeof(window) != "undefined") {
              var frame = window['requestAnimationFrame'],
                cancelFrame = window['cancelRequestAnimationFrame'];
              ['', 'ms', 'moz', 'webkit', 'o'].forEach(function(x) {
                if (!frame) {
                  frame = window[x + 'RequestAnimationFrame'];
                  cancelFrame = window[x + 'CancelAnimationFrame'] || window[x + 'CancelRequestAnimationFrame'];
                }
              });
            }

            if (!frame)
              frame = function(cb) {
                return setTimeout(cb, 16);
              };

            if (!cancelFrame)
              cancelFrame = function(id) {
                clearTimeout(id);
              };

            _callers = [];
            _oneTimers = {};
            _everies = {};
            _framers = [];
            var lastMs = 0;

            var _callQueQue = function() {
              var ms = (new Date()).getTime();
              var fn;
              while (fn = _callers.shift()) {
                if (Object.prototype.toString.call(fn) === '[object Array]') {
                  fn[1].apply(fn[0], fn[2]);
                } else {
                  fn();
                }

              }

              for (var i = 0; i < _framers.length; i++) {
                var fFn = _framers[i];
                fFn();
              }

              for (var n in _oneTimers) {
                if (_oneTimers.hasOwnProperty(n)) {
                  var v = _oneTimers[n];
                  v[0](v[1]);
                  delete _oneTimers[n];
                }
              }

              for (var n in _everies) {
                if (_everies.hasOwnProperty(n)) {
                  var v = _everies[n];
                  if (v.nextTime < ms) {
                    if (v.remove) {
                      if (v.nextTime > 0) {
                        v.fn();
                        delete _everies[n];
                      } else {
                        v.nextTime = ms + v.step;
                      }
                    } else {
                      v.fn();
                      v.nextTime = ms + v.step;
                    }
                  }
                  if (v.until) {
                    if (v.until < ms) {
                      delete _everies[n];
                    }
                  }
                }
              }

              frame(_callQueQue);
              lastMs = ms;
            };
            _callQueQue();
            _initDone = true;
          }
        });
        _myTrait_.once = function(key, fn, value) {
          // _oneTimers

          _oneTimers[key] = [fn, value];
        }
        _myTrait_.onFrame = function(fn) {

          _framers.push(fn);
        }
        _myTrait_.polyfill = function(t) {
          // --- let's not ---
        }
        _myTrait_.removeFrameFn = function(fn) {

          var i = _framers.indexOf(fn);
          if (i >= 0) {
            if (fn._onRemove) {
              fn._onRemove();
            }
            _framers.splice(i, 1);
            return true;
          } else {
            return false;
          }
        }
      }(this));
    }
    var later = function(a, b, c, d, e, f, g, h) {
      if (this instanceof later) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != later._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new later(a, b, c, d, e, f, g, h);
    };
    later._classInfo = {
      name: 'later'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("later", later)
    later.prototype = new later_prototype();
    if (typeof(window) != 'undefined') window['later'] = later;
    if (typeof(window) != 'undefined') window['later_prototype'] = later_prototype;;
    (function(_myTrait_) {
      _myTrait_.isArray = function(someVar) {
        return Object.prototype.toString.call(someVar) === '[object Array]';
      }
      _myTrait_.isFunction = function(fn) {
        return Object.prototype.toString.call(fn) == '[object Function]';
      }
      _myTrait_.isObject = function(obj) {
        return obj === Object(obj);
      }
    }(this));;
    (function(_myTrait_) {
      _myTrait_.all = function(firstArg) {

        var args;
        if (this.isArray(firstArg)) {
          args = firstArg;
        } else {
          args = Array.prototype.slice.call(arguments, 0);
        }
        // console.log(args);
        var targetLen = args.length,
          rCnt = 0,
          myPromises = [],
          myResults = new Array(targetLen);

        return this.then(
          function() {

            var allPromise = _promise();
            if (args.length == 0) {
              allPromise.resolve([]);
            }
            args.forEach(function(b, index) {
              if (b.then) {
                // console.log("All, looking for ", b, " state = ", b._state);
                myPromises.push(b);

                b.then(function(v) {
                  myResults[index] = v;
                  // console.log("Got a promise...",b, " cnt = ", rCnt);
                  rCnt++;
                  if (rCnt == targetLen) {
                    allPromise.resolve(myResults);
                  }
                }, function(v) {
                  allPromise.reject(v);
                });

              } else {
                allPromise.reject("Not list of promises");
              }
            })

            return allPromise;

          });





      }
      _myTrait_.collect = function(collectFn, promiseList, results) {

        var args;
        if (this.isArray(promiseList)) {
          args = promiseList;
        } else {
          args = [promiseList];
        }

        // console.log(args);
        var targetLen = args.length,
          isReady = false,
          noMore = false,
          rCnt = 0,
          myPromises = [],
          myResults = results || {};

        return this.then(
          function() {

            var allPromise = _promise();
            args.forEach(function(b, index) {
              if (b.then) {
                // console.log("All, looking for ", b, " state = ", b._state);
                myPromises.push(b);

                b.then(function(v) {
                  rCnt++;
                  isReady = collectFn(v, myResults);
                  if ((isReady && !noMore) || (noMore == false && targetLen == rCnt)) {
                    allPromise.resolve(myResults);
                    noMore = true;
                  }
                }, function(v) {
                  allPromise.reject(v);
                });

              } else {
                allPromise.reject("Not list of promises");
              }
            })

            return allPromise;

          });

      }
      _myTrait_.fail = function(fn) {
        return this.then(null, fn);
      }
      _myTrait_.fulfill = function(withValue) {
        // if(this._fulfilled || this._rejected) return;

        if (this._rejected) return;
        if (this._fulfilled && withValue != this._stateValue) {
          return;
        }

        var me = this;
        this._fulfilled = true;
        this._stateValue = withValue;

        var chCnt = this._childPromises.length;

        while (chCnt--) {
          var p = this._childPromises.shift();
          if (p._onFulfill) {
            try {
              var x = p._onFulfill(withValue);
              // console.log("Returned ",x);
              if (typeof(x) != "undefined") {
                p.resolve(x);
              } else {
                p.fulfill(withValue);
              }
            } catch (e) {
              // console.error(e);
              /*
                           If either onFulfilled or onRejected throws an exception e, promise2 
                           must be rejected with e as the reason.            
                       */
              p.reject(e);
            }
          } else {
            /*
                       If onFulfilled is not a function and promise1 is fulfilled, promise2 must be 
                       fulfilled with the same value as promise1        
                   */
            p.fulfill(withValue);
          }
        };
        // this._childPromises.length = 0;
        this._state = 1;
        this.triggerStateChange();

      }
      _myTrait_.genPlugin = function(fname, fn) {
        var me = this;
        this.plugin(fname,
          function() {
            var args = Array.prototype.slice.call(arguments, 0);
            console.log("Plugin args", args);
            var myPromise = _promise();
            this.then(function(v) {
              var args2 = Array.prototype.slice.call(arguments, 0);
              var z = args.concat(args2);
              var res = fn.apply(this, z);
              myPromise.resolve(res);
            }, function(r) {
              myPromise.reject(r);
            });
            return myPromise;

          }
        );
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(onFulfilled, onRejected) {
        // 0 = pending
        // 1 = fullfilled
        // 2 = error

        this._state = 0;
        this._stateValue = null;
        this._isAPromise = true;
        this._childPromises = [];

        if (this.isFunction(onFulfilled))
          this._onFulfill = onFulfilled;
        if (this.isFunction(onRejected))
          this._onReject = onRejected;

        if (!onRejected && this.isFunction(onFulfilled)) {



          var me = this;
          later().asap(
            function() {
              console.log("--- calling the onFulfilled ");
              onFulfilled(function(v) {
                me.resolve(v)
              }, function(v) {
                me.resolve(v);
              });
            });

        }
      });
      _myTrait_.isFulfilled = function(t) {
        return this._state == 1;
      }
      _myTrait_.isPending = function(t) {
        return this._state == 0;
      }
      _myTrait_.isRejected = function(v) {
        return this._state == 2;
      }
      _myTrait_.nodeStyle = function(fname, fn) {
        var me = this;
        this.plugin(fname,
          function() {
            var args = Array.prototype.slice.call(arguments, 0);
            var last, userCb, cbIndex = 0;
            if (args.length >= 0) {
              last = args[args.length - 1];
              if (Object.prototype.toString.call(last) == '[object Function]') {
                userCb = last;
                cbIndex = args.length - 1;
              }
            }

            var mainPromise = wishes().pending();
            this.then(function() {
              var nodePromise = wishes().pending();
              var args2 = Array.prototype.slice.call(arguments, 0);
              console.log("Orig args", args);
              console.log("Then args", args2);
              var z;
              if (args.length == 0)
                z = args2;
              if (args2.length == 0)
                z = args;
              if (!z) z = args2.concat(args);
              cbIndex = z.length; // 0,fn... 2
              if (userCb) cbIndex--;
              z[cbIndex] = function(err) {
                if (err) {
                  console.log("Got error ", err);
                  nodePromise.reject(err);
                  mainPromise.reject(err);
                  return;
                }
                if (userCb) {
                  var args = Array.prototype.slice.call(arguments);
                  var res = userCb.apply(this, args);
                  mainPromise.resolve(res);
                } else {
                  var args = Array.prototype.slice.call(arguments, 1);
                  mainPromise.resolve.apply(mainPromise, args);
                }
              }
              nodePromise.then(function(v) {
                mainPromise.resolve(v);
              });

              console.log("nodeStyle after concat", z);
              var res = fn.apply(this, z);
              // myPromise.resolve(res);
              // return nodePromise;
              return nodePromise;
            }, function(v) {
              mainPromise.reject(v);
            });
            return mainPromise;
            /*
                      log("..... now waiting "+ms);
                      var p = waitFor(ms);
                      p.then( function(v) {
                          myPromise.resolve(v);
                      });
                  */
          }
        );
      }
      _myTrait_.onStateChange = function(fn) {

        if (!this._listeners)
          this._listeners = [];

        this._listeners.push(fn);
      }
      _myTrait_.plugin = function(n, fn) {

        _myTrait_[n] = fn;

        return this;
      }
      _myTrait_.props = function(obj) {
        var args = [];

        for (var n in obj) {
          if (obj.hasOwnProperty(n)) {
            args.push({
              name: n,
              promise: obj[n]
            });
          }
        }


        // console.log(args);
        var targetLen = args.length,
          rCnt = 0,
          myPromises = [],
          myResults = {};

        return this.then(
          function() {

            var allPromise = wishes().pending();
            args.forEach(function(def) {
              var b = def.promise,
                name = def.name;
              if (b.then) {
                // console.log("All, looking for ", b, " state = ", b._state);
                myPromises.push(b);

                b.then(function(v) {
                  myResults[name] = v;
                  rCnt++;
                  if (rCnt == targetLen) {
                    allPromise.resolve(myResults);
                  }
                }, function(v) {
                  allPromise.reject(v);
                });

              } else {
                allPromise.reject("Not list of promises");
              }
            })

            return allPromise;

          });

      }
      _myTrait_.reject = function(withReason) {

        // if(this._rejected || this._fulfilled) return;

        // conso

        if (this._fulfilled) return;
        if (this._rejected && withReason != this._rejectReason) return;


        this._state = 2;
        this._rejected = true;
        this._rejectReason = withReason;
        var me = this;

        var chCnt = this._childPromises.length;
        while (chCnt--) {
          var p = this._childPromises.shift();

          if (p._onReject) {
            try {
              p._onReject(withReason);
              p.reject(withReason);
            } catch (e) {
              /*
                           If either onFulfilled or onRejected throws an exception e, promise2 
                           must be rejected with e as the reason.            
                       */
              p.reject(e);
            }
          } else {
            /*
                       If onFulfilled is not a function and promise1 is fulfilled, promise2 must be 
                       fulfilled with the same value as promise1        
                   */
            p.reject(withReason);
          }
        };

        // this._childPromises.length = 0;
        this.triggerStateChange();

      }
      _myTrait_.rejectReason = function(reason) {
        if (reason) {
          this._rejectReason = reason;
          return;
        }
        return this._rejectReason;
      }
      _myTrait_.resolve = function(x) {

        // console.log("Resolving ", x);

        // can not do this many times...
        if (this._state > 0) return;

        if (x == this) {
          // error
          this._rejectReason = "TypeError";
          this.reject(this._rejectReason);
          return;
        }

        if (this.isObject(x) && x._isAPromise) {

          // 
          this._state = x._state;
          this._stateValue = x._stateValue;
          this._rejectReason = x._rejectReason;
          // ... 
          if (this._state === 0) {
            var me = this;
            x.onStateChange(function() {
              if (x._state == 1) {
                // console.log("State change");
                me.resolve(x.value());
              }
              if (x._state == 2) {
                me.reject(x.rejectReason());
              }
            });
          }
          if (this._state == 1) {
            // console.log("Resolved to be Promise was fulfilled ", x._stateValue);
            this.fulfill(this._stateValue);
          }
          if (this._state == 2) {
            // console.log("Relved to be Promise was rejected ", x._rejectReason);
            this.reject(this._rejectReason);
          }
          return;
        }
        if (this.isObject(x) && x.then && this.isFunction(x.then)) {
          // console.log("Thenable ", x);
          var didCall = false;
          try {
            // Call the x.then
            var me = this;
            x.then.call(x,
              function(y) {
                if (didCall) return;
                // we have now value for the promise...
                // console.log("Got value from Thenable ", y);
                me.resolve(y);
                didCall = true;
              },
              function(r) {
                if (didCall) return;
                // console.log("Got reject from Thenable ", r);
                me.reject(r);
                didCall = true;
              });
          } catch (e) {
            if (!didCall) this.reject(e);
          }
          return;
        }
        this._state = 1;
        this._stateValue = x;

        // fulfill the promise...
        this.fulfill(x);

      }
      _myTrait_.state = function(newState) {
        if (typeof(newState) != "undefined") {
          this._state = newState;
        }
        return this._state;
      }
      _myTrait_.then = function(onFulfilled, onRejected) {

        if (!onRejected) onRejected = function() {};

        var p = new _promise(onFulfilled, onRejected);
        var me = this;

        if (this._state == 1) {
          later().asap(function() {
            me.fulfill(me.value());
          });
        }
        if (this._state == 2) {
          ater().asap(function() {
            me.reject(me.rejectReason());
          });
        }
        this._childPromises.push(p);
        return p;



      }
      _myTrait_.triggerStateChange = function(t) {
        var me = this;
        if (!this._listeners) return;
        this._listeners.forEach(function(fn) {
          fn(me);
        });
        // one-timer
        this._listeners.length = 0;
      }
      _myTrait_.value = function(v) {
        if (typeof(v) != "undefined") {
          this._stateValue = v;
          return this;
        }
        return this._stateValue;
      }
    }(this));
  }
  var _promise = function(a, b, c, d, e, f, g, h) {
    if (this instanceof _promise) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != _promise._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new _promise(a, b, c, d, e, f, g, h);
  };
  _promise._classInfo = {
    name: '_promise'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_promise", _promise)
  _promise.prototype = new _promise_prototype();
  if (typeof(window) != 'undefined') window['_promise'] = _promise;
  if (typeof(window) != 'undefined') window['_promise_prototype'] = _promise_prototype;
  var objectTools_prototype = function() {;
    (function(_myTrait_) {
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(main, dataObj) {


        var optArea = main.div();
        var resArea = main.div();

        var tbl = optArea.table(),
          objId = _e("input");
        tbl.addRow(objId, "Hae ID -arvolla");
        var btn = optArea.div().button().text("Etsi");

        var ta = _e("textarea");
        ta.width(700).height(130);
        resArea.add(ta);

        btn.on("click", function() {
          var res = dataObj.findFromCache(objId.val());
          if (res) {
            ta.val(JSON.stringify(res.toData(), null, 2));
          } else {
            ta.val("Object not found ");
          }
        });
      });
    }(this));
  }
  var objectTools = function(a, b, c, d, e, f, g, h) {
    if (this instanceof objectTools) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != objectTools._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new objectTools(a, b, c, d, e, f, g, h);
  };
  objectTools._classInfo = {
    name: 'objectTools'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("objectTools", objectTools)
  objectTools.prototype = new objectTools_prototype();
  if (typeof(window) != 'undefined') window['objectTools'] = objectTools;
  if (typeof(window) != 'undefined') window['objectTools_prototype'] = objectTools_prototype;
  var aceCmdConvert_prototype = function() {
    'use strict';;
    (function(_myTrait_) {
      _myTrait_.fromAce = function(cmdList) {


        var newList = [];

        cmdList.forEach(function(cmd) {

          var range = cmd.range;
          if (cmd.action == "insertText") {
            newList.push([
              1,
              range.start.row,
              range.start.column,
              range.end.row,
              range.end.column,
              cmd.text
            ])
          }
          if (cmd.action == "removeText") {
            newList.push([
              2,
              range.start.row,
              range.start.column,
              range.end.row,
              range.end.column,
              cmd.text
            ])
          }
          if (cmd.action == "insertLines") {
            newList.push([
              3,
              range.start.row,
              range.start.column,
              range.end.row,
              range.end.column,
              cmd.lines
            ])
          }
          if (cmd.action == "removeLines") {
            newList.push([
              4,
              range.start.row,
              range.start.column,
              range.end.row,
              range.end.column,
              cmd.lines,
              cmd.nl
            ])
          }


        });

        return newList;

        /*
           {"action":"insertText","range":{"start":{"row":0,"column":0},
               "end":{"row":0,"column":1}},"text":"d"}
           */
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(onFulfilled, onRejected) {

      });
      _myTrait_.runToAce = function(cmdList) {


        var newList = [],
          _convert = ["",
            "insertText", "removeText", "insertLines", "removeLines"
          ];

        cmdList.forEach(function(cmd) {

          var c = {
            action: _convert[cmd[0]],
            range: {
              start: {
                row: cmd[1],
                column: cmd[2]
              },
              end: {
                row: cmd[3],
                column: cmd[4]
              }
            }
          };
          if (cmd[0] < 3) {
            c.text = cmd[5];
          } else {
            c.lines = cmd[5];
          }
          if (cmd[0] == 4) c.nl = cmd[6] || "\n";
          newList.push(c);

        });

        return newList;

        /*
           {"action":"insertText","range":{"start":{"row":0,"column":0},
               "end":{"row":0,"column":1}},"text":"d"}
           */
      }
      _myTrait_.runToLineObj = function(lines, cmdList) {

        cmdList.forEach(function(cmd) {
          var row = cmd[1],
            col = cmd[2],
            endRow = cmd[3],
            endCol = cmd[4];
          if (cmd[0] == 1) {
            if (cmd[5] == "\n") {
              // add the newline can be a bit tricky
              var line = lines.item(row);
              if (!line) {
                lines.insertAt(row, {
                  text: ""
                });
                lines.insertAt(row + 1, {
                  text: ""
                });
              } else {
                var txt = line.text();
                line.text(txt.slice(0, col));
                var newLine = {
                  text: txt.slice(col) || ""
                };
                lines.insertAt(row + 1, newLine);
              }
              //lines[row] = line.slice(0,col);
              //var newLine = line.slice(col) || "";
              //lines.splice(row+1, 0, newLine);
            } else {
              var line = lines.item(row);
              if (!line) {
                lines.insertAt(row, {
                  text: cmd[5]
                });
              } else {
                var txt = line.text();
                line.text(txt.slice(0, col) + cmd[5] + txt.slice(col));
                // lines[row] = line.slice(0, col) + cmd[5] + line.slice(col);
              }
            }
          }
          if (cmd[0] == 2) {
            if (cmd[5] == "\n") {
              // removing the newline can be a bit tricky
              // lines[row]
              var thisLine = lines.item(row),
                nextLine = lines.item(row + 1);

              // lines[row] = thisLine + nextLine;
              // lines.splice(row+1, 1); // remove the line...
              var txt1 = "",
                txt2 = "";
              if (thisLine) txt1 = thisLine.text();
              if (nextLine) txt2 = nextLine.text();
              if (!thisLine) {
                lines.insertAt(row, {
                  text: ""
                });
              } else {
                thisLine.text(txt1 + txt2);
              }
              if (nextLine) nextLine.remove();
            } else {
              var line = lines.item(row),
                txt = line.text();
              line.text(txt.slice(0, col) + txt.slice(endCol));
              //  str.slice(0, 4) + str.slice(5, str.length))
              // lines[row] = line.slice(0, col) + line.slice(endCol);
            }
          }
          if (cmd[0] == 3) {
            var cnt = endRow - row;
            for (var i = 0; i < cnt; i++) {
              // var line = lines.item(row+i);
              lines.insertAt(row + i, {
                text: cmd[5][i]
              });
              // lines.splice(row+i, 0, cmd[5][i]);
            }
          }
          if (cmd[0] == 4) {
            var cnt = endRow - row;
            for (var i = 0; i < cnt; i++) {
              var line = lines.item(row);
              line.remove();
              // lines.splice(row, 1);
            }
          }

        });
        /*
           tools.button().text("Insert to 1 ").on("click", function() {
               myT.lines.insertAt(1, { text : prompt("text")}); 
           });
           tools.button().text("Insert to 0 ").on("click", function() {
               myT.lines.insertAt(0, { text : prompt("text")}); 
           });
           tools.button().text("Split line 1").on("click", function() {
               var line1 = myT.lines.item(1);
               var txt = line1.text();
               var txt1 = txt.substring(0, 4),
                   txt2 = txt.substring(4);
               line1.text(txt1);
               myT.lines.insertAt(2, { text : txt2 });
           });
           tools.button().text("Insert to N-1 ").on("click", function() {
               myT.lines.insertAt(myT.lines.length()-1, { text : prompt("text")}); 
           });
           tools.button().text("Insert to N ").on("click", function() {
               myT.lines.insertAt(myT.lines.length(), { text : prompt("text")}); 
           });
           */

      }
      _myTrait_.runToString = function(str, cmdList) {

        if (!cmdList || (typeof(str) == "undefined")) {
          return "";
        }
        str = str + "";

        var lines = str.split("\n");

        cmdList.forEach(function(cmd) {
          var row = cmd[1],
            col = cmd[2],
            endRow = cmd[3],
            endCol = cmd[4];
          if (cmd[0] == 1) {
            if (cmd[5] == "\n") {
              // add the newline can be a bit tricky
              var line = lines[row] || "";
              lines[row] = line.slice(0, col);
              var newLine = line.slice(col) || "";
              lines.splice(row + 1, 0, newLine);
            } else {
              var line = lines[row] || "";
              lines[row] = line.slice(0, col) + cmd[5] + line.slice(col);
            }
          }
          if (cmd[0] == 2) {
            if (cmd[5] == "\n") {
              // removing the newline can be a bit tricky
              // lines[row]
              var thisLine = lines[row] || "",
                nextLine = lines[row + 1] || "";
              lines[row] = thisLine + nextLine;
              lines.splice(row + 1, 1); // remove the line...
            } else {
              var line = lines[row] || "";
              // str.slice(0, 4) + str.slice(5, str.length))
              lines[row] = line.slice(0, col) + line.slice(endCol);
            }
          }
          if (cmd[0] == 3) {
            var cnt = endRow - row;
            for (var i = 0; i < cnt; i++) {
              lines.splice(row + i, 0, cmd[5][i]);
            }
          }
          if (cmd[0] == 4) {
            var cnt = endRow - row;
            for (var i = 0; i < cnt; i++) {
              lines.splice(row, 1);
            }
          }

        });

        return lines.join("\n");
      }
      _myTrait_.simplify = function(cmdList) {

        // [[1,0,0,0,1,"a"],[1,0,1,0,2,"b"],[1,0,2,0,3,"c"],[1,0,3,0,4,"e"],[1,0,4,0,5,"d"],
        // [1,0,5,0,6,"e"],[1,0,6,0,7,"f"],[1,0,7,0,8,"g"]]
        var newList = [],
          lastCmd,
          lastCol,
          lastRow,
          collect = null;

        cmdList.forEach(function(cmd) {

          if (lastCmd && (cmd[0] == 1) && (lastCmd[0] == 1) && (cmd[3] == cmd[1]) && (lastCmd[1] == cmd[1]) && (lastCmd[3] == cmd[3]) && (lastCmd[4] == cmd[2])) {
            if (!collect) {
              collect = [];
              collect[0] = 1;
              collect[1] = lastCmd[1];
              collect[2] = lastCmd[2];
              collect[3] = cmd[3];
              collect[4] = cmd[4];
              collect[5] = lastCmd[5] + cmd[5];
            } else {
              collect[3] = cmd[3];
              collect[4] = cmd[4];
              collect[5] = collect[5] + cmd[5];
            }
          } else {
            if (collect) {
              newList.push(collect);
              collect = null;
            }
            if (cmd[0] == 1) {
              collect = cmd.slice();
            } else {
              newList.push(cmd);
            }
          }
          lastCmd = cmd;
        });
        if (collect) newList.push(collect);
        return newList;
      }
    }(this));
  }
  var aceCmdConvert = function(a, b, c, d, e, f, g, h) {
    if (this instanceof aceCmdConvert) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != aceCmdConvert._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new aceCmdConvert(a, b, c, d, e, f, g, h);
  };
  aceCmdConvert._classInfo = {
    name: 'aceCmdConvert'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("aceCmdConvert", aceCmdConvert)
  aceCmdConvert.prototype = new aceCmdConvert_prototype();
  if (typeof(window) != 'undefined') window['aceCmdConvert'] = aceCmdConvert;
  if (typeof(window) != 'undefined') window['aceCmdConvert_prototype'] = aceCmdConvert_prototype;
  var templatePackage_prototype = function() {
    'use strict';
    var _inputWorker_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.run = function(change, obj, targetObj) {

          //console.log("run");
          //console.log(change, obj, targetObj);

          if (!change || !targetObj) return;

          // DOM node... new value to the DOM node...

          //console.log("About to change");

          if (change[0] == 4) {
            //console.log("Creating the SET change");
            var prop = change[1];
            var v = obj.data[prop];
            //console.log(obj);
            //console.log(obj.data);
            //console.log(prop,v);

            var oldVal = targetObj.value;
            if (oldVal != v) targetObj.value = v;
          }

        }
      }(this));
    }
    var _inputWorker = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _inputWorker) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _inputWorker._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _inputWorker(a, b, c, d, e, f, g, h);
    };
    _inputWorker._classInfo = {
      name: '_inputWorker'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_inputWorker", _inputWorker)
    _inputWorker.prototype = new _inputWorker_prototype();
    var _domTextWorker_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.run = function(change, obj, targetObj) {

          if (!change || !targetObj) return;

          var dom = targetObj;

          if (!this.bDetected) {

            if (typeof(dom.textContent) != "undefined") {
              this.bFast = true;
            } else {
              this.bFast = false;
              this.tmpDom = document.createElement("div");
            }
            this.bDetected = true;
          }

          if (change[0] == 4) {
            var prop = change[1];
            var v = obj.data[prop];
            if (this.bFast) {
              targetObj.textContent = v;
            } else {
              this.tmpDom.innerHTML = v;
              if (targetObj.innerHTML) {
                targetObj.innerHTML = this.tmpDom.innerText;
              } else {
                targetObj.replaceData(0, targetObj.nodeValue.length, v || "");
                /*
                       var p = targetObj.parentNode;
                       if(p) {
                           p.replaceChild( document.createTextNode(v || ""), targetObj);
                       }
                       */
                // targetObj.nodeValue = this.tmpDom.innerText;
              }

            }

          }

        }
      }(this));
    }
    var _domTextWorker = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _domTextWorker) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _domTextWorker._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _domTextWorker(a, b, c, d, e, f, g, h);
    };
    _domTextWorker._classInfo = {
      name: '_domTextWorker'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_domTextWorker", _domTextWorker)
    _domTextWorker.prototype = new _domTextWorker_prototype();
    var templateCompiler_prototype = function() {;
      (function(_myTrait_) {
        var _modelTemplates;
        var _viewContent;
        var _viewTemplates;
        var _namedModels;
        var _namedViews;
        var _dataLink;
        var _customDirectives;
        var _viewsById;
        var _aceInstances;
        var _regTypes;
        _myTrait_._addCustomDir = function(name, fn) {

          if (!_customDirectives) _customDirectives = {}
          _customDirectives[name] = fn;

        }
        _myTrait_._addModelTemplate = function(elem, tplObj) {

          var id = this.guid();
          if (!_modelTemplates) _modelTemplates = {};
          _modelTemplates[id] = tplObj;
          if (elem && elem.setAttribute) elem.setAttribute("data-tpl", id);
        }
        _myTrait_._callCustom = function(name, dom, options) {
          if (_customDirectives[name]) {
            _customDirectives[name](dom, options);
          }
        }
        _myTrait_._clearWorkers = function(view) {

          view.workers.forEach(function(ww) {
            _dataLink._removeWorker(ww);
          })
          var me = this;
          view.childViews.forEach(function(w) {
            me._clearWorkers(w);
          });
        }
        _myTrait_._createViewDef = function(dataId, parentView) {


          var viewDef = {
            viewid: this.getGUID(),
            dataid: dataId,
            baseTpl: null,
            dom: null,
            parentView: parentView,
            workers: [],
            childViews: []
          }

          if (!_viewsById) {
            _viewsById = {}
          }
          _viewsById[viewDef.viewid] = viewDef;

          if (parentView && parentView.childViews) {
            parentView.childViews.push(viewDef);
          }

          _dataLink._addModelView(dataId, viewDef);


          return viewDef;
        }
        _myTrait_._eventActionFor = function(event, attributeName, rootData) {
          var elem = event.target;
          if (!elem) return;
          var action = elem.getAttribute(attributeName);
          var me = this;
          if (action) {
            var max = 10,
              dom = elem,
              objid;
            // console.log("Looking action ", action);
            while (dom && !(objid = dom.getAttribute("data-id")) && (max--)) {
              dom = dom.parentNode;
            }
            if (dom && objid) {

              var params = action.split("("),
                action = params.shift();
              var argStr = params.pop(),
                plist = null;
              if (argStr) {
                var prms = argStr.split(")"),
                  plist = prms.shift().split(",");
              }
              // console.log("Found the action");
              var oo = rootData.findFromCache(objid);
              if (me.isFunction(oo[action])) {
                console.log("fires ", action, plist);
                if (me.isArray(plist)) {
                  oo[action].apply(oo, plist);
                } else {
                  oo[action](); // just a test for the sake of easiness...
                }
              }
            }
          }
        }
        _myTrait_._findModelTemplate = function(elem) {

          if (elem && elem.getAttribute) {
            var id = elem.getAttribute("data-tpl");
            if (_modelTemplates) return _modelTemplates[id];
          }
        }
        _myTrait_._getNamedView = function(name) {

          return _namedViews[name];
        }
        _myTrait_._getNamedViews = function(t) {

          return _namedViews;
        }
        _myTrait_._getSvgTagName = function(tag) {

          if (tag == "textpath") return "textPath";

          return tag;
        }
        _myTrait_._getViewsOfModel = function(dataId) {

          // this is needed for example when the view is destroyed...


          return _modelTemplates[dataId];
        }
        _myTrait_._saveViewTemplate = function(name, tplDef) {

          if (!_viewTemplates) {
            _viewTemplates = {};
          }

          _viewTemplates[name] = tplDef;
        }
        _myTrait_._setNamedModel = function(name, model) {

          // The named nodel
          // <div data-model="@topnavi">
          // </div>

          // ********* dynamic view template to be used *********
          // <div data-view="@content">
          // </div>


          _namedModels[name] = model;

          return this;
        }
        _myTrait_._setNamedView = function(name, viewDef) {

          _namedViews[name] = viewDef;

        }
        _myTrait_.clearTheView = function(viewId) {

          if (!_viewsById) return;

          var view = _viewsById[viewId];
          if (view) {

            this._clearWorkers(view);
            var parentView = view.parentView;

            if (parentView) {
              var i = parentView.childViews.indexOf(view);
              if (i >= 0) {
                parentView.childViews.splice(i, 1);
              }
            }

            delete _viewsById[view.viewid];

          }
        }
        _myTrait_.composeModelView = function(dom, dataItem, modelView, renderToView) {
          var m = dataItem,
            me = this,
            t = modelView.baseTpl,
            itemView;

          if (renderToView) {
            itemView = renderToView;
          } else {
            itemView = me._createViewDef(m.__id, modelView);
          }
          if (t.classSwitch) {
            var subC = m.data[t.classSwitch],
              sT;
            if (!subC) {
              sT = t.classTemplates["default"];
            } else {
              sT = t.classTemplates[subC];
              if (!sT) sT = t.classTemplates["default"];
            }
            if (sT) {
              if (sT) {
                var newDom = me.composeTemplate(m, sT, itemView);

                if (renderToView) {
                  // console.log("Using Render to View ...");
                  renderToView.dom.parentNode.replaceChild(newDom, renderToView.dom);
                } else {
                  dom.appendChild(newDom);
                }
                itemView.dom = newDom;

                // Worker to observe changes for the class-switch
                var w = _dataLink._createWorker(m.__id, t.classSwitch, _workers().fetch(5), dom, {
                  view: itemView,
                  template: t,
                  m: m,
                  dom: newDom
                });

                itemView.workers.push(w);
              }
            }
          } else {
            var subTpl = t.children[0];
            var newDom = me.composeTemplate(m, subTpl, modelView);
            dom.appendChild(newDom);
            itemView.dom = newDom;
          }
        }
        _myTrait_.composePartsToTxt = function(tpl, dataItem) {
          var rawText = "";
          var list = tpl.txtParts.list,
            toks = tpl.txtParts.tokens;
          // console.log(list);
          for (var i = 0; i < list.length; i++) {
            var vName;
            if (vName = toks[i]) {
              var val = "";
              if (typeof(dataItem.data[vName]) != "undefined") {
                val = dataItem.data[vName] || "";
              }
              rawText += val;

            } else {
              rawText += list[i] || "";
            }
          }
          return rawText;


        }
        _myTrait_.composeTemplate = function(dataItem, tpl, currentView) {

          var bDoNotInsert = false;
          var me = this;
          if (tpl && tpl.tplData) {
            tpl = tpl.tplData;
          }

          if (tpl && tpl.baseTpl) {
            tpl = tpl.baseTpl;
          }

          // Detect the data-attribute for the template here...
          var bChange = false;
          if (tpl.dataAttrs) {
            var modelURL = tpl.dataAttrs["data-model-url"];
            var modelURL2 = tpl.dataAttrs["data-model-url-confirm"];
            if (modelURL && (modelURL == modelURL2)) {
              // console.log("*** found model url ***");
              // console.log(modelURL);
            }

            var mName;
            if (mName = tpl.dataAttrs["data-selection"]) {
              if (dataItem.data[mName]) {
                _dataLink._addSelectionModel(dataItem.data[mName]);
              }
            }
            // currently only local models:
            var modelName = tpl.dataAttrs["data-use-model"];
            if (modelName) {
              _dataLink.query(modelName, function(newModel) {
                if (newModel) {
                  dataItem = newModel;
                  bChange = true;
                }
              });
            }
          }





          if (!currentView) {
            currentView = this._createViewDef(dataItem.__id);
            currentView.baseTpl = tpl;

            //console.log("The template");
            //console.log(tpl);

            if (tpl.dataAttrs) {
              var viewName = tpl.dataAttrs["data-view"];
              //console.error("Found ", viewName);
              if (viewName) {
                this._setNamedView(viewName, currentView);
              }
            }
          } else {
            if (tpl.dataAttrs) {
              var viewName = tpl.dataAttrs["data-view"];
              //console.error("Found ", viewName);
              if (viewName) {
                // currentView = me._createViewDef( dataItem.__id, currentView );
                currentView = this._createViewDef(dataItem.__id, currentView);
                currentView.baseTpl = tpl;
                this._setNamedView(viewName, currentView);
              }
            }
          }



          if (tpl.type == 3) {
            var dom;

            if (tpl.txtParts && tpl.txtParts.bHas) {

              var dom = document.createDocumentFragment();

              var list = tpl.txtParts.list,
                toks = tpl.txtParts.tokens;
              for (var i = 0; i < list.length; i++) {
                var vName;
                if (vName = toks[i]) {
                  var val = "",
                    bDidAppend = false;
                  var vParts = vName.split(":");
                  if (vParts.length > 1) {
                    vName = vParts[0];
                    var typeName = vParts[1];

                    // Here is the code to create a live template compiler from a variable
                    if (typeName == "aceHTML") {
                      if (typeof(dataItem.data[vName]) != "undefined") {
                        val = dataItem.data[vName] || "";
                      }
                      var docHolder = document.createElement("div");
                      // Then, what do do really... might apply some classes to the editor here
                      docHolder.setAttribute("class", "aceHTML");
                      var inst = me.getAceInstance(dataItem.__id + ":" + vName, docHolder, dataItem, vName, null, currentView);
                      if (inst.dom.parentNode) {
                        inst.dom.parentNode.removeChild(inst.dom);
                      }
                      dom.appendChild(inst.dom);
                      inst.editor._noUpdates = true;
                      inst.editor.setValue(val);
                      inst.editor._noUpdates = false;

                      currentView.workers.push(w);
                      bDidAppend = true;
                    }

                    // Here is the code to create a live template compiler from a variable
                    if (typeName == "aceJS") {
                      if (typeof(dataItem.data[vName]) != "undefined") {
                        val = dataItem.data[vName] || "";
                      }
                      var docHolder = document.createElement("div");
                      // Then, what do do really... might apply some classes to the editor here
                      docHolder.setAttribute("class", "aceHTML");
                      var inst = me.getAceInstance(dataItem.__id + ":" + vName, docHolder, dataItem, vName, "javascript", currentView);
                      if (inst.dom.parentNode) {
                        inst.dom.parentNode.removeChild(inst.dom);
                      }
                      dom.appendChild(inst.dom);
                      inst.editor._noUpdates = true;
                      inst.editor.setValue(val);
                      inst.editor._noUpdates = false;



                      bDidAppend = true;
                    }

                    // Here is the code to create a live template compiler from a variable
                    if (typeName == "template") {
                      if (typeof(dataItem.data[vName]) != "undefined") {
                        val = dataItem.data[vName] || "";
                      }
                      // console.error("Could not handle ", vParts[0], vParts[1]);
                      // Now, we might do something funny here...
                      // Do we have this compiled???
                      var jsTpl = me.compile(val);
                      var subTplDOM = me.composeTemplate(dataItem, jsTpl);
                      // TODO: on value perhaps not necessary?

                      dom.appendChild(subTplDOM);
                      bDidAppend = true;
                      var myView = me.getViewForElem(subTplDOM);
                      var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(9), subTplDOM, {
                        modelid: dataItem.__id,
                        compiler: me,
                        view: myView
                      });
                      myView.workers.push(w);
                    }

                    var custType;
                    if (_regTypes[typeName]) {
                      // console.log("Found the custom type ", typeName);
                      // console.log("Data item ", dataItem.data[vName]);
                    }

                    if ((custType = _regTypes[typeName])) {
                      // console.log("Did have the data item");

                      if (vName == "this") {
                        val = dataItem;
                      } else {
                        if (typeof(dataItem.data[vName]) != "undefined") {
                          val = dataItem.data[vName] || "";
                        }
                      }

                      if (custType.fn && vName) {
                        var newDom = custType.fn(val, {
                          dom: dom,
                          data: dataItem,
                          tpl: tpl,
                          view: currentView
                        });
                        if (newDom) {
                          dom.appendChild(newDom);
                          bDidAppend = true;
                          var ddd = dataItem.data[vName];
                          if (me.isObject(ddd) && me.isArray(ddd.data)) {
                            var w = _dataLink._createWorker(ddd.__id, "*", _workers().fetch(10), newDom, {
                              modelid: ddd.__id,
                              fn: custType.fn,
                              varName: vName,
                              dom: newDom,
                              callOpts: {
                                dom: dom,
                                data: ddd,
                                tpl: tpl,
                                view: currentView
                              }
                            });
                          } else {
                            ddd = dataItem;
                            var w = _dataLink._createWorker(ddd.__id, vName, _workers().fetch(10), newDom, {
                              modelid: ddd.__id,
                              fn: custType.fn,
                              varName: vName,
                              dom: newDom,
                              callOpts: {
                                dom: dom,
                                data: ddd,
                                tpl: tpl,
                                view: currentView
                              }
                            });
                          }

                          currentView.workers.push(w);

                        }
                      }

                    }


                  }

                  if (!bDidAppend) {

                    _dataLink.query(vName, function(val, resolved) {

                      if (!resolved) return;

                      if (!val) val = "";

                      var tn = document.createTextNode(val);
                      dom.appendChild(tn);

                      if (resolved.obj && resolved.name) {

                        // TODO create worker for the item...
                        var w = _dataLink._createWorker(resolved.obj.__id, resolved.name, _workers().fetch(1), tn, null);
                        currentView.workers.push(w);
                      }



                    }, dataItem);

                  }

                } else {
                  dom.appendChild(document.createTextNode(list[i] || ""));

                }
              }

            } else {
              dom = document.createTextNode(tpl.text || "");
            }
          }
          if (tpl.type == 1) {
            var dom, bSvgRoot = false;

            if (tpl.tagName == "svg") {
              // bSvgRoot = true;
              dom = document.createElementNS("http://www.w3.org/2000/svg", "svg");
              // xmlns="http://www.w3.org/2000/svg" xmlns:xlink= "http://www.w3.org/1999/xlink"
              dom.setAttribute("xmlns", "http://www.w3.org/2000/svg");
              dom.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
            } else {

              if (tpl.ns == "svg") {

                var dom = document.createElementNS("http://www.w3.org/2000/svg", this._getSvgTagName(tpl.tagName));
                dom.setAttributeNS(null, "data-id", dataItem.__id);
                dom.setAttributeNS(null, "data-viewid", currentView.viewid);
              } else {
                var dom = document.createElement(tpl.tagName);
                dom.setAttribute("data-id", dataItem.__id);
                dom.setAttribute("data-viewid", currentView.viewid);
              }
            }
            // if there is a value bind to the node, create worker for it...
            var bHadValue = false;

            if (!currentView.dom) currentView.dom = dom;

            var selClassBase,
              selClass, selClassFilter;
            if (dataItem && (selClassBase = tpl.dataAttrs["data-sel-class"])) {
              var parts = selClassBase.split(":");
              selClassFilter = parts[0];
              var selList = _docUp().findSelection(selClassFilter);
              if (selList.indexOf(dataItem.__id) >= 0) {
                $(dom).addClass(parts[1]);
              }
            }
            var bIsStyleTag = false;
            if (tpl.tagName == "style") {

              bIsStyleTag = true;

              //console.log("***** parsing a style element *****");
              //console.log("***** parsing a style element *****");
              //console.log(tpl);
              //console.log(dataItem);
              // _rawTextWorker

              var subTpl = tpl.children[0];
              var wOpts = {
                tpl: subTpl,
                dom: dom,
                model: dataItem,
                modelid: dataItem.__id
              }

              // Do we use "any" variable in this case or just some variables...
              var worker = _docUp()._createWorker(dataItem.__id,
                "*",
                _workers().fetch(8),
                dom, wOpts);
              currentView.workers.push(worker);

              var rawText = this.composePartsToTxt(subTpl, dataItem);
              // console.log(rawText);

              if (dom.cssText) {
                dom.cssText = rawText;
              } else {
                me.dom_setText(dom, rawText);
                //  dom.textContent = rawText;
              }

            }

            // The last variable...
            var ifVar;

            if (dataItem && (ifVar = tpl.dataAttrs["data-if-not-last"])) {

              // Test...
              try {
                var p = dataItem.__p;
                if (p) {

                  var pData = _dataLink._find(p);
                  if (typeof(pData) != "undefined") {
                    var ii = pData.data.indexOf(dataItem);
                    var len = pData.data.length;
                    if (ii < (len - 1)) {
                      // OK...
                    } else {
                      // Should remove the DOM item actually...
                      dom.style.display = "none";
                      bDoNotInsert = true;
                    }
                  }
                }
              } catch (e) {
                console.error(e.message);
              }

            }


            if (ifVar = tpl.dataAttrs["data-if"]) {
              _dataLink.query(ifVar, function(val) {
                if (!val) {
                  dom.style.display = "none";
                  // bDoNotInsert = true;
                }
                // TODO create worker for the item...
                var w = _dataLink._createWorker(dataItem.__id, ifVar, _workers().fetch(11), dom);
                currentView.workers.push(w);
              }, dataItem);
            }

            if (ifVar = tpl.dataAttrs["data-if-not"]) {
              _dataLink.query(ifVar, function(val) {
                if (val) {
                  dom.style.display = "none";
                  // bDoNotInsert = true;
                }
                // TODO create worker for the item...
                var w = _dataLink._createWorker(dataItem.__id, ifVar, _workers().fetch(11), dom);
                currentView.workers.push(w);
              }, dataItem);
            }

            if (ifVar = tpl.dataAttrs["data-if-then"]) {

              // evaluation worker for some change

              var ifParts = ifVar.split("=>");
              // data-if-then="logged=1 => doSomething"

              var conditionParts = ifParts[0].split("=");
              var varName = conditionParts[0];

              _dataLink.query(varName, function(val, opt) {

                var w = _dataLink._createWorker(opt.obj.__id, opt.name, _workers().fetch(13), dom, {
                  modelid: opt.obj.__id,
                  evalFn: ifVar,
                  thenCtrl: $.trim(ifParts[1])
                });
                currentView.workers.push(w);
              }, dataItem);

            }

            if (!bSvgRoot) {

              var target;
              if (target = tpl.dataAttrs["data-upload-to"]) {
                try {
                  var opts = {
                    vars: {},
                    target: target,
                    autoUpload: true,
                    onComplete: function(v) {
                      console.log("***** GOT FROM UPLOAD ");
                      console.log(v);
                      _dataLink.execCommand(v);
                    }
                  };
                  var nmod = tpl.dataAttrs["data-upload-list"]
                  if (nmod) {
                    _dataLink.query(nmod, function(res, opts) {
                      console.log("---- upload list, to");
                      console.log(res);
                      console.log(opts);
                      opts.vars.responsesTo = opts.obj.__id;
                    }, dataItem);

                  }

                  var fr = _dataLink._createUploadFrame(opts)
                  dom.appendChild(fr._dom);
                } catch (e) {
                  alert(e.message);
                }
              }


              if (tpl.valueParts && tpl.valueParts.bHas) {

                var list = tpl.valueParts.list,
                  toks = tpl.valueParts.tokens;
                for (var i = 0; i < list.length; i++) {
                  var vName;
                  if (vName = toks[i]) {
                    var val = "";

                    _dataLink.query(vName, function(val, resolved) {
                      if (!resolved) return;
                      if (!val) val = "";
                      dom.value = val;
                      if (resolved.obj && resolved.name) {
                        var dataItem = resolved.obj;
                        var vName = resolved.name;
                        var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(2), dom, null);
                        currentView.workers.push(w);
                        me.dom_setAttr(dom, "data-value-id", dataItem.__id + "::" + vName, tpl.ns);
                      }

                    }, dataItem);

                    /*
                               if(typeof(dataItem.data[vName])!="undefined") {
                                   val = dataItem.data[vName] || "";
                               }
                               dom.value = val;
                       
                               // TODO create worker for the item...
                               var w = _dataLink._createWorker( dataItem.__id, vName, _workers().fetch(2), dom, null);
                               currentView.workers.push(w);           
                               
                               me.dom_setAttr(dom, "data-value-id", dataItem.__id+"::"+vName);
                               */

                  } else {
                    // dom.appendChild( document.createTextNode( list[i] || "" ) );
                  }
                }
                bHadValue = true;
              }
              // TODO: data-attributes, are there any binds to them??
              if (tpl.attributes) {
                tpl.attributes.forEach(function(a) {
                  var name = a[0],
                    value = a[1],
                    binds = a[2];
                  if (name == "value") {
                    if (bHadValue) return;
                  }
                  var bHadB = false;

                  if (_customDirectives[name]) {
                    var myVars = {},
                      rawValue;
                    var customOpts = {
                      currentView: currentView,
                      model: dataItem,
                      binds: binds,
                      name: name,
                      vars: myVars,
                      value: rawValue
                    };

                    if (binds) {
                      var list = binds.list,
                        toks = binds.tokens;
                      for (var i = 0; i < list.length; i++) {
                        var vName;
                        if (vName = toks[i]) {
                          var val = "";
                          if (typeof(dataItem.data[vName]) != "undefined") {
                            val = dataItem.data[vName] || "";
                          }
                          myVars[vName] = val;
                          customOpts.vars = myVars;
                          customOpts.value = val;


                          // This worker should remove all the workers for this DOM element
                          var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(6), dom, customOpts);
                          currentView.workers.push(w);

                        }
                      }
                    }


                    _customDirectives[name](dom, customOpts);
                  }

                  if (tpl.dataAttrs[name]) {
                    // might check here the attributes
                    // data-view
                    // data-model
                    // data-select
                    // data-id etc.
                    if (name == "data-attr-fwd") {
                      var varList = value.split(",");

                      varList.forEach(function(vName) {
                        vName = vName.trim();
                        var val = "",
                          name = vName;
                        var parts = vName.split("=>");
                        if (parts.length > 1) {
                          name = parts[1].trim();
                          vName = parts[0].trim();
                        }
                        if (typeof(dataItem.data[vName]) != "undefined") {
                          val = dataItem.data[vName] || "";
                        }
                        // dom.setAttribute(name, val);
                        me.dom_setAttr(dom, name, val, tpl.ns);

                        // TODO create worker for the item...
                        if (tpl.ns == "svg") {
                          var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(4), dom, name);
                        } else {
                          var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(3), dom, name);
                        }
                        currentView.workers.push(w);
                        bHadB = true;
                      });
                    }
                  }


                  // dom.setAttribute(name, value);
                  // Attribute workers... binds.list
                  // => binds.tokens --- >?
                  if (binds) {
                    //console.log("Found binds ", binds);
                    var list = binds.list,
                      toks = binds.tokens;

                    me.composeTokensToTxt(binds, dataItem, function(res) {

                      bHadB = true;
                      me.dom_setAttr(dom, name, res, tpl.ns);
                    });
                    for (var i = 0; i < list.length; i++) {
                      var vName;
                      if (vName = toks[i]) {
                        var val = "";
                        if (typeof(dataItem.data[vName]) != "undefined") {
                          val = dataItem.data[vName] || "";
                        }
                        // TODO create worker for the item...
                        if (tpl.ns == "svg") {
                          var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(4), dom, {
                            attrName: name,
                            binds: binds,
                            compiler: me
                          });
                        } else {
                          var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(3), dom, {
                            attrName: name,
                            binds: binds,
                            compiler: me
                          });
                        }
                        currentView.workers.push(w);
                        bHadB = true;
                      }
                    }
                  }
                  if (!bHadB) {
                    me.dom_setAttr(dom, name, value, tpl.ns);
                  }


                })
              }
            }

            if (tpl.children && !(bIsStyleTag) && !(tpl.tagName == "textarea")) {
              var me = this;
              // data-model change here
              // data-view definitions
              // create a parent view etc....
              // model changes, views and so on should be taken into account here...
              tpl.children.forEach(function(t) {
                // Sub template..
                var modelName = t.dataAttrs["data-model"],
                  viewName = t.dataAttrs["data-view"],
                  cProp; // now undefined

                if (modelName) {


                  _dataLink.query(modelName, function(subModel) {
                    //console.log("The query returned ", subModel);
                    //console.log("Root doc is ");
                    //console.log(_dataLink._findRootDoc( subModel) );
                    if (subModel && subModel.__id) {

                      if (t.ns == "svg") {
                        var childDom = document.createElementNS("http://www.w3.org/2000/svg", tpl.tagName);
                      } else {
                        var childDom = document.createElement(t.tagName);
                      }

                      // TODO, set attributes... 
                      t.attributes.forEach(function(a) {
                        var name = a[0],
                          value = a[1],
                          binds = a[2];
                        me.dom_setAttr(childDom, name, value, tpl.ns);
                      });
                      // And here comes the code from below...
                      var modelView = me._createViewDef(subModel.__id, currentView);

                      modelView.dom = childDom;

                      // if this is actually a model-view, then save the name...
                      if (viewName) me._setNamedView(viewName, modelView);

                      me.dom_setAttr(childDom, "data-id", subModel.__id, tpl.ns);
                      // childDom.setAttribute("data-id", subModel.__id);
                      modelView.tagName = t.tagName;
                      modelView.baseTpl = t;

                      if (me.isArray(subModel.data)) {

                        // This should create a worker for the model view...
                        var w = _dataLink._createWorker(subModel.__id, "*", _workers().fetch(7), modelView);
                        modelView.workers.push(w);

                        if (subModel.data.forEach) {
                          subModel.data.forEach(function(m) {
                            me.composeModelView(childDom, m, modelView);
                          });
                        }
                        dom.appendChild(childDom);
                      } else {

                        // Then, continue...
                        var childDom = me.composeTemplate(subModel, t, modelView);
                        if (childDom) {
                          dom.appendChild(childDom);
                        }
                      }
                    }
                  }, dataItem);



                } else {

                  var childDom = me.composeTemplate(dataItem, t, currentView);
                  if (childDom) {
                    dom.appendChild(childDom);
                  }
                }
              });
            }

          }

          if (bDoNotInsert) {
            dom = document.createDocumentFragment();
            return dom;
          }

          return dom;

        }
        _myTrait_.composeTokensToTxt = function(txtParts, dataItem, fn) {
          var rawText = "";
          var list = txtParts.list,
            toks = txtParts.tokens,
            result = [],
            doneCnt = 0,
            called = false;

          // console.log(list);
          for (var i = 0; i < list.length; i++) {
            var vName;

            // If there is a token assigned to this index...
            if (vName = toks[i]) {
              (function(i) {
                _dataLink.query(vName, function(val) {
                  if (!val) val = "";
                  // Here is then the value, it could be coming even from some
                  // other source, which is not available at this point??? quite
                  // difficult actually to create this totally composable in all
                  // the cases but let's give it a try after all...
                  result[i] = val;
                  doneCnt++;
                  if (!called && (doneCnt == list.length)) {
                    called = true;
                    fn(result.join(""));
                  }
                }, dataItem);
              }(i));

            } else {
              result[i] = list[i] || "";
              doneCnt++;
            }
          }
          if (!called && (doneCnt == list.length)) {
            fn(result.join(""));
          }
        }
        _myTrait_.createElemFromTpl = function(elem, model) {

          /*
                           me._addModelTemplate( elem, {
                               baseTpl : html.trim(),
                               classTpl : templateList,
                               cProp : cProp
                           });
           */

          // if you need to find again the compiled template options for this current
          // view for the template...
          var tpl = this._findModelTemplate(elem);

          console.log("Tpl", tpl);

          var cProp = tpl.cProp,
            html = tpl.baseTpl,
            m = model,
            me = this;

          if (cProp) {
            var templateList = tpl.classTpl;
            if (m.data[cProp]) {
              var subClass = m.data[cProp],
                h = templateList[subClass];
              if (h) {
                h = h.trim();
                var newDom = me.createNewTemplate(m, h, elem.tagName);
                return newDom; // elem.appendChild( newDom );  
              }
            }
          } else {
            var newDom = me.createNewTemplate(m, html, elem.tagName);
            return newDom; // elem.appendChild( newDom );
          }
        }
        _myTrait_.createViewType = function(name, data, options) {

          if (_regTypes[name]) {
            return _regTypes[name].fn(data, options);
          }
        }
        _myTrait_.findTemplateList = function(str) {
          // So, the templates are of form {{firstname}} {{lastname}}

          // parset this list into parts...

          var parts = str.split("{{"),
            len = parts.length,
            hCnt = 0;

          if (len < 2) {
            return [str];
          }

          //console.log("*parts*");
          //console.log(parts);

          var list = [];
          for (var i = 0; i < parts.length; i++) {
            var part = parts[i];

            if (part.length == 0) continue;

            var rest = part.split("}}");
            if (rest.length > 1) {
              list.push("{{" + rest[0] + "}}");
              list.push(rest[1]);
            } else {
              // there was no end
              list.push(part);
            }
          }

          return list;
        }
        _myTrait_.getAceInstance = function(name, domElem, dataItem, varName, type, currentView) {

          if (!type) type = "html";

          if (!_aceInstances) _aceInstances = {};

          if (!_aceInstances[name]) {

            var editor = ace.edit(domElem);
            editor.setTheme("ace/theme/monokai");
            editor.getSession().setMode("ace/mode/" + type);

            var changeList = [];
            // Sending the editing messages is done here... 
            editor.getSession().on('change', function(e) {

              if (editor._noUpdates) return;

              // console.log("Got a change, which can be broadcasted ", e);

              editor._noUpdates = true;

              var conv = aceCmdConvert();
              var listS = aceCmdConvert().fromAce([e.data]);
              var simpleList = conv.simplify(listS);
              var item,
                list = [];
              while (item = simpleList.pop()) {
                list.push(item);

              }
              _dataLink.execCommand([13, varName, list, null, dataItem.__id]);

              editor._noUpdates = false;

            });


            var i = {
              dom: domElem,
              name: name,
              editor: editor
            };
            _aceInstances[name] = i;

            var w = _dataLink._createWorker(dataItem.__id, varName, _workers().fetch(12), domElem, {
              modelid: dataItem.__id,
              editor: editor,
              view: currentView
            });
            currentView.workers.push(w);


            /*
               editor.on("change", function(e) {
                   if(editor._noUpdates) return;
               
                   var conv = aceCmdConvert();
                   var listS = aceCmdConvert().fromAce( [e.data] );
                   var simpleList = conv.simplify(listS);
                   var item;
                   while(item=simpleList.pop()) {
                       list.push(item)
                   }
                   chList.val(JSON.stringify( conv.simplify(list) ) );
               });  
               */



          }

          return _aceInstances[name];


        }
        _myTrait_.getGUID = function(t) {
          return Math.random().toString(36).substring(2, 15) +
            Math.random().toString(36).substring(2, 15);
        }
        _myTrait_.getViewForElem = function(elem) {

          var id = elem.getAttribute("data-viewid");
          if (id) {
            return _viewsById[id];
          }
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(t) {


          if (!_namedModels) {
            _namedModels = {};
            _namedViews = {};
            _customDirectives = {};
            _regTypes = {};
            _dataLink = _docUp();
          }
        });
        _myTrait_.registerViewType = function(name, typeDef) {

          _regTypes[name] = typeDef;
        }
      }(this));;
      (function(_myTrait_) {
        var _eventOn;
        var _commands;
        var _authToken;
        var _authRandom;
        var _authUser;
        _myTrait_.guid = function(t) {

          return Math.random().toString(36).substring(2, 15) +
            Math.random().toString(36).substring(2, 15);

          /*        
           function s4() {
               return Math.floor((1 + Math.random()) * 0x10000)
                          .toString(16)
                          .substring(1);
             }
           
           return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                  s4() + '-' + s4() + s4() + s4();*/
        }
        _myTrait_.isArray = function(t) {

          return Object.prototype.toString.call(t) === '[object Array]';
        }
        _myTrait_.isDataTrait = function(obj) {

          if (obj.__dataTr) return true;
        }
        _myTrait_.isFunction = function(fn) {
          return Object.prototype.toString.call(fn) == '[object Function]';
        }
        _myTrait_.isObject = function(t) {

          if (typeof(t) == "undefined") return this.__isO;

          return t === Object(t);
        }
      }(this));;
      (function(_myTrait_) {
        var _modelTemplates;
        var _viewContent;
        var _viewTemplates;
        var _namedModels;
        var _namedViews;
        var _dataLink;
        var _customDirectives;
        var _viewsById;
        var _aceInstances;
        var _regTypes;
        _myTrait_.dom_setAttr = function(dom, name, value, ns) {

          if (name == "xlink:href") {
            dom.setAttributeNS('http://www.w3.org/1999/xlink', 'href', value);
          } else {
            if (ns) {
              if (dom.setAttributeNS) {
                dom.setAttributeNS(null, name, value);
              }
            } else {
              if (dom.setAttribute) {
                dom.setAttribute(name, value);
              }
            }
          }
        }
        _myTrait_.dom_setText = function(dom, text) {

          if (typeof(dom.textContent) != "undefined") {
            dom.textContent = text;
          } else {
            var div = document.createElement("div");
            div.innerHTML = text;
            var newText = div.textContent || div.innerText || "";
            text.innerHTML = newText;
          }
        }
      }(this));;
      (function(_myTrait_) {
        var domUtil;
        var _svgElems;
        _myTrait_.compile = function(html, startTag) {

          // return this.testData();

          // here is the view definition...
          var currentNode = {
            tagName: "DIV",
            tplData: null
          };

          var ns;

          if (startTag) {
            var dom = document.createElement(startTag);
            dom.innerHTML = html;
            currentNode.tagName = startTag;

            if (_svgElems[currentNode.tagName.toLowerCase()]) {
              ns = "svg";
            }

          } else {
            var dom = document.createElement("DIV");
            dom.innerHTML = html;
          }

          currentNode.tplData = this.parseNode(dom, ns);

          return currentNode;

        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(t) {


          if (!domUtil) {
            domUtil = _e();
            _svgElems = {
              "circle": "true",
              "rect": true,
              "path": true,
              "svg": true,
              "image": true,
              "line": true,
              "text": true,
              "tspan": true,
              "g": true,
              "pattern": true,
              "polygon": true,
              "polyline": true,
              "clippath": true,
              "defs": true,
              "textpath": true,
              "feoffset": true,
              "femerge": true,
              "femergenode": true,
              "fegaussianblur": true,
              "filter": true
            };
          }
        });
        _myTrait_.parseMustache = function(str) {
          var parts = str.split("{{"),
            len = parts.length,
            hCnt = 0;

          if (len < 2) {
            return [str];
          }

          //console.log("*parts*");
          //console.log(parts);

          var list = [];
          for (var i = 0; i < parts.length; i++) {
            var part = parts[i];

            if (part.length == 0) continue;

            var rest = part.split("}}");
            if (rest.length > 1) {
              list.push("{{" + rest[0] + "}}");
              list.push(rest[1]);
            } else {
              // there was no end
              list.push(part);
            }
          }

          return list;
        }
        _myTrait_.parseNode = function(dom, ns) {

          if (dom.nodeType == 8) return null;


          // here is the view definition...
          var currentNode = {
            tagName: dom.tagName,
            type: dom.nodeType,
            children: [],
            attributes: [],
            classTemplates: {},
            dataAttrs: {},
            ns: ns
          };


          if (currentNode.tagName) {
            var tn = currentNode.tagName.toLowerCase();
            if (_svgElems[tn]) {
              ns = "svg";
              if (tn != "svg") {
                currentNode.ns = "svg";
              }

            }
            currentNode.tagName = tn;
          } else {

          }


          var bIsInput = false;
          if (dom.nodeName && dom.nodeName.toLowerCase() == "input") {
            bIsInput = true;
          }

          var vStr, iValue;
          if (bIsInput) {
            if (iValue = dom.getAttribute("data-input-value")) {
              currentNode.value = iValue;
              currentNode.valueParts = this.parseTemplateParts(iValue);
            }
          }
          if (dom.value && (!iValue)) {
            currentNode.value = dom.value;
            currentNode.valueParts = this.parseTemplateParts(currentNode.value);
          }

          if (dom.attributes) {

            for (var i = 0; i < dom.attributes.length; i++) {
              var attrib = dom.attributes[i];
              if (attrib.specified) {
                var name = attrib.name,
                  value = attrib.value;

                if (name.substring(0, 4) == "data") {
                  currentNode.dataAttrs[name] = value;
                }
                currentNode.attributes.push([name, value, this.parseTemplateParts(value)]);
              }
            }
          }




          if (!dom.childNodes || dom.childNodes.length == 0) {
            currentNode.text = dom.textContent;
            currentNode.txtParts = this.parseTemplateParts(currentNode.text);
          }

          var childNodes = dom.childNodes;
          if (childNodes) {
            var len = childNodes.length;
            for (var i = 0; i < len; i++) {
              var child = childNodes[i];

              var newChild = this.parseNode(child, ns);
              if (newChild) currentNode.children.push(newChild);

            }
          }

          var cs;
          if (currentNode && (cs = currentNode.dataAttrs["data-class-switch"])) {
            currentNode.useClass = true;

            currentNode.classSwitch = cs;

            for (var ii = 0; ii < currentNode.children.length; ii++) {
              var tempCandidate = currentNode.children[ii];
              if (tempCandidate.dataAttrs) {
                var cName = tempCandidate.dataAttrs["data-class"];
                if (cName) {
                  currentNode.classTemplates[cName] = tempCandidate;
                }
              }
            }
          }

          return currentNode;
        }
        _myTrait_.parseTemplateParts = function(str) {

          var tplParts = {
            list: null,
            tokens: {},
            bHas: false
          }

          if (!str || str.length == 0) return null;


          var list = tplParts.list = this.parseMustache(str);
          for (var i = 0; i < list.length; i++) {
            var item = list[i];
            if (item.length > 3 && (item.charAt(0) == "{") && (item.charAt(1) == "{")) {
              tplParts.bHas = true;
              var vName = item.substring(2, item.length - 2);
              tplParts.tokens[i] = vName;
            }
          }

          return tplParts;


        }
      }(this));
    }
    var templateCompiler = function(a, b, c, d, e, f, g, h) {
      if (this instanceof templateCompiler) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != templateCompiler._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new templateCompiler(a, b, c, d, e, f, g, h);
    };
    templateCompiler._classInfo = {
      name: 'templateCompiler'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("templateCompiler", templateCompiler)
    templateCompiler.prototype = new templateCompiler_prototype();
    if (typeof(window) != 'undefined') window['templateCompiler'] = templateCompiler;
    if (typeof(window) != 'undefined') window['templateCompiler_prototype'] = templateCompiler_prototype;
    var _domAttrWorker_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.run = function(change, obj, targetObj, options) {

          if (!change || !targetObj) return;
          if (change[0] == 4) {
            var name = options.attrName,
              binds = options.binds,
              compiler = options.compiler,
              dom = targetObj;

            var prop = change[1];

            console.log("ATTR CHANGE ");
            console.log("Binds ", binds);

            // The old way:
            // targetObj.setAttribute(attrN, v);
            /*
           Object {    
                       list: Array[3], 
                       tokens: Object, 
                       bHas: true
                   }
                   bHas: true
                   list: Array[3]
                       0: "list-group-item "
                       1: "{{selected}}"
                       2: ""
                   length: 3
           */
            console.log("DOM ATTR worker binds ", binds);
            var list = binds.list,
              toks = binds.tokens,
              str = "";

            compiler.composeTokensToTxt(binds, obj, function(res) {
              console.log("Composed new attribute value for ", name);
              console.log(res);
              targetObj.setAttribute(name, res);
            });


          }

        }
      }(this));
    }
    var _domAttrWorker = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _domAttrWorker) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _domAttrWorker._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _domAttrWorker(a, b, c, d, e, f, g, h);
    };
    _domAttrWorker._classInfo = {
      name: '_domAttrWorker'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_domAttrWorker", _domAttrWorker)
    _domAttrWorker.prototype = new _domAttrWorker_prototype();
    var _svgAttrWorker_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.run = function(change, obj, targetObj, attrN) {


          if (!change || !targetObj) return;
          if (change[0] == 4) {
            var prop = change[1];
            var v = obj.data[prop];
            targetObj.setAttributeNS(null, attrN, v);
          }

        }
      }(this));
    }
    var _svgAttrWorker = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _svgAttrWorker) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _svgAttrWorker._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _svgAttrWorker(a, b, c, d, e, f, g, h);
    };
    _svgAttrWorker._classInfo = {
      name: '_svgAttrWorker'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_svgAttrWorker", _svgAttrWorker)
    _svgAttrWorker.prototype = new _svgAttrWorker_prototype();
    var _classWorker_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.run = function(change, obj, targetObj, myData) {


          if (!change || !targetObj) return;
          if (change[0] == 4) {

            var view = myData.view;

            var m = myData.m,
              t = myData.template;


            var subC = m.data[t.classSwitch],
              sT;
            if (!subC) {
              sT = t.classTemplates["default"];
            } else {
              sT = t.classTemplates[subC];
              if (!sT) sT = t.classTemplates["default"];
            }
            if (sT) {
              if (sT) {

                // this view replace does not work right now...

                var el = templateCompiler(); // ???
                //console.log("***** removing old workers *****");
                //console.log(view);

                //console.log("---");
                el._clearWorkers(view);
                //console.log("---");
                var up = _docUp();
                //console.log("---");

                // console.log("Compose template ", view.parentView, view);

                var parentDom = view.dom.parentNode;

                // => 
                // composeModelView( dom, ... da da da...)
                // var newDom = el.composeTemplate( m,  sT, view.parentView, view );
                var newDom = el.composeTemplate(m, sT, view);

                view.dom = newDom;

                //var parentDom = myData.dom.parentNode;
                parentDom.replaceChild(newDom, myData.dom);
                /*    
                      console.log("---");
                      */
                // add new worker to observe class changes to the new DOM instance
                var newWorker = up._createWorker(m.__id, t.classSwitch, _workers().fetch(5), newDom, {
                  view: view,
                  template: t,
                  m: m,
                  dom: newDom
                });
                view.workers.push(newWorker);

              }
            }

          }

        }
      }(this));
    }
    var _classWorker = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _classWorker) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _classWorker._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _classWorker(a, b, c, d, e, f, g, h);
    };
    _classWorker._classInfo = {
      name: '_classWorker'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_classWorker", _classWorker)
    _classWorker.prototype = new _classWorker_prototype();
    var _customDirWorker_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.run = function(change, obj, targetObj, options) {

          if (!change || !targetObj) return;
          if (change[0] == 4) {

            var tpl = options.tpl,
              binds = options.binds,
              dataItem = options.model,
              name = options.name,
              dom = targetObj;

            var myVars = {},
              rawValue;
            if (binds) {
              var list = binds.list,
                toks = binds.tokens;
              for (var i = 0; i < list.length; i++) {
                var vName;
                if (vName = toks[i]) {
                  var val = "";
                  if (typeof(dataItem.data[vName]) != "undefined") {
                    val = dataItem.data[vName] || "";
                  }
                  myVars[vName] = val;
                  options.value = val
                }
              }
            }
            options.vars = myVars;

            templateCompiler()._callCustom(name, dom, options);

            /*
                  _customDirectives[name](dom, {
                      currentView : currentView,
                      model : dataItem,
                      binds : binds,
                      vars : myVars,
                      value : rawValue
                  });
           */

          }

        }
      }(this));
    }
    var _customDirWorker = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _customDirWorker) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _customDirWorker._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _customDirWorker(a, b, c, d, e, f, g, h);
    };
    _customDirWorker._classInfo = {
      name: '_customDirWorker'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_customDirWorker", _customDirWorker)
    _customDirWorker.prototype = new _customDirWorker_prototype();
    var _listViewWorker_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.run = function(change, obj, viewObj, arrayDataObj) {

          if (!change || !viewObj) return;

          // insert
          if (change[0] == 7) {
            var tplB = templateCompiler();
            tplB.composeModelView(viewObj.dom, obj, viewObj);
          }

          // remove item from array...
          if (change[0] == 8) {

            var up = _docUp();

            var obj = up._find(change[2]),
              parent = up._find(change[4]),
              childNode = parseInt(change[2]);

            var i = 0,
              len = viewObj.childViews.length;

            console.log("Should remove ", obj);

            for (; i < len; i++) {
              var ww = viewObj.childViews[i];
              if (ww.dataid == change[2]) {
                console.log("Found the view to be removed");
                console.log(ww);
                up._removeView(ww);
                break;
              }
            }

            // The old solution removed ALL the views of the model:
            /*
               var viewOfModel = _docUp()._getModelViews( change[2] );
               console.log("The view model is ", viewOfModel);
               viewOfModel.forEach( function(view) {
                   // Removing all the views
                   console.log("Removing view ", view);
                   up._removeView( view );
               });
               */
          }

          // move object in list
          if (change[0] == 12) {

            var up = _docUp();
            var obj = up._find(change[1]),
              parent = up._find(change[4]),
              toIndex = parseInt(change[2]);

            var oldIndex = parseInt(change[3]);
            var viewDom = viewObj.dom;
            var itemToMove = viewDom.children[oldIndex];
            var itemParent;

            itemParent = itemToMove.parentNode;

            // moving the item...
            itemParent.removeChild(itemToMove);

            var oldItemAtPos = viewDom.children[toIndex];
            itemParent.insertBefore(itemToMove, oldItemAtPos);

            console.log("Moving the item ", viewObj);
            console.log("Old " + oldIndex + " new " + toIndex);
            // move item in the view list...   
            var theV = viewObj.childViews.splice(oldIndex, 1);

            console.log("theV ", theV, theV[0]);

            viewObj.childViews.splice(toIndex, 0, theV[0]);


          }


        }
      }(this));
    }
    var _listViewWorker = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _listViewWorker) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _listViewWorker._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _listViewWorker(a, b, c, d, e, f, g, h);
    };
    _listViewWorker._classInfo = {
      name: '_listViewWorker'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_listViewWorker", _listViewWorker)
    _listViewWorker.prototype = new _listViewWorker_prototype();
    var _workers_prototype = function() {;
      (function(_myTrait_) {
        var _allWorkers;
        _myTrait_.fetch = function(index) {
          return _allWorkers[index];
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(t) {

          if (!_allWorkers) {

            _allWorkers = [
              null, // 
              _domTextWorker(), // 1
              _inputWorker(), // 2
              _domAttrWorker(), // 3
              _svgAttrWorker(), // 4
              _classWorker(), // 5
              _customDirWorker(), // 6
              _listViewWorker(), // 7
              _rawTextWorker(), // 8
              _templateWorker(), // 9
              _abstractWorker(), // 10
              _domIfWorker(), // 11
              _aceEditorWorker(), // 12
              _ifThenWorker(), // 13,
              _objectEventWorker() // 14
            ];


          }

        });
      }(this));
    }
    var _workers = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _workers) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _workers._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _workers(a, b, c, d, e, f, g, h);
    };
    _workers._classInfo = {
      name: '_workers'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_workers", _workers)
    _workers.prototype = new _workers_prototype();
    var _rawTextWorker_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.run = function(change, obj, targetObj, options) {

          if (!change || !targetObj) return;

          // how to create something new...
          if (change[0] == 4) {


            // console.log("*** worker for raw data going on ***");

            var tpl = options.tpl,
              dataItem = options.model,
              dom = targetObj;

            dataItem = _docUp()._find(options.modelid);

            // console.log(dom);
            var rawText = "";

            /*
               This function needs to create a raw text worker.
               
               For example, the contents of the script tag might be:
               
                background-color : {{bgColor}}px;
                font-size : {{smallFont}}px;
               
               */

            var list = tpl.txtParts.list,
              toks = tpl.txtParts.tokens;
            for (var i = 0; i < list.length; i++) {
              var vName;
              if (vName = toks[i]) {
                var val = "";
                if (typeof(dataItem.data[vName]) != "undefined") {
                  val = dataItem.data[vName] || "";
                }
                rawText += val;

              } else {
                rawText += list[i] || "";
              }
            }

            // console.log(rawText);

            if (dom.cssText) {
              dom.cssText = rawText;
            } else {
              // console.log("Should set the text content of style tag");
              dom.textContent = rawText;
            }
          }
        }
      }(this));
    }
    var _rawTextWorker = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _rawTextWorker) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _rawTextWorker._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _rawTextWorker(a, b, c, d, e, f, g, h);
    };
    _rawTextWorker._classInfo = {
      name: '_rawTextWorker'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_rawTextWorker", _rawTextWorker)
    _rawTextWorker.prototype = new _rawTextWorker_prototype();
    var _templateWorker_prototype = function() {;
      (function(_myTrait_) {
        var _dataLink;
        _myTrait_.run = function(change, obj, targetObj, options) {

          if (!change || !targetObj) return;

          // how to create something new...
          if (change[0] == 4) {


            //  console.log("*** template worker composes the template again, if the value changes ***");

            var dataItem,
              compiler = options.compiler,
              vName = change[1], // the property that has changed
              newTemplateValue = change[2], // This is what to has to be compiled
              dom = targetObj;

            dataItem = _docUp()._find(options.modelid);

            // Now, there's a new set of workers, the old workers should be released...
            var jsTpl = compiler.compile(newTemplateValue);
            var subTplDOM = compiler.composeTemplate(dataItem, jsTpl);

            compiler._clearWorkers(options.view);

            // And then, you just have to switch the items...
            // TODO: clear all the workers...

            dom.parentNode.replaceChild(subTplDOM, dom);

            // dom.appendChild( subTplDOM );

            if (!_dataLink) _dataLink = _docUp();

            var myView = compiler.getViewForElem(subTplDOM);

            var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(9), subTplDOM, {
              modelid: dataItem.__id,
              compiler: compiler,
              view: myView
            });
            myView.workers.push(w);

          }
        }
      }(this));
    }
    var _templateWorker = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _templateWorker) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _templateWorker._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _templateWorker(a, b, c, d, e, f, g, h);
    };
    _templateWorker._classInfo = {
      name: '_templateWorker'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_templateWorker", _templateWorker)
    _templateWorker.prototype = new _templateWorker_prototype();
    var _abstractWorker_prototype = function() {;
      (function(_myTrait_) {
        var _dataLink;
        _myTrait_.run = function(change, obj, targetObj, options1, options2) {

          if (!change || !targetObj) return;

          var options;
          if (options2) {
            options = options2;
          } else {
            options = options1;
          }

          var dataItem,
            fn = options.fn,
            callOpts = options.callOpts,
            vName = options.varName, // the property that has changed
            dom = options.dom;

          //console.log("---- abstract worker ");
          //console.log("Options ", options);
          //console.log("Options ", options2);
          //console.log("Target ", targetObj);
          //console.log("Old target ",options.dom);

          dataItem = _docUp()._find(options.modelid);

          if (dom.parentNode) {

            //console.log("Data item ", dataItem);
            //console.log("fn ", fn);

            var newDom = fn(dataItem.data[vName], {
              data: dataItem,
              view: callOpts.view,
              dom: dom.parentNode
            });

            dom.parentNode.replaceChild(newDom, dom);

            options.dom = newDom;
          } else {
            // console.log("No parent node!!!!!!!!!");
          }

          // If there is a set of workers but in this case we assume there is not...
          // var myView = compiler.getViewForElem( subTplDOM ); 
          // compiler._clearWorkers( options.view );



        }
      }(this));
    }
    var _abstractWorker = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _abstractWorker) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _abstractWorker._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _abstractWorker(a, b, c, d, e, f, g, h);
    };
    _abstractWorker._classInfo = {
      name: '_abstractWorker'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_abstractWorker", _abstractWorker)
    _abstractWorker.prototype = new _abstractWorker_prototype();
    var _domIfWorker_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.run = function(change, obj, targetObj) {

          if (!change || !targetObj) return;

          var dom = targetObj;


          if (change[0] == 4) {
            var prop = change[1];
            var v = obj.data[prop];

            if (v) {
              var entryClass = dom.getAttribute("data-entry-class");
              dom.style.display = "block";
              if (entryClass) $(dom).addClass(entryClass);
              var exitClass = dom.getAttribute("data-exit-class");
              if (exitClass) $(dom).removeClass(exitClass);
            } else {
              var entryClass = dom.getAttribute("data-entry-class");
              if (entryClass) {
                $(dom).removeClass(entryClass);
              }

              var exitClass = dom.getAttribute("data-exit-class");
              if (exitClass) {
                $(dom).addClass(exitClass);
                setTimeout(function() {
                  dom.style.display = "none";
                }, 500);
              } else {
                dom.style.display = "none";
              }
            }

          }

        }
      }(this));
    }
    var _domIfWorker = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _domIfWorker) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _domIfWorker._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _domIfWorker(a, b, c, d, e, f, g, h);
    };
    _domIfWorker._classInfo = {
      name: '_domIfWorker'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_domIfWorker", _domIfWorker)
    _domIfWorker.prototype = new _domIfWorker_prototype();
    var _aceEditorWorker_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.run = function(change, obj, targetObj, options) {


          if (!change) return;

          // how to create something new...
          if (change[0] == 4) {
            var editor = options.editor,
              dataItem = options.model,
              dom = targetObj;

            // options.modelid

            if (editor._noUpdates) {

            } else {


              var up = _docUp();

              if (!up.isDoingRemote()) {
                console.log("Should update the ACE editor value directly here... ");
                editor._noUpdates = true;
                editor.setValue(change[2], 1);
                editor._noUpdates = false;
              }
              //var s = editor.getSession();
              //var doc = s.getDocument();          

            }
          }

          if (change[0] == 13) {

            // options.modelid

            var editor = options.editor,
              dataItem = options.model,
              dom = targetObj;

            dataItem = _docUp()._find(options.modelid);
            // Deltas should be in the second var.
            /*
               var conv = aceCmdConvert();
               obj.data[prop] = conv.runToString( obj.data[prop], a[2]);    
               */

            var aceList = aceCmdConvert().runToAce(change[2]);

            editor._noUpdates = true;
            var s = editor.getSession();
            var doc = s.getDocument();
            //console.log(change,obj,targetObj);
            //console.log("... applying ... ");
            //console.log(aceList);
            doc.applyDeltas(aceList);
            editor._noUpdates = false;

          }

          /*
           
           */
        }
      }(this));
    }
    var _aceEditorWorker = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _aceEditorWorker) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _aceEditorWorker._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _aceEditorWorker(a, b, c, d, e, f, g, h);
    };
    _aceEditorWorker._classInfo = {
      name: '_aceEditorWorker'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_aceEditorWorker", _aceEditorWorker)
    _aceEditorWorker.prototype = new _aceEditorWorker_prototype();
    var _ifThenWorker_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.run = function(change, obj, targetObj, options) {
          //console.log("******* if Then Worker ******");
          //console.log(change);
          //console.log(options);

          if (!change) return;

          // how to create something new...
          if (change[0] == 4) {


            //console.log("... should be doing something");
            // options.modelid
            var dom = targetObj;

            var up = _docUp();
            var dataItem = up._find(options.modelid);
            // Then, we can set the value...

            console.log("******* if Then Worker ******");
            console.log(options);

            if (options.thenCtrl) {

              console.log("==>Calling ctr");
              up._callController(options.thenCtrl, options.modelid, dom)


            }


          }

        }
      }(this));
    }
    var _ifThenWorker = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _ifThenWorker) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _ifThenWorker._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _ifThenWorker(a, b, c, d, e, f, g, h);
    };
    _ifThenWorker._classInfo = {
      name: '_ifThenWorker'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_ifThenWorker", _ifThenWorker)
    _ifThenWorker.prototype = new _ifThenWorker_prototype();
    var _objectEventWorker_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.run = function(change, obj, targetObj, options, options2) {
          //console.log("******* if Then Worker ******");
          //console.log(change);
          //console.log(options);

          if (!change) return;

          // how to create something new...
          if (change[0] == 4) {
            // createPropertyUpdateFn

            // console.log("%c  set for objects, property updf ", "background:orange;color:white");
            console.log("--- set value --- ");
            var dom = targetObj;
            var up = _docUp();

            var dI = _data();
            dI.createPropertyUpdateFn(change[1], null);

            var dataItem = up._find(options.modelid);

            if (dataItem.__undone) return;

            if (options && options.eventObj) {
              if (change[3] != change[2]) {
                options.eventObj.trigger(change[1], change[2]);
              }
            }

          }

          if (options2) {
            var origOptions = options;
            options = options2;
          }


          if (change[0] == 5) {
            var up = _docUp();
            var dataItem = up._find(change[2]),
              dataItem2 = up._find(change[4]);

            if (dataItem.__undone) return;
            if (dataItem2.__undone) return;

            var dc = _data();

            if (dc.findFromCache(change[4])) {

              var dI = _data(change[4]),
                setObj = _data(change[2]),
                prop = change[1];

              if (!dI) return;
              if (!setObj) return;

              dI[prop] = setObj;
            }
            // could trigger some event here perhaps...   
          }

          // __removedAt
          if (change[0] == 8) {

            var dom = targetObj;
            var up = _docUp();
            var dataItem = up._find(change[2]);
            if (dataItem.__undone) return;

            if (options.bListenMVC && options.eventObj) {
              options.eventObj.trigger("remove", dataItem.__removedAt);
            }
          }

          // insert
          if (change[0] == 7) {

            var up = _docUp();

            var parentObj = up._find(change[4]),
              insertedObj = up._find(change[2]);

            if (parentObj.__undone) return;
            if (insertedObj.__undone) return;

            var index = parentObj.data.indexOf(insertedObj);

            if (options.bListenMVC && options.eventObj) {
              options.eventObj.trigger("insert", index);
            }
          }

          if (change[0] == 12) {

            var up = _docUp();

            var parentObj = up._find(change[4]),
              index = parseInt(change[2]),
              len = parentObj.data.length;

            if (parentObj.__undone) return;

            for (var i = 0; i < len; i++) {
              var m = parentObj.data[i];
              if (m.__id == change[1]) {
                targetObj = m;
                break;
              }
            }

            if (targetObj && targetObj.__undone) return;

            console.log("Options for cmd 12 ");
            console.log(targetObj);

            // move item, this may not be working as expected...
            var fromIndex = targetObj.__fromIndex; //  up._getExecInfo().fromIndex;
            console.log(fromIndex);
            // console.log("about to trigger move with ", targetObj, change[2], index, len, parentObj );

            if (targetObj) {
              var targetIndex = parseInt(change[2]);
              if (options.bListenMVC && options.eventObj) {
                // console.log("Triggering move ", fromIndex, targetIndex);
                options.eventObj.trigger("move", {
                  from: fromIndex,
                  to: targetIndex
                });
              }
            }
          }

        }
      }(this));
    }
    var _objectEventWorker = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _objectEventWorker) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _objectEventWorker._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _objectEventWorker(a, b, c, d, e, f, g, h);
    };
    _objectEventWorker._classInfo = {
      name: '_objectEventWorker'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_objectEventWorker", _objectEventWorker)
    _objectEventWorker.prototype = new _objectEventWorker_prototype();
    var _data_prototype = function() {;
      (function(_myTrait_) {
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(t) {

        });
      }(this));;
      (function(_myTrait_) {
        var _eventOn;
        var _commands;
        var _authToken;
        var _authRandom;
        var _authUser;
        var _up;
        var _dataCache;
        var _createdFunctions;
        _myTrait_.__dataTr = function(t) {

        }
        _myTrait_._collectObject = function(me, what, cb) {
          if (!this.isArray(what)) what = what.split(",");

          var myData = {};
          what.forEach(
            function(n) {
              myData[n] = me[n]();
              me.on(n, function() {
                myData[n] = me[n]();
                console.log(n + " = " + me[n]() + " from " + me.getID());
                cb(myData);
              });
            }
          );
          cb(myData);
        }
        _myTrait_._copyAs = function(newFileName) {

          var me = this;

          var chData = me._channelInfo;
          if (!chData) return;

          var raw = this.toData();
          me._reGuidRawData(raw);

          var newCh = {
            ip: chData.ip,
            port: chData.port,
            sandbox: chData.sandbox,
            path: chData.path,
            file: newFileName,
            createWith: raw
          };

          var obj = _data({}, {
            channel: newCh
          });

          return obj;

        }
        _myTrait_._embedFileURL = function(name) {
          var url = name || this._findURL();
          var parts = this._parseURL(url);

          var metaURL = parts.protocol + "://" + parts.ip + ":" + parts.port + "/" + parts.sandbox + "/" + parts.path + "/" + this.getID() + ".embed";

          return metaURL;
        }
        _myTrait_._findActiveChannel = function(t) {

          if (this._activeChannel) {
            if (this._activeChannel) {
              return this._activeChannel;
            }
          }

          var p = this.parent();
          if (p) return p._findActiveChannel();
        }
        _myTrait_._findRootDoc = function(t) {

          if (this._isRootDoc) return this;

          var p = this.parent();
          if (p) return p._findRootDoc();
          return this;


        }
        _myTrait_._findURL = function(t) {

          var o = this;

          while (!o._docData.__radioURL) {
            o = o.parent();
          }

          if (o && o._docData && o._docData.__radioURL) return o._docData.__radioURL;

        }
        _myTrait_._forMembers = function(fn) {
          var me = this;

          if (this.isArray()) {
            for (var i = 0; i < this._data.length; i++) {
              var o = this._data[i];
              if (this.isObject(o)) {
                if (o.__dataTr) {
                  fn(o);
                }
              }
            }
          } else {
            this._members.forEach(function(n) {
              if (me[n]) fn(me[n]);
            });
          }
        }
        _myTrait_._getCommandHistory = function(t) {

          return _up._getCommandHistory(this._findURL());
        }
        _myTrait_._initializeData = function(docData, options) {


          // pointer to the docUp data
          this._data = docData.data;
          this._docData = docData;

          // __removedAt
          var worker = _up._createWorker(this._docData.__id,
            "*",
            _workers().fetch(14),
            null, {
              bListenMVC: true,
              modelid: this._docData.__id,
              eventObj: this
            });

          // The data to be used as initialising
          var data = docData.data;

          if (data instanceof Array) {

            for (var n in data) {

              // Rather dubious way of doing it, but let's try it...
              this[n] = _data(data[n]);

            }

          } else {

            for (var n in data) {

              if (data.hasOwnProperty(n)) {
                var v = data[n];

                //console.log("*** property ", n);

                // functions are here assumed to be variables from another object...
                if (this.isFunction(v)) {
                  // ???? Should we be emitting the function forward in this case, it should not be
                  // possible to have the function as data parameter in this case... maybe?
                  continue;
                }

                // _data

                if (!this.isFunction(v) && (v === Object(v) || (v instanceof Array))) {

                  this[n] = new _data(v, options);
                  continue;

                }

                // just plain member variable function setting 
                if (!this.isFunction(v) && !this.isObject(v) && !this.isArray(v)) {

                  // ....
                  if (!this[n]) {
                    this.createPropertyUpdateFn(n, v);
                  }

                }

              }
            }

          }

        }
        _myTrait_._makeEmbeddable = function(t) {

          // The root doc might just create a meta channel for itself...???? hard to say if this really
          // is working or not... the root doc could perhapse be linked, but right now it's not clear
          // if that works like for the normal documents
          if (!this._docData.__p) {
            console.error("ERROR: Can not make root document embeddable, it already is");
            return;
          }

          if (this._docData.__rid) {
            console.error("ERROR: The object is alrady remoted");
            return;
          }

          var url = this._findURL(),
            me = this;
          var copy = _data(this.serialize());

          copy.then(
            function() {

              var metaURL = copy._metaFileURL(url),
                embedURL = copy._embedFileURL(url);

              console.log("Might be creting");
              console.log("-", metaURL);
              console.log("-", embedURL);

              var simpleObj = _data({});
              simpleObj.then(function() {
                console.log("The command list of this object ");
                console.log(simpleObj._docData.__ctxCmdList);
              })


              return;

              var embedDoc = _data(embedURL, {
                createWith: copy.toData()
              });
              var metaDoc = _data(metaURL, {
                createWith: {
                  items: [{
                    channel: url
                  }]
                }
              });

              // When the embedded document channel has been created...
              embedDoc.then(function() {

              });

            });
        }
        _myTrait_._metaFileURL = function(name) {
          var url = name || this._findURL();
          var parts = this._parseURL(url);

          var metaURL = parts.protocol + "://" + parts.ip + ":" + parts.port + "/" + parts.sandbox + "/" + parts.path + "/" + this.getID() + ".ln";

          return metaURL;

        }
        _myTrait_._moveCmdListTo = function(newParent) {

          if (this.__cmdList && newParent) {
            var root = newParent._findRootDoc();
            if (root) {
              if (!root.__cmdList) root.__cmdList = [];
              if (!root.__ctxCmdList) root.__ctxCmdList = [];
              if (root == this) return;
              if (!root.__cmdList.concat) {
                console.log("*cmdlist*");
                console.log(JSON.stringify(root.__cmdList));
              }
              root.__cmdList = root.__cmdList.concat(this.__cmdList);
              this.__cmdList = [];
              root.__ctxCmdList = root.__ctxCmdList.concat(this.__ctxCmdList);
              this.__ctxCmdList = [];
            }
          }
        }
        _myTrait_._parseURL = function(url) {

          var parts1 = url.split("://");
          var protocol = parts1.shift(),
            rest = parts1.shift();
          var serverParts = rest.split("/"),
            ipAndPort = serverParts.shift(),
            iParts = ipAndPort.split(":"),
            ip = iParts[0],
            port = iParts[1],
            sandbox = serverParts.shift(),
            fileName = serverParts.pop(),
            path = serverParts.join("/");

          return {
            url: url,
            ip: ip,
            port: port,
            sandbox: sandbox,
            path: path,
            file: fileName,
            protocol: protocol
          };
        }
        _myTrait_._reGuidRawData = function(data) {

          console.log("_reGuidRawData");

          if (this.isArray(data)) {
            var me = this;
            data.forEach(function(i) {
              me._reGuidRawData(i)
            });
          } else {
            if (this.isObject(data)) {
              for (var n in data) {
                if (!data.hasOwnProperty(n)) continue;
                if (n == "__id") {
                  console.log("Changing the __id");
                  data[n] = this.guid();
                  continue;
                }
                if (this.isObject(data[n])) this._reGuidRawData(data[n]);
                if (this.isArray(data[n])) this._reGuidRawData(data[n]);
              }
            }
          }
        }
        _myTrait_._setAuthToken = function(authUser, authPassword) {

          _authUser = authUser;
          _authToken = authPassword;


        }
        _myTrait_._setBroadcastManager = function(mgrObj) {

          this.__bcManager = mgrObj;
        }
        _myTrait_.addController = function(c) {
          if (!this._controllers)
            this._controllers = [];

          if (this._controllers.indexOf(c) >= 0) return;

          this._controllers.push(c);
        }
        _myTrait_.askChannelQuestion = function(question, data, cb) {


          var url = this._findURL();
          console.log("Asking, the URL was " + url);

          var doc = _docUp(url);

          doc.then(function() {
            console.log("Resolved the doc, asking the channel the question " + question);
            doc._ask(question, data, cb);
          });

          // var doc = docRadio(rl)


        }
        _myTrait_.at = function(i) {
          var ii = this._docData.data[i];
          if (ii) return _data(ii);
        }
        _myTrait_.clear = function(t) {
          var len = this.length();
          while (len--) {
            this.pop();
          }
        }
        _myTrait_.clone = function(t) {
          return _data(this.serialize());
        }
        _myTrait_.copyToData = function(t) {

          var raw = this.toData();
          this._reGuidRawData(raw);

          return raw;
        }
        _myTrait_.createArrayField = function(n, v, validators) {

          // ***** basicly, this is all that is required... perhaps...????
          // this[n] = _data(data[n]);

          var df,
            me = this;
          if (v._docData) {
            df = v;
          } else {
            df = _data(v);
          }

          //console.log("Entering the create field ");
          //console.log(df, me, n, v);

          if (me[n]) {
            //console.log("There already was field ", n);
            return this;
          } else {
            //console.log("... the field should be created...");
            //console.log(df);
          }

          df.then(function() {
            _up.execCommand([5, n, df.getID(), null, me.getID()]);
          });

          me[n] = df;

          return this;

        }
        _myTrait_.createField = function(n, defaultValue) {

          this.set(n, defaultValue || null);

        }
        _myTrait_.createObjectField = function(n, v) {
          var df,
            me = this;
          if (v._docData) {
            df = v;
          } else {
            df = _data(v);
          }

          var myPromise = _promise();

          // console.log("Entering the create field ");
          // console.log(df, me, n, v);
          // this.createPropertyUpdateFn(n);

          if (me.hasOwn(n)) {
            //console.log("There already was field ", n);
            myPromise.resolve(false);
            return myPromise;
          } else {
            //console.log("... the field should be created...");
            //console.log(df);
          }

          df.then(function() {
            _up.execCommand([5, n, df.getID(), null, me.getID()]).then(function() {
              myPromise.resolve();
            });
          });

          me[n] = df;

          return myPromise;
        }
        _myTrait_.createPropertyUpdateFn = function(name, value) {

          // ???????? Could you just create the properties according to their prototypal values...???
          // *** The prototype might have room for one function and others could be placed in the upper
          // level functions.... pretty weird but still, possible...

          var me = this;
          if (!_myTrait_[name]) {
            _myTrait_[name] = function(value) {
              // NOTE: does not support delegating the functions anymore with
              // something like this.x = ...

              if (!this._docData) {
                //console.error("Does not have docdata");
                //console.log(this);
                return;
              }

              var d = this._docData.data;
              if (!d) return;

              if (typeof(value) == "undefined") {
                // var o = _up._find( me._data.__id);
                // find the object and return
                return d[name];
              }
              if (d[name] == value) return;
              if (!this._enterCtx(name)) return;
              _up.execCommand([4, name, value, null, this._docData.__id]);
              this._leaveCtx(name)
              return this;
            };
            _createdFunctions[name] = true;
          } else {
            // *** not possible to create the function or property for the object...?

          }


          return;

          // the "real" implementation....


          (function(n, v) {
            var datao = me._data;
            me[n] = function(value, getme) {

              if (getme) {
                return {
                  me: me,
                  name: n
                };
              }
              if (typeof(value) == "undefined") return datao[n];

              if (me.isFunction(value)) {
                if (!value._dataF) {
                  me.on(n, function(o, v) {
                    value(v);
                  });
                  return me;
                } else {
                  me[n] = value;
                  // here you should trigger the update event...
                  var oo = value(null, true);
                  oo.me.on(oo.name, function(o, newV) {
                    lastChange.item = me;
                    lastChange.field = oo.name;
                    lastChange.value = newV;
                    me.emitValue("childChange", lastChange);
                  });
                  return me;
                }
              }

              if (me._validators) {
                if (me._validators[n]) {

                  var msg;
                  if (msg = me._validators[n](value)) {
                    me.trigger("invalid-" + n, msg);
                    return me;
                  } else {
                    me.trigger("valid-" + n, value);
                  }
                }
              }

              if (!me._enterCtx(n)) return;

              var bChange = datao[n] != value;

              datao[n] = value;

              if (typeof(datao[n]) == "undefined" || bChange)
                me.saveCommand("set", n, value, datao[n]);

              // console.log("Setting", n, "on", me, "to ", value);
              if (bChange) {
                me.trigger(n, value);
                me.trigger("change", n);


                lastChange.item = me;
                lastChange.field = n;
                lastChange.value = value;
                me.emitValue("childChange", lastChange);
              }
              me._leaveCtx(n)
              return me;
            }
            me[n]._dataF = true;


          }(name, value));

          me.saveCommand("set", name, value, null);
        }
        _myTrait_.dbDefineSync = function(variables) {
          if (variables) {
            var me = this;
            variables.forEach(function(v) {
              var sv = me.dbFindSyncVar(v.name, true);
              for (var n in v) {
                if (v.hasOwnProperty(n)) {
                  sv[n] = v[n];
                }
              }
            });
          }
        }
        _myTrait_.dbFindSyncVar = function(name, createIfNotFound) {
          if (!this.__dbSync) {
            this.__dbSync = [];
          }

          var found,
            me = this;
          for (var i = 0; i < this.__dbSync.length; i++) {
            var v = this.__dbSync[i];
            if (v.name == name) return v;
          };

          if (createIfNotFound) {
            var v = {
              name: name,
              dirty: false
            };
            this.__dbSync.push(v);

            this.on(name, function(o, value) {
              v.dirty = true;
            });

          }
          return v;
        }
        _myTrait_.dbSync = function(t) {
          var found,
            me = this;

          // Q : how to report errors when saving...???

          for (var i = 0; i < this.__dbSync.length; i++) {
            var v = this.__dbSync[i];
            if (v.dirty) {
              if (v.syncFn) {
                if (!v.promises) v.promises = [];
                console.log("The variable ", v);
                v.promises.push(v.syncFn());
                v.dirty = false;
              }
            }
            // if(v.name==name) return v;
          };
        }
        _myTrait_.emitValue = function(scope, data) {
          if (this._processingEmit) return this;

          this._processingEmit = true;
          // adding controllers to the data...
          if (this._controllers) {
            var cnt = 0;
            for (var i = 0; i < this._controllers.length; i++) {
              var c = this._controllers[i];
              if (c[scope]) {
                c[scope](data);
                cnt++;
              }
            }

            // this._processingEmit = false;
            // Do not stop emitting the value to the parents...
            // if(cnt>0) return this;
          }

          /*
           if(this._controller) {
               if(this._controller[scope]) {
                  this._controller[scope](data);
                  return;
               }
           }
           */

          if (this._valueFn && this._valueFn[scope]) {
            this._valueFn[scope].forEach(function(fn) {
              fn(data);
            });
          }
          if (1) {
            if (this._parent) {
              if (!this._parent.emitValue) {
                // console.log("Strange... no emit value in ", this._parent);
              } else {
                this._parent.emitValue(scope, data);
              }
            }
          }
          this._processingEmit = false;
        }
        _myTrait_.extendWith = function(obj) {


          for (var n in obj) {
            var fn = obj[n];
            if (this.isFunction(fn)) {
              _myTrait_[n] = fn;
            }
          }
        }
        _myTrait_.find = function(path) {
          // should find the item from the path...

          console.log("*** find with " + path);

          var dataObj = _up._getObjectInPath(path, this._docData);

          return _data(dataObj.__id);
        }
        _myTrait_.findRootDocup = function(t) {

          var p = this,
            np;

          while (np = p.parent()) {
            p = np;
          }

          return _docUp(p._docData);
        }
        _myTrait_.forEach = function(fn) {

          // this[n]
          // here is the critical decision, do we keep the _data objects subitems in order or just
          // fetch them from the local index of all objects?

          // this is not safe because of the order may have changed...

          var p = _promise(),
            myProm = _promise(),
            list = [],
            me = this;

          this._docData.data.forEach(function(d) {
            if (d.__undone) return;
            list.push(_data(d));
          });

          p.all(list).then(function() {
            me._docData.data.forEach(function(data) {
              if (data.__undone) return;
              var d = _data(data);
              fn(d);
            });
            myProm.resolve(true);
          });
          p.resolve(true);

          return myProm;




        }
        _myTrait_.get = function(name) {

          if (this[name]) {
            if (this.isFunction(this[name]))
              return this[name]();
            return this[name];
          }
        }
        _myTrait_.getID = function(t) {

          return this._docData.__id;
        }
        _myTrait_.getRemoteID = function(t) {

          if (this._docData && this._docData.__rid) return this._docData.__rid;
        }
        _myTrait_.guid = function(t) {

          return Math.random().toString(36).substring(2, 15) +
            Math.random().toString(36).substring(2, 15);

          /*        
           function s4() {
               return Math.floor((1 + Math.random()) * 0x10000)
                          .toString(16)
                          .substring(1);
             }
           
           return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                  s4() + '-' + s4() + s4() + s4();*/
        }
        _myTrait_.hasOwn = function(name) {

          if (typeof(this._docData.data[name]) != "undefined") {
            return true;
          }
          return false;
        }
        _myTrait_.indexOf = function(t) {
          return _up.indexOf(this._docData);
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(data, options, notUsed, notUsed2) {


          if (!_up) _up = _docUp({});
          if (!_dataCache) {
            _dataCache = {};
            _createdFunctions = {};
          }
        });
        _myTrait_.insertAt = function(index, v) {



          this.push(v);
          var lastItem = this.at(this.length() - 1);

          _up.moveItemToPos(lastItem.getID(), index);

          return this;


          /*
               if(a[0]==12) {
                   var obj = this._find( a[4] ),
                       prop = "*",
                       len = obj.data.length,
                       targetObj,
                       i = 0;
                   
                   for(i=0; i< len; i++) {
                       var m = obj.data[i];
                       if(m.__id == a[1]) {
                           targetObj = m;
                           break;
                       }
                   }
                   
                   // Questions here:
                   // - should we move command list only on the parent object, not the child
                   //  =>  this._moveCmdListToParent(targetObj); could be
                   //      this._moveCmdListToParent(obj);
                   // That is... where the command is really saved???
                   // is the command actually written anywhere???
                   //  - where is the writeCommand?
                   // 
                   // Moving the object in the array
                   if(targetObj) {
                       var targetIndex = parseInt(a[2]);
                       
                       //console.log("==== MOVING ==== ", targetObj);
                       //console.log(i + "=> "+targetIndex);
                       
                       obj.data.splice(i, 1);
                       obj.data.splice(targetIndex, 0, targetObj);
                       this._cmd(a, obj, targetObj);
                       
                       if(!(isRemote || _isRemoteUpdate)) {
                           this.writeCommand(a);
                       }           
                       
                   }
               
               }
           */
        }
        _myTrait_.isArray = function(t) {

          if (typeof(t) == "undefined") {
            if (!this._docData) return false;
            if (!this._docData.data) return false;
            return this.isArray(this._docData.data);
          }
          return Object.prototype.toString.call(t) === '[object Array]';
        }
        _myTrait_.isDataTrait = function(obj) {

          if (obj._docData) return true;
        }
        _myTrait_.isFunction = function(fn) {
          return Object.prototype.toString.call(fn) == '[object Function]';
        }
        _myTrait_.isObject = function(t) {

          if (typeof(t) == "undefined") {
            if (!this._docData) return false;
            if (!this._docData.data) return false;
            return this.isObject(this._docData.data);
          }

          return t === Object(t);
        }
        _myTrait_.item = function(i) {
          var ii = this._docData.data[i];
          if (ii) return _data(ii);
        }
        _myTrait_.keys = function(fn) {
          var i = 0;
          for (var n in this._docData.data) {
            fn(n, this._docData.data[n], this._docData.data);
            // fn( n, i++, this._docData.data );
          }

          return this;
        }
        _myTrait_.length = function(t) {
          if (!this._docData) return 0;
          if (!this._docData.data) return 0;
          return this._docData.data.length;
        }
        _myTrait_.moveDown = function(t) {
          _up.moveItemDown(this._docData.__id);
        }
        _myTrait_.moveToIndex = function(index) {

          _up.moveItemToPos(this._docData.__id, index);
          // moveItemToPos
        }
        _myTrait_.moveUp = function(t) {
          _up.moveItemUp(this._docData.__id);
        }
        _myTrait_.onValue = function(scope, fn) {
          if (!this._valueFn) {
            this._valueFn = {};
          }
          if (!this._valueFn[scope])
            this._valueFn[scope] = [];

          if (this._valueFn[scope].indexOf(fn) < 0)
            this._valueFn[scope].push(fn);
        }
        _myTrait_.parent = function(p) {

          if (typeof(p) != "undefined") {
            console.error("setting parent is not implemented");
            return this;
          }
          if (!this._docData) {
            return;
          }

          var p = this._docData.__p;
          if (p) return _data(p);



        }
        _myTrait_.pick = function(what) {

          var stream = simpleStream();
          var me = this;

          this.then(
            function() {
              console.log("About to collect ", what);

              me._collectObject(me, what, function(data) {
                console.log("Got " + data);
                stream.pushValue(data);
              });
            });

          return stream;
        }
        _myTrait_.pop = function(t) {

          var len = this.length();
          if (len) {
            var it = this.at(len - 1);
            it.remove();
            return it;
          }
        }
        _myTrait_.push = function(newData) {

          var myPromise = _promise();
          if (newData.then) {
            var myDoc = this._docData;
            newData.then(
              function() {
                newData = newData._docData;
                _up.push(myDoc, newData).then(function() {
                  myPromise.resolve(true);
                });
              });
            return myPromise;
            // newData = newData._docData;
          }
          var me = this;
          this.then(
            function() {
              _up.push(me._docData, newData).then(function() {
                myPromise.resolve(true);
              });
            });

          return myPromise;
          /*
           var str = "{" + createItem + "}";
           var dataObj = JSON.parse( str );
           
           for( n in dataObj ) {
               var dataId = elem.getAttribute("data-id");
               if(dataId) {
                   // Then, how to add a document object
                   var model = me._find(dataId);
                   me.push( model.data[n], dataObj[n], n );
               }
           }
           */
        }
        _myTrait_.pushRemote = function(URL, objID) {

          if (this.isArray()) {
            var newId = this.guid();
            _docUp().execCommand([16, URL, objID, newId, this.getID()]);
          }
          return this;

        }
        _myTrait_.remove = function(t) {

          console.log("Removing cmd for ", this._docData.__id);
          _up.removeItem(this._docData.__id);

          return this;

          /*
           if(this.isObject(i)) {
               var obj = i;
               i = this._data.indexOf(obj);
               if(i<0) return this;
           }
           
           this._removedItem = this._data[i];
           this._data.splice(i,1);
           this.trigger("remove", i);     
           
           lastChange.item  = this._removedItem;
           lastChange.field = i;
           lastChange.value = null;
           lastChange.type ="remove";
           
           this.emitValue("childChange", lastChange);
           
           return this;
           */
        }
        _myTrait_.removeListener = function(eventName, fn) {
          if (this._events && this._events[eventName]) {
            var i = this._events[eventName].indexOf(fn);
            if (i >= 0) this._events[eventName].splice(i, 1);
            if (this._events[eventName].length == 0) {
              delete this._events[eventName];
            }
          }
        }
        _myTrait_.restackOps = function(input) {
          var cmds = [],
            windowSize = 5;

          function result(dist, data, from, to, parent) {
            return {
              dist: dist,
              data: data,
              from: from,
              to: to,
              parent: parent
            };
          }

          function totalDist(data) {
            return data.reduce(function(previousValue, currentValue, index, array) {
              return previousValue + Math.abs(index - currentValue);
            }, 0);
          }

          // Copyright Otto Chrons, otto@chrons.me
          function restack(input) {
            var data = input.slice(0);
            console.log("data:", data);
            var size = data.length;
            var iterations = size;
            var minDist = totalDist(data);
            var prevResults = [result(minDist, input, 0, 0, null)]

            while (minDist > 0 && iterations > 0) {
              var results = [];
              prevResults.forEach(function(pr) {
                minDist = pr.dist;
                var a = pr.data;
                for (var from = 0; from < size; from++) {
                  for (var to = 0; to < size + 1; to++) {
                    var t = a.slice(0);
                    var x = t.splice(from, 1);
                    if (to < from) t.splice(to, 0, x[0]);
                    else t.splice(to - 1, 0, x[0]);
                    var d = totalDist(t);
                    if (results.length < windowSize || d < minDist) {
                      var r = result(d, t, from, to, pr);
                      results.push(r);
                      if (results.length > windowSize) {
                        results.sort(function(r1, r2) {
                          return r1.dist - r2.dist;
                        });
                        results = results.slice(0, results.length - 1);
                      }
                      minDist = results.reduce(function(md, r) {
                        return Math.max(md, r.dist);
                      }, 0);
                    }
                  }
                }
              });
              //console.log("Results", results);
              prevResults = results;
              iterations--;
              minDist = results.reduce(function(md, r) {
                return Math.min(md, r.dist);
              }, 1);
              //console.log("minDist "+minDist);
            }
            if (!results) return;
            // replay operations
            var bestResult = results.filter(function(r) {
              return r.dist == 0;
            })[0]
            var ops = [bestResult];
            while (bestResult.parent != null) {
              ops.push(bestResult.parent);
              bestResult = bestResult.parent;
            }
            ops.reverse();
            // skip first
            ops.slice(1).forEach(function(op) {
              if (op.to == op.parent.data.length) {
                cmds.push(["b", op.parent.data[op.from], op.parent.data[op.to - 1]]);
                // console.log("cmd", "b " + op.parent.data[op.from] + " " + op.parent.data[op.to - 1]);
              } else {
                cmds.push(["a", op.parent.data[op.from], op.parent.data[op.to]]);
                // console.log("cmd", "a " + op.parent.data[op.from] + " " + op.parent.data[op.to]);
              }
            });
            //console.log("data:", data);
            //console.log("iterations: ", ops.length - 1);
            return data; // actually the return value is not used for anything
          }
          restack(input);

          return cmds;

        }
        _myTrait_.restackOps2 = function(input) {
          var moveCnt = 0,
            cmds = [];

          function restack(input) {
            var data = input.slice(0);
            var dataIn = input.slice(0);
            var goalIn = input.slice(0).sort(function(a, b) {
              return a - b;
            });
            //console.log("data:", data);
            //console.log("goal:", goalIn);

            var mapper = {};
            var indexes = {};
            // Testing this kind of simple system...
            for (var i = 0; i < dataIn.length; i++) {
              var mm = goalIn.indexOf(dataIn[i]);
              mapper[dataIn[i]] = mm;
              indexes[mm] = dataIn[i];
              data[i] = mm;
            }

            var goal = data.slice(0).sort(function(a, b) {
              return a - b;
            });

            var minValue = data[0],
              maxValue = data[0],
              partDiffs = [],
              partCum = 0,
              avgDiff = function() {
                var i = 0;
                len = data.length, df = 0;
                for (; i < len; i++) {
                  var v = data[i];
                  if (v > maxValue) maxValue = v;
                  if (v < minValue) minValue = v;
                  if (i > 0) partDiffs.push(goal[i] - goal[i - 1]);
                  if (i > 0) partCum += Math.abs(goal[i] - goal[i - 1]);
                  df += Math.abs(v - goal[i]);
                }
                partCum = partCum / len;
                return df / len;
              }();

            partDiffs.sort(function(a, b) {
              return a - b;
            });
            var minDelta = partDiffs[0];

            // collects one "acceptable" array 
            var accept = function(fn) {
              var collect = function(i, sx, last) {
                var res = [];
                var len = data.length;
                if (!sx) sx = 0;
                for (; i < len; i++) {
                  var v = data[i];
                  if ((v - last) == 1) {
                    res.push(v);
                    last = v;
                    continue;
                  }
                  var gi = i + sx;
                  if (gi < 0) gi = 0;
                  if (gi >= len) gi = len - 1;
                  if (fn(v, goal[gi], v, last, i, len)) {
                    if ((data[i + 1] && data[i + 1] < v && data[i + 1] > last)) {
                      // skip, if next should be taken instead 
                    } else {
                      res.push(v);
                      last = v;
                    }
                  }
                }
                return res;
              }

              var m = [];
              var ii = 0,
                a = 0;
              // small tricks to improve the algo, just for comp's sake...
              while (a < 0.1) {
                for (var sx = -5; sx <= 5; sx++)
                  m.push(collect(Math.floor(data.length * a), sx, minValue - 1));
                a += 0.05;
              }
              m.sort(function(a, b) {
                return b.length - a.length;
              });
              return m[0];
            };

            // different search agents...
            var test = [
              accept(function(dv, gv, v, last, i, len) {
                // console.log(Math.abs(v-last)+" vs "+partCum);
                if (v < last) return false;
                if (i > 0)
                  if (Math.abs(v - last) > partDiffs[i - 1]) return false;
                if (Math.abs(v - last) > avgDiff) return false;
                if (Math.abs(dv - gv) <= avgDiff * (i / len) && v >= last) return true;
                if (Math.abs(last - v) <= avgDiff * (i / len) && v >= last) return true;
                return false;
              }),
              accept(function(dv, gv, v, last, i, len) {
                if (v < last) return false;
                if (Math.abs(v - last) > avgDiff) return false;
                if (Math.abs(dv - gv) <= avgDiff * (i / len) && v >= last) return true;
                if (Math.abs(last - v) <= avgDiff * (i / len) && v >= last) return true;
                return false;
              }),
              accept(function(dv, gv, v, last, i, len) {
                if (v < last) return false;
                if (Math.abs(v - last) > avgDiff) return false;
                if (Math.abs(dv - gv) <= avgDiff * (i / len) && v >= last) return true;
                if (Math.abs(last - v) <= avgDiff * (i / len) && v >= last) return true;
                return false;
              }),
              accept(function(dv, gv, v, last, i, len) {
                if (v < last) return false;
                if (Math.abs(dv - gv) <= avgDiff * (i / len) && v >= last) return true;
                if (Math.abs(last - v) <= avgDiff * (i / len) && v >= last) return true;
                return false;
              }),
              accept(function(dv, gv, v, last, i, len) {
                if (v < last) return false;
                if (Math.abs(dv - gv) <= avgDiff && v >= last) return true;
                if (Math.abs(last - v) <= avgDiff * (i / len) && v >= last) return true;
                return false;
              }),
              accept(function(dv, gv, v, last, i, len) {
                if (v < last) return false;
                if (Math.abs(v - last) < partCum) return true;
                if (Math.abs(dv - gv) <= partCum && v >= last) return true;
                return false;
              }),
              accept(function(dv, gv, v, last, i, len) {
                if (v > last) return true;
                return false;
              }),
              accept(function(dv, gv, v, last, i, len) {
                if (v < last) return false;
                if (Math.abs(v - last) > avgDiff) return false;
                if (Math.abs(dv - gv) <= avgDiff && v >= last) return true;
                return false;
              }),
              accept(function(dv, gv, v, last, i, len) {
                if (v < last) return false;
                if (i > 0)
                  if (Math.abs(v - last) > avgDiff) return false;
                if (Math.abs(dv - gv) <= avgDiff * (i / len) && v >= last) return true;
                if (i > 0)
                  if (Math.abs(last - v) <= avgDiff * (i / len) && v >= last) return true;
                return false;
              }),
              accept(function(dv, gv, v, last, i, len) {
                if (v < last) return false;
                if (last >= minValue) {
                  if (v >= last) return true;
                } else {
                  if (v == minValue) return true;
                }
                return false;
              })
            ];


            // choose between algorithms
            var okVals = [],
              maxSet = 0;
            for (var i = 0; i < test.length; i++) {
              var set = test[i];
              if (set.length > maxSet) {
                okVals = set;
                maxSet = set.length;
              }
            }
            // if nothing, take something
            if (okVals.length == 0) okVals = [goal[Math.floor(goal.length / 2)]];

            // divide the list to big and small
            var big = [],
              small = [];
            var divide = function() {
              var min = minValue,
                max = okVals[0],
                okLen = okVals.length,
                oki = data.indexOf(max),
                index = 0;

              var i = 0;
              len = data.length;
              for (; i < len; i++) {
                var v = data[i];
                if (v >= min && v <= max && (i <= oki)) {
                  big.push(v);
                  min = v;
                } else {
                  small.push(v);
                }
                if (v == max) {
                  min = v;
                  if (index < okLen - 1) {
                    index++;
                    max = okVals[index];
                    oki = data.indexOf(max);
                  } else {
                    max = maxValue;
                    oki = len + 1;
                  }
                }
              }

            }();

            // sort the small list before joining them
            small.sort(function(a, b) {
              return a - b;
            });

            //console.log(big);
            //console.log(small);

            var joinThem = function() {
              var si = 0,
                bi = 0,
                lastb = big[0],
                slen = small.length;
              while (si < slen) {
                var b = big[bi],
                  s = small[si];
                if (typeof(b) == "undefined") {
                  while (si < slen) {
                    cmds.push(["b", indexes[s], indexes[lastb]]);
                    // restackXBelowY(dataIn, indexes[s], indexes[lastb]);
                    lastb = s;
                    si++;
                    s = small[si]
                  }
                  return;
                }
                if (b < s) {
                  // console.log("B was smaller");
                  lastb = b;
                  bi++;
                } else {
                  cmds.push(["a", indexes[s], indexes[b]]);
                  // restackXAboveY(dataIn, indexes[s], indexes[b]);
                  si++;
                }
              }
            }();

            // console.log(dataIn);
            return data; // actually the return value is not used for anything    

          }
          restack(input);

          return cmds;

        }
        _myTrait_.serialize = function(nonRecursive) {
          var o, me = this,
            data = this._docData.data;
          if (this.isArray(this._data)) {
            o = [];
          } else {
            o = {};
          }

          for (var n in data) {
            if (data.hasOwnProperty(n)) {
              var v = data[n];
              if (typeof(v) == "undefined") continue;
              if (nonRecursive) {
                if (this.isObject(v) || this.isArray(v)) continue;
              }
              if (this.isObject(v)) {
                o[n] = _data(v).serialize();
              } else {
                o[n] = v;
              }
            }
          }

          return o;
        }
        _myTrait_.set = function(name, value) {
          /*
           Replace with _up.set()
           */

          if (this.isFulfilled()) {
            return _up.execCommand([4, name, value, null, this._docData.__id]);
          }

          var p = _promise();
          var me = this;

          // TODO: check of the value is object or array...
          if (!_createdFunctions[name] && !this.isObject(value)) {
            this.createPropertyUpdateFn(name, value);
          }

          this.then(function() {
            _up.execCommand([4, name, value, null, me._docData.__id]).then(function() {
              p.resolve(true);
            });
          });

          return p;

        }
        _myTrait_.toData = function(nonRecursive) {

          var str = JSON.stringify(this._docData);
          var data = JSON.parse(str);

          if (data.__ctxCmdList) delete data.__ctxCmdList;
          if (data.__cmdList) delete data.__cmdList;

          return data;
        }
        _myTrait_.unset = function(name) {

          _up.unset(this._docData.__id, name);

          return this;

        }
        _myTrait_.updateData = function(data) {
          var me = this;
          var lastChange = {};
          if (data instanceof Array) {
            //console.log("Updating array with ",data);

            // array update is not trivial task to do.... :/

            // let's try this harder way...

            var bCouldUpdate = true,
              objIndex = {};

            this.forEach(function(i) {
              if (!i.id) {
                bCouldUpdate = false;
              } else {
                objIndex[i.id()] = i;
              }
            });
            data.forEach(function(i) {
              if (!i.id) bCouldUpdate = false;
            });

            if (bCouldUpdate) {
              // console.log("Update is possible for data ", data);
              // NOTE: TODO: there could be a new sort-order... this is not implemented in
              // the update function yet...

              for (var i = 0; i < data.length; i++) {
                var dataObj = data[i];
                var obj = objIndex[dataObj.id];
                if (obj) {
                  obj.updateData(dataObj);
                } else {
                  me.push(dataObj);
                }
              }
            } else {
              console.log("Was not able to update data ", data);
            }

            if (!bCouldUpdate) {
              me.clear();

              for (var n in data) {
                //console.log("Index... ",n);
                var v = data[n];
                //console.log("Object... ",v);
                if (!this.isFunction(v) && (v === Object(v) || (v instanceof Array))) {

                  //console.log("push... and create a new object starts");
                  me.push(v);
                  //console.log("******* Pushed new data, currently I am ", me);
                  /*
                           // The update of array is not this easy...
                           if(me._data[n]) {
                               console.log("Index ",n," with updateData");
                               me._data[n].updateData(v);    
                           } else {
                               console.log("index ",n," creating a new data object " );
                               me._data[n] = new _data(v, me._validators);
                               me._data[n].parent(this);
                               this._members.push(n);
                               console.log(me._data);
                           }
                           */
                } else {
                  //console.log("push...2");
                  // create a new object if necessary...???
                  me.push(v);

                  //console.log("v was not object, currently I am ", me);
                  /*
                           // there is not trigger here if the item changes???
                           if(v != this._data[n]) {
                               this._data[n] = v;
                               this.trigger("replace", n);   
                           }
                           */
                }
              }
            }

          } else {
            //console.log("Updating object");
            for (var n in data) {
              if (data.hasOwnProperty(n)) {
                var v = data[n];

                if (!this.isFunction(v) &&
                  !(v instanceof Array) && v === Object(v) && !(v.constructor === Object)) {
                  // if object but NOT plain object, update date is not used here
                  continue;
                }

                if (!this.isFunction(v) && (v === Object(v) || (v instanceof Array))) {

                  if (this[n]) {
                    if (this[n].updateData)
                      this[n].updateData(v);
                  } else {
                    this[n] = new _data(v);
                    this[n].parent(this);
                    this._members.push(n);
                    this.saveCommand("setMember", n, this[n]._guid, null);
                  }
                } else {
                  // the basic...


                  if (me[n]) {
                    me[n](v);
                  } else {
                    // if no function defined, create it
                    // this._data[n] = v;
                    me.createPropertyUpdateFn(n, v);
                    this[n](v);

                  }
                }
              }
            }

          }
        }
        _myTrait_.validatorFor = function(varName, fn) {
          if (!this._validators) {
            this._validators = {};
          }

          this._validators[varName] = fn
        }
      }(this));;
      (function(_myTrait_) {
        var _callContext;
        _myTrait_._enterCtx = function(fname) {

          if (!_callContext) {
            _callContext = {
              active: {}
            };
          }
          if (!this.__lid) this.__lid = this.guid();

          var id = this.__lid + fname;
          if (!_callContext.active[id]) {
            _callContext.active[id] = 1;
            return true;
          } else {
            // console.error("**** RECURSION PREVENTED **** ", id);
            return false;
          }
        }
        _myTrait_._getCtx = function(t) {
          var o = {},
            a = _callContext.active;
          for (var n in a) {
            if (a.hasOwnProperty(n)) o[n] = a[n];
          }
          return o;
        }
        _myTrait_._leaveCtx = function(fname) {
          var id = this.__lid + fname;
          if (_callContext.active[id]) {
            delete _callContext.active[id];
          }

        }
        _myTrait_._resetCtx = function(t) {
          _callContext.active = {};
        }
        _myTrait_._setCtx = function(ctx) {
          _callContext.active = ctx;
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(t) {

          // create local id
          this.__lid = this.guid();

          if (!_callContext) {
            _callContext = {
              active: {}
            };
          }

        });
      }(this));;
      (function(_myTrait_) {
        var _eventOn;
        var _up;
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(t) {

          if (!_eventOn) _eventOn = [];
          if (!_up) _up = _docUp();
        });
        _myTrait_.on = function(eventName, fn) {
          if (!this._events) this._events = {};
          if (!this._events[eventName]) this._events[eventName] = [];
          this._events[eventName].push(fn);

          // This might remove the old event...
          var me = this;
          fn._unbindEvent = function() {
            // console.log("unbindEvent called");
            me.removeListener(eventName, fn);
          }
          /*
           var worker = _up._createWorker( this._docData.__id,  
                                           eventName, 	
                                           _workers().fetch(14),
                                           null,
                                           {
                                               modelid : this._docData.__id,
                                               eventName : eventName,
                                               eventObj : this
                                           } );
           
           */


        }
        _myTrait_.removeListener = function(eventName, fn) {
          if (this._events && this._events[eventName]) {
            var i = this._events[eventName].indexOf(fn);
            if (i >= 0) this._events[eventName].splice(i, 1);
            if (this._events[eventName].length == 0) {
              delete this._events[eventName];
            }
          }
        }
        _myTrait_.trigger = function(eventName, data) {
          if (_eventOn.indexOf(eventName + this._guid) >= 0) {
            return;
          }

          if (this._events && this._events[eventName]) {
            var el = this._events[eventName],
              me = this;
            _eventOn.push(eventName + this._guid);
            var len = el.length;
            for (var i = 0; i < len; i++) {
              el[i](me, data);
            }

            var mi = _eventOn.indexOf(eventName + this._guid);
            _eventOn.splice(mi, 1);
            // console.log("The event array", _eventOn);
          }
        }
      }(this));;
      (function(_myTrait_) {
        var _commands;
        var _objectCache;
        var _cmdIndex;
        var _lastCmdId;
        var _lastCmdVals;
        var _objSetValCmds;
        var _commandListener;
        var _isRemoteUpdate;
        var _hotObjects;
        var _hotSettings;
        var _hotDocs;
        var _incomingDataFn;
        _myTrait_._askSnapshot = function(bUseRawData) {

          var root = this.findRootDocup();
          root._askSnapshot(true);


        }
        _myTrait_._broadcastToCmdChannels = function(cmdList) {

          if (this._cmdChannels) {
            console.log("Channels", this._cmdChannels);
            this._cmdChannels.forEach(function(ch) {
              ch.broadcast(cmdList);
            });
          } else {
            //console.log("**** NO CHANNELS *****");
            //console.log(this);
          }
        }
        _myTrait_._clearCmdCache = function(t) {
          _objectCache = {};
          _commands = [];

        }
        _myTrait_._removeFromCache = function(obj) {

          console.error("_removeFromCache not implemented ");
          return;

          if (!obj) {
            var me = this;
            this._forMembers(function(m) {
              if (m) m._removeFromCache();
            });
            this._removeFromCache(this);
          } else {

            if (this.isObject(obj)) {
              var g = obj._guid;
              if (g) {
                console.log("*** removing " + g);
                delete _objectCache[g];
              }
            } else {
              if (obj) {
                console.log("*** removing " + obj);
                delete _objectCache[obj];
              }
            }
          }
        }
        _myTrait_._sendToInListeners = function(data) {

          console.error("_sendToInListeners not implemented");
        }
        _myTrait_.addToCache = function(id, obj) {

          if (!_objectCache) _objectCache = {};

          if (id) {
            _objectCache[id] = obj;
          }
        }
        _myTrait_.execCommands = function(cmdList) {
          console.error("execCommands not implemented");
        }
        _myTrait_.findFromCache = function(guid) {

          if (!_objectCache) return;

          return _objectCache[guid];
        }
        _myTrait_.getObjectCache = function(t) {
          return _objectCache;
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(t) {

        });
        _myTrait_.isRecordingCommands = function(t) {
          console.error("isRecordingCommands not implemented");
        }
        _myTrait_.saveCommand = function(action, property, value, oldValue) {

          console.error("saveCommand not implemented");
          return;

        }
        _myTrait_.setCommandRecOnOff = function(b) {
          console.error("setCommandRecOnOff not implemented");
          return;
        }
      }(this));;
      (function(_myTrait_) {
        var _up;
        var _factoryProperties;
        var _registry;
        _myTrait_._addFactoryProperty = function(name) {
          if (!_factoryProperties) _factoryProperties = [];
          _factoryProperties.push(name);
        }
        if (!_myTrait_.hasOwnProperty('__factoryClass')) _myTrait_.__factoryClass = []
        _myTrait_.__factoryClass.push(function(data) {

          if (this.isObject(data)) {
            if (data.data && data.__id) {
              var oo = this.findFromCache(data.__id);
              if (oo) {
                // console.log("did find object "+data.__id+" from cache");
                return oo;
              }
            }
          } else {
            // console.log("_data classfactory ", data);
            var oo = this.findFromCache(data);
            if (oo) {
              // console.log("_data classfactory did find ", data);
              // console.log("did find object "+data+" from cache (using id)");
              return oo;
            } else {
              //console.log("_data classfactory did NOT find ", data);
            }
          }

          if (_factoryProperties && _registry) {
            for (var i = 0; i < _factoryProperties.length; i++) {
              var pn = _factoryProperties[i];
              var name;

              if (data && data.data) {

                name = data.data[pn];
              } else {
                if (data) name = data[pn];
              }

              if (name) {
                cf = _registry[name];
                if (cf) {
                  return cf;
                }
              }
            }
          }


          if (data && data.__m) {
            var name = data.__m,
              cf = _registry[name];
            return cf;
          }
        });
        _myTrait_.callMe = function(t) {
          alert(t);
        }
        _myTrait_.createSubClass = function(propertyName, className, classConstructor) {


          // resStr+=cName+"_prototype.prototype = "+compileInfo.inheritFrom+".prototype\n";

          var myDataClass_prototype = classConstructor;

          var myDataClass = function(a, b, c, d, e, f, g, h) {
            if (this instanceof myDataClass) {
              console.log("is instance of...");
              console.log(this.__traitInit);
              var args = [a, b, c, d, e, f, g, h];
              if (this.__factoryClass) {
                var m = this;
                var res;
                this.__factoryClass.forEach(function(initF) {
                  res = initF.apply(m, args);
                });
                if (Object.prototype.toString.call(res) == '[object Function]') {
                  if (res._classInfo.name != myDataClass._classInfo.name) return new res(a, b, c, d, e, f, g, h);
                } else {
                  if (res) return res;
                }
              }
              if (this.__traitInit) {
                console.log("Calling the subclass trait init...");
                var m = this;
                this.__traitInit.forEach(function(initF) {
                  initF.apply(m, args);
                })
              } else {
                if (typeof this.init == 'function')
                  this.init.apply(this, args);
              }
            } else {
              console.log("NOT instance of...");
              return new myDataClass(a, b, c, d, e, f, g, h);
            }
          }
          myDataClass._classInfo = {
            name: this.guid()
          };

          myDataClass_prototype.prototype = _data.prototype;
          myDataClass.prototype = new myDataClass_prototype();

          this.registerComponent(className, myDataClass);
          this._addFactoryProperty(propertyName);


          return myDataClass;


        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(data, options) {

          // getting the data from the docup...
          //console.log("_data init ", data);
          //console.trace();

          if (!_up) {
            _up = _docUp({});
          }
          var myData,
            myDoc,
            me = this;

          if (!data) {
            me.resolve(true);
            return;
          }



          if (data && data.__id) {
            if (_up._find(data.__id)) {

              // console.log("**** data found, initializing **** ");
              //console.log(JSON.parse(JSON.stringify( data) ));        
              me._initializeData(data);
              me.addToCache(data.__id, me);
              me.resolve(true);
              return;
            }
          }

          // console.log("**** did not find the "+data.__id+" **** ");

          if (data && data.__rid) {
            var remData = _up._find(data.__rid);
            if (remData) {

              //console.log("**** remData was data found, not yet, initializing **** ");
              //console.log(JSON.parse(JSON.stringify( remData ) ));        
              //me._initializeData(data);
              //me.addToCache( data.__id, me );    
              //me.resolve(true);       
              //return;
            }
          }

          // muutoin data ei ole ladattuna...
          console.log("_doc up for data");
          myDoc = _docUp(data, options);

          myDoc.then(function() {

            myData = myDoc.getData();

            console.log("**** just returned creating data for **** ");
            // console.log(myData);

            // it could be a remote data too
            me._initializeData(myData);
            me.addToCache(myData.__id, me);
            me.resolve(true);
          });



          /*
me.resolve(true); 
*/


        });
        _myTrait_.registerComponent = function(name, classDef) {

          if (!_registry) _registry = {};

          if (!_registry[name]) {
            _registry[name] = classDef;
          }
        }
      }(this));
    }
    _data_prototype.prototype = _promise.prototype
    var _data = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _data) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _data._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _data(a, b, c, d, e, f, g, h);
    };
    _data._classInfo = {
      name: '_data'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_data", _data)
    _data.prototype = new _data_prototype();
    if (typeof(window) != 'undefined') window['_data'] = _data;
    if (typeof(window) != 'undefined') window['_data_prototype'] = _data_prototype;;
    (function(_myTrait_) {
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(main) {

      });
    }(this));
  }
  var templatePackage = function(a, b, c, d, e, f, g, h) {
    if (this instanceof templatePackage) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != templatePackage._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new templatePackage(a, b, c, d, e, f, g, h);
  };
  templatePackage._classInfo = {
    name: 'templatePackage'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("templatePackage", templatePackage)
  templatePackage.prototype = new templatePackage_prototype();
  if (typeof(window) != 'undefined') window['templatePackage'] = templatePackage;
  if (typeof(window) != 'undefined') window['templatePackage_prototype'] = templatePackage_prototype;
  var _promise_prototype = function() {
    'use strict';
    var later_prototype = function() {;
      (function(_myTrait_) {
        var _initDone;
        var _callers;
        var _oneTimers;
        var _everies;
        var _framers;
        _myTrait_.add = function(fn, thisObj, args) {
          if (thisObj || args) {
            var tArgs;
            if (Object.prototype.toString.call(args) === '[object Array]') {
              tArgs = args;
            } else {
              tArgs = Array.prototype.slice.call(arguments, 2);
              if (!tArgs) tArgs = [];
            }
            _callers.push([thisObj, fn, tArgs]);
          } else {
            _callers.push(fn);
          }
        }
        _myTrait_.after = function(seconds, fn, name) {

          if (!name) {
            name = "time" + (new Date()).getTime() + Math.random(10000000);
          }

          _everies[name] = {
            step: Math.floor(seconds * 1000),
            fn: fn,
            nextTime: 0,
            remove: true
          };
        }
        _myTrait_.asap = function(fn) {
          this.add(fn);

        }
        _myTrait_.every = function(seconds, fn, name) {

          if (!name) {
            name = "time" + (new Date()).getTime() + Math.random(10000000);
          }

          _everies[name] = {
            step: Math.floor(seconds * 1000),
            fn: fn,
            nextTime: 0
          };
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(interval, fn) {
          if (!_initDone) {

            this.polyfill();

            var frame, cancelFrame;
            if (typeof(window) != "undefined") {
              var frame = window['requestAnimationFrame'],
                cancelFrame = window['cancelRequestAnimationFrame'];
              ['', 'ms', 'moz', 'webkit', 'o'].forEach(function(x) {
                if (!frame) {
                  frame = window[x + 'RequestAnimationFrame'];
                  cancelFrame = window[x + 'CancelAnimationFrame'] || window[x + 'CancelRequestAnimationFrame'];
                }
              });
            }

            if (!frame)
              frame = function(cb) {
                return setTimeout(cb, 16);
              };

            if (!cancelFrame)
              cancelFrame = function(id) {
                clearTimeout(id);
              };

            _callers = [];
            _oneTimers = {};
            _everies = {};
            _framers = [];
            var lastMs = 0;

            var _callQueQue = function() {
              var ms = (new Date()).getTime();
              var fn;
              while (fn = _callers.shift()) {
                if (Object.prototype.toString.call(fn) === '[object Array]') {
                  fn[1].apply(fn[0], fn[2]);
                } else {
                  fn();
                }

              }

              for (var i = 0; i < _framers.length; i++) {
                var fFn = _framers[i];
                fFn();
              }

              for (var n in _oneTimers) {
                if (_oneTimers.hasOwnProperty(n)) {
                  var v = _oneTimers[n];
                  v[0](v[1]);
                  delete _oneTimers[n];
                }
              }

              for (var n in _everies) {
                if (_everies.hasOwnProperty(n)) {
                  var v = _everies[n];
                  if (v.nextTime < ms) {
                    if (v.remove) {
                      if (v.nextTime > 0) {
                        v.fn();
                        delete _everies[n];
                      } else {
                        v.nextTime = ms + v.step;
                      }
                    } else {
                      v.fn();
                      v.nextTime = ms + v.step;
                    }
                  }
                  if (v.until) {
                    if (v.until < ms) {
                      delete _everies[n];
                    }
                  }
                }
              }

              frame(_callQueQue);
              lastMs = ms;
            };
            _callQueQue();
            _initDone = true;
          }
        });
        _myTrait_.once = function(key, fn, value) {
          // _oneTimers

          _oneTimers[key] = [fn, value];
        }
        _myTrait_.onFrame = function(fn) {

          _framers.push(fn);
        }
        _myTrait_.polyfill = function(t) {
          // --- let's not ---
        }
        _myTrait_.removeFrameFn = function(fn) {

          var i = _framers.indexOf(fn);
          if (i >= 0) {
            if (fn._onRemove) {
              fn._onRemove();
            }
            _framers.splice(i, 1);
            return true;
          } else {
            return false;
          }
        }
      }(this));
    }
    var later = function(a, b, c, d, e, f, g, h) {
      if (this instanceof later) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != later._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new later(a, b, c, d, e, f, g, h);
    };
    later._classInfo = {
      name: 'later'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("later", later)
    later.prototype = new later_prototype();
    if (typeof(window) != 'undefined') window['later'] = later;
    if (typeof(window) != 'undefined') window['later_prototype'] = later_prototype;;
    (function(_myTrait_) {
      _myTrait_.isArray = function(someVar) {
        return Object.prototype.toString.call(someVar) === '[object Array]';
      }
      _myTrait_.isFunction = function(fn) {
        return Object.prototype.toString.call(fn) == '[object Function]';
      }
      _myTrait_.isObject = function(obj) {
        return obj === Object(obj);
      }
    }(this));;
    (function(_myTrait_) {
      _myTrait_.all = function(firstArg) {

        var args;
        if (this.isArray(firstArg)) {
          args = firstArg;
        } else {
          args = Array.prototype.slice.call(arguments, 0);
        }
        // console.log(args);
        var targetLen = args.length,
          rCnt = 0,
          myPromises = [],
          myResults = new Array(targetLen);

        return this.then(
          function() {

            var allPromise = _promise();
            if (args.length == 0) {
              allPromise.resolve([]);
            }
            args.forEach(function(b, index) {
              if (b.then) {
                // console.log("All, looking for ", b, " state = ", b._state);
                myPromises.push(b);

                b.then(function(v) {
                  myResults[index] = v;
                  // console.log("Got a promise...",b, " cnt = ", rCnt);
                  rCnt++;
                  if (rCnt == targetLen) {
                    allPromise.resolve(myResults);
                  }
                }, function(v) {
                  allPromise.reject(v);
                });

              } else {
                allPromise.reject("Not list of promises");
              }
            })

            return allPromise;

          });





      }
      _myTrait_.collect = function(collectFn, promiseList, results) {

        var args;
        if (this.isArray(promiseList)) {
          args = promiseList;
        } else {
          args = [promiseList];
        }

        // console.log(args);
        var targetLen = args.length,
          isReady = false,
          noMore = false,
          rCnt = 0,
          myPromises = [],
          myResults = results || {};

        return this.then(
          function() {

            var allPromise = _promise();
            args.forEach(function(b, index) {
              if (b.then) {
                // console.log("All, looking for ", b, " state = ", b._state);
                myPromises.push(b);

                b.then(function(v) {
                  rCnt++;
                  isReady = collectFn(v, myResults);
                  if ((isReady && !noMore) || (noMore == false && targetLen == rCnt)) {
                    allPromise.resolve(myResults);
                    noMore = true;
                  }
                }, function(v) {
                  allPromise.reject(v);
                });

              } else {
                allPromise.reject("Not list of promises");
              }
            })

            return allPromise;

          });

      }
      _myTrait_.fail = function(fn) {
        return this.then(null, fn);
      }
      _myTrait_.fulfill = function(withValue) {
        // if(this._fulfilled || this._rejected) return;

        if (this._rejected) return;
        if (this._fulfilled && withValue != this._stateValue) {
          return;
        }

        var me = this;
        this._fulfilled = true;
        this._stateValue = withValue;

        var chCnt = this._childPromises.length;

        while (chCnt--) {
          var p = this._childPromises.shift();
          if (p._onFulfill) {
            try {
              var x = p._onFulfill(withValue);
              // console.log("Returned ",x);
              if (typeof(x) != "undefined") {
                p.resolve(x);
              } else {
                p.fulfill(withValue);
              }
            } catch (e) {
              // console.error(e);
              /*
                           If either onFulfilled or onRejected throws an exception e, promise2 
                           must be rejected with e as the reason.            
                       */
              p.reject(e);
            }
          } else {
            /*
                       If onFulfilled is not a function and promise1 is fulfilled, promise2 must be 
                       fulfilled with the same value as promise1        
                   */
            p.fulfill(withValue);
          }
        };
        // this._childPromises.length = 0;
        this._state = 1;
        this.triggerStateChange();

      }
      _myTrait_.genPlugin = function(fname, fn) {
        var me = this;
        this.plugin(fname,
          function() {
            var args = Array.prototype.slice.call(arguments, 0);
            console.log("Plugin args", args);
            var myPromise = _promise();
            this.then(function(v) {
              var args2 = Array.prototype.slice.call(arguments, 0);
              var z = args.concat(args2);
              var res = fn.apply(this, z);
              myPromise.resolve(res);
            }, function(r) {
              myPromise.reject(r);
            });
            return myPromise;

          }
        );
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(onFulfilled, onRejected) {
        // 0 = pending
        // 1 = fullfilled
        // 2 = error

        this._state = 0;
        this._stateValue = null;
        this._isAPromise = true;
        this._childPromises = [];

        if (this.isFunction(onFulfilled))
          this._onFulfill = onFulfilled;
        if (this.isFunction(onRejected))
          this._onReject = onRejected;

        if (!onRejected && this.isFunction(onFulfilled)) {



          var me = this;
          later().asap(
            function() {
              console.log("--- calling the onFulfilled ");
              onFulfilled(function(v) {
                me.resolve(v)
              }, function(v) {
                me.resolve(v);
              });
            });

        }
      });
      _myTrait_.isFulfilled = function(t) {
        return this._state == 1;
      }
      _myTrait_.isPending = function(t) {
        return this._state == 0;
      }
      _myTrait_.isRejected = function(v) {
        return this._state == 2;
      }
      _myTrait_.nodeStyle = function(fname, fn) {
        var me = this;
        this.plugin(fname,
          function() {
            var args = Array.prototype.slice.call(arguments, 0);
            var last, userCb, cbIndex = 0;
            if (args.length >= 0) {
              last = args[args.length - 1];
              if (Object.prototype.toString.call(last) == '[object Function]') {
                userCb = last;
                cbIndex = args.length - 1;
              }
            }

            var mainPromise = wishes().pending();
            this.then(function() {
              var nodePromise = wishes().pending();
              var args2 = Array.prototype.slice.call(arguments, 0);
              console.log("Orig args", args);
              console.log("Then args", args2);
              var z;
              if (args.length == 0)
                z = args2;
              if (args2.length == 0)
                z = args;
              if (!z) z = args2.concat(args);
              cbIndex = z.length; // 0,fn... 2
              if (userCb) cbIndex--;
              z[cbIndex] = function(err) {
                if (err) {
                  console.log("Got error ", err);
                  nodePromise.reject(err);
                  mainPromise.reject(err);
                  return;
                }
                if (userCb) {
                  var args = Array.prototype.slice.call(arguments);
                  var res = userCb.apply(this, args);
                  mainPromise.resolve(res);
                } else {
                  var args = Array.prototype.slice.call(arguments, 1);
                  mainPromise.resolve.apply(mainPromise, args);
                }
              }
              nodePromise.then(function(v) {
                mainPromise.resolve(v);
              });

              console.log("nodeStyle after concat", z);
              var res = fn.apply(this, z);
              // myPromise.resolve(res);
              // return nodePromise;
              return nodePromise;
            }, function(v) {
              mainPromise.reject(v);
            });
            return mainPromise;
            /*
                      log("..... now waiting "+ms);
                      var p = waitFor(ms);
                      p.then( function(v) {
                          myPromise.resolve(v);
                      });
                  */
          }
        );
      }
      _myTrait_.onStateChange = function(fn) {

        if (!this._listeners)
          this._listeners = [];

        this._listeners.push(fn);
      }
      _myTrait_.plugin = function(n, fn) {

        _myTrait_[n] = fn;

        return this;
      }
      _myTrait_.props = function(obj) {
        var args = [];

        for (var n in obj) {
          if (obj.hasOwnProperty(n)) {
            args.push({
              name: n,
              promise: obj[n]
            });
          }
        }


        // console.log(args);
        var targetLen = args.length,
          rCnt = 0,
          myPromises = [],
          myResults = {};

        return this.then(
          function() {

            var allPromise = wishes().pending();
            args.forEach(function(def) {
              var b = def.promise,
                name = def.name;
              if (b.then) {
                // console.log("All, looking for ", b, " state = ", b._state);
                myPromises.push(b);

                b.then(function(v) {
                  myResults[name] = v;
                  rCnt++;
                  if (rCnt == targetLen) {
                    allPromise.resolve(myResults);
                  }
                }, function(v) {
                  allPromise.reject(v);
                });

              } else {
                allPromise.reject("Not list of promises");
              }
            })

            return allPromise;

          });

      }
      _myTrait_.reject = function(withReason) {

        // if(this._rejected || this._fulfilled) return;

        // conso

        if (this._fulfilled) return;
        if (this._rejected && withReason != this._rejectReason) return;


        this._state = 2;
        this._rejected = true;
        this._rejectReason = withReason;
        var me = this;

        var chCnt = this._childPromises.length;
        while (chCnt--) {
          var p = this._childPromises.shift();

          if (p._onReject) {
            try {
              p._onReject(withReason);
              p.reject(withReason);
            } catch (e) {
              /*
                           If either onFulfilled or onRejected throws an exception e, promise2 
                           must be rejected with e as the reason.            
                       */
              p.reject(e);
            }
          } else {
            /*
                       If onFulfilled is not a function and promise1 is fulfilled, promise2 must be 
                       fulfilled with the same value as promise1        
                   */
            p.reject(withReason);
          }
        };

        // this._childPromises.length = 0;
        this.triggerStateChange();

      }
      _myTrait_.rejectReason = function(reason) {
        if (reason) {
          this._rejectReason = reason;
          return;
        }
        return this._rejectReason;
      }
      _myTrait_.resolve = function(x) {

        // console.log("Resolving ", x);

        // can not do this many times...
        if (this._state > 0) return;

        if (x == this) {
          // error
          this._rejectReason = "TypeError";
          this.reject(this._rejectReason);
          return;
        }

        if (this.isObject(x) && x._isAPromise) {

          // 
          this._state = x._state;
          this._stateValue = x._stateValue;
          this._rejectReason = x._rejectReason;
          // ... 
          if (this._state === 0) {
            var me = this;
            x.onStateChange(function() {
              if (x._state == 1) {
                // console.log("State change");
                me.resolve(x.value());
              }
              if (x._state == 2) {
                me.reject(x.rejectReason());
              }
            });
          }
          if (this._state == 1) {
            // console.log("Resolved to be Promise was fulfilled ", x._stateValue);
            this.fulfill(this._stateValue);
          }
          if (this._state == 2) {
            // console.log("Relved to be Promise was rejected ", x._rejectReason);
            this.reject(this._rejectReason);
          }
          return;
        }
        if (this.isObject(x) && x.then && this.isFunction(x.then)) {
          // console.log("Thenable ", x);
          var didCall = false;
          try {
            // Call the x.then
            var me = this;
            x.then.call(x,
              function(y) {
                if (didCall) return;
                // we have now value for the promise...
                // console.log("Got value from Thenable ", y);
                me.resolve(y);
                didCall = true;
              },
              function(r) {
                if (didCall) return;
                // console.log("Got reject from Thenable ", r);
                me.reject(r);
                didCall = true;
              });
          } catch (e) {
            if (!didCall) this.reject(e);
          }
          return;
        }
        this._state = 1;
        this._stateValue = x;

        // fulfill the promise...
        this.fulfill(x);

      }
      _myTrait_.state = function(newState) {
        if (typeof(newState) != "undefined") {
          this._state = newState;
        }
        return this._state;
      }
      _myTrait_.then = function(onFulfilled, onRejected) {

        if (!onRejected) onRejected = function() {};

        var p = new _promise(onFulfilled, onRejected);
        var me = this;

        if (this._state == 1) {
          later().asap(function() {
            me.fulfill(me.value());
          });
        }
        if (this._state == 2) {
          ater().asap(function() {
            me.reject(me.rejectReason());
          });
        }
        this._childPromises.push(p);
        return p;



      }
      _myTrait_.triggerStateChange = function(t) {
        var me = this;
        if (!this._listeners) return;
        this._listeners.forEach(function(fn) {
          fn(me);
        });
        // one-timer
        this._listeners.length = 0;
      }
      _myTrait_.value = function(v) {
        if (typeof(v) != "undefined") {
          this._stateValue = v;
          return this;
        }
        return this._stateValue;
      }
    }(this));
  }
  var _promise = function(a, b, c, d, e, f, g, h) {
    if (this instanceof _promise) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != _promise._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new _promise(a, b, c, d, e, f, g, h);
  };
  _promise._classInfo = {
    name: '_promise'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_promise", _promise)
  _promise.prototype = new _promise_prototype();
  if (typeof(window) != 'undefined') window['_promise'] = _promise;
  if (typeof(window) != 'undefined') window['_promise_prototype'] = _promise_prototype;
  var docRadio_prototype = function() {
    var _promise_prototype = function() {
      'use strict';
      var later_prototype = function() {;
        (function(_myTrait_) {
          var _initDone;
          var _callers;
          var _oneTimers;
          var _everies;
          var _framers;
          _myTrait_.add = function(fn, thisObj, args) {
            if (thisObj || args) {
              var tArgs;
              if (Object.prototype.toString.call(args) === '[object Array]') {
                tArgs = args;
              } else {
                tArgs = Array.prototype.slice.call(arguments, 2);
                if (!tArgs) tArgs = [];
              }
              _callers.push([thisObj, fn, tArgs]);
            } else {
              _callers.push(fn);
            }
          }
          _myTrait_.after = function(seconds, fn, name) {

            if (!name) {
              name = "time" + (new Date()).getTime() + Math.random(10000000);
            }

            _everies[name] = {
              step: Math.floor(seconds * 1000),
              fn: fn,
              nextTime: 0,
              remove: true
            };
          }
          _myTrait_.asap = function(fn) {
            this.add(fn);

          }
          _myTrait_.every = function(seconds, fn, name) {

            if (!name) {
              name = "time" + (new Date()).getTime() + Math.random(10000000);
            }

            _everies[name] = {
              step: Math.floor(seconds * 1000),
              fn: fn,
              nextTime: 0
            };
          }
          if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
            _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
          if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
          _myTrait_.__traitInit.push(function(interval, fn) {
            if (!_initDone) {

              this.polyfill();

              var frame, cancelFrame;
              if (typeof(window) != "undefined") {
                var frame = window['requestAnimationFrame'],
                  cancelFrame = window['cancelRequestAnimationFrame'];
                ['', 'ms', 'moz', 'webkit', 'o'].forEach(function(x) {
                  if (!frame) {
                    frame = window[x + 'RequestAnimationFrame'];
                    cancelFrame = window[x + 'CancelAnimationFrame'] || window[x + 'CancelRequestAnimationFrame'];
                  }
                });
              }

              if (!frame)
                frame = function(cb) {
                  return setTimeout(cb, 16);
                };

              if (!cancelFrame)
                cancelFrame = function(id) {
                  clearTimeout(id);
                };

              _callers = [];
              _oneTimers = {};
              _everies = {};
              _framers = [];
              var lastMs = 0;

              var _callQueQue = function() {
                var ms = (new Date()).getTime();
                var fn;
                while (fn = _callers.shift()) {
                  if (Object.prototype.toString.call(fn) === '[object Array]') {
                    fn[1].apply(fn[0], fn[2]);
                  } else {
                    fn();
                  }

                }

                for (var i = 0; i < _framers.length; i++) {
                  var fFn = _framers[i];
                  fFn();
                }

                for (var n in _oneTimers) {
                  if (_oneTimers.hasOwnProperty(n)) {
                    var v = _oneTimers[n];
                    v[0](v[1]);
                    delete _oneTimers[n];
                  }
                }

                for (var n in _everies) {
                  if (_everies.hasOwnProperty(n)) {
                    var v = _everies[n];
                    if (v.nextTime < ms) {
                      if (v.remove) {
                        if (v.nextTime > 0) {
                          v.fn();
                          delete _everies[n];
                        } else {
                          v.nextTime = ms + v.step;
                        }
                      } else {
                        v.fn();
                        v.nextTime = ms + v.step;
                      }
                    }
                    if (v.until) {
                      if (v.until < ms) {
                        delete _everies[n];
                      }
                    }
                  }
                }

                frame(_callQueQue);
                lastMs = ms;
              };
              _callQueQue();
              _initDone = true;
            }
          });
          _myTrait_.once = function(key, fn, value) {
            // _oneTimers

            _oneTimers[key] = [fn, value];
          }
          _myTrait_.onFrame = function(fn) {

            _framers.push(fn);
          }
          _myTrait_.polyfill = function(t) {
            // --- let's not ---
          }
          _myTrait_.removeFrameFn = function(fn) {

            var i = _framers.indexOf(fn);
            if (i >= 0) {
              if (fn._onRemove) {
                fn._onRemove();
              }
              _framers.splice(i, 1);
              return true;
            } else {
              return false;
            }
          }
        }(this));
      }
      var later = function(a, b, c, d, e, f, g, h) {
        if (this instanceof later) {
          var args = [a, b, c, d, e, f, g, h];
          if (this.__factoryClass) {
            var m = this;
            var res;
            this.__factoryClass.forEach(function(initF) {
              res = initF.apply(m, args);
            });
            if (Object.prototype.toString.call(res) == '[object Function]') {
              if (res._classInfo.name != later._classInfo.name) return new res(a, b, c, d, e, f, g, h);
            } else {
              if (res) return res;
            }
          }
          if (this.__traitInit) {
            var m = this;
            this.__traitInit.forEach(function(initF) {
              initF.apply(m, args);
            })
          } else {
            if (typeof this.init == 'function')
              this.init.apply(this, args);
          }
        } else return new later(a, b, c, d, e, f, g, h);
      };
      later._classInfo = {
        name: 'later'
      };
      if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("later", later)
      later.prototype = new later_prototype();
      if (typeof(window) != 'undefined') window['later'] = later;
      if (typeof(window) != 'undefined') window['later_prototype'] = later_prototype;;
      (function(_myTrait_) {
        _myTrait_.isArray = function(someVar) {
          return Object.prototype.toString.call(someVar) === '[object Array]';
        }
        _myTrait_.isFunction = function(fn) {
          return Object.prototype.toString.call(fn) == '[object Function]';
        }
        _myTrait_.isObject = function(obj) {
          return obj === Object(obj);
        }
      }(this));;
      (function(_myTrait_) {
        _myTrait_.all = function(firstArg) {

          var args;
          if (this.isArray(firstArg)) {
            args = firstArg;
          } else {
            args = Array.prototype.slice.call(arguments, 0);
          }
          // console.log(args);
          var targetLen = args.length,
            rCnt = 0,
            myPromises = [],
            myResults = new Array(targetLen);

          return this.then(
            function() {

              var allPromise = _promise();
              args.forEach(function(b, index) {
                if (b.then) {
                  // console.log("All, looking for ", b, " state = ", b._state);
                  myPromises.push(b);

                  b.then(function(v) {
                    myResults[index] = v;
                    // console.log("Got a promise...",b, " cnt = ", rCnt);
                    rCnt++;
                    if (rCnt == targetLen) {
                      allPromise.resolve(myResults);
                    }
                  }, function(v) {
                    allPromise.reject(v);
                  });

                } else {
                  allPromise.reject("Not list of promises");
                }
              })

              return allPromise;

            });





        }
        _myTrait_.collect = function(collectFn, promiseList, results) {

          var args;
          if (this.isArray(promiseList)) {
            args = promiseList;
          } else {
            args = [promiseList];
          }

          // console.log(args);
          var targetLen = args.length,
            isReady = false,
            noMore = false,
            rCnt = 0,
            myPromises = [],
            myResults = results || {};

          return this.then(
            function() {

              var allPromise = _promise();
              args.forEach(function(b, index) {
                if (b.then) {
                  // console.log("All, looking for ", b, " state = ", b._state);
                  myPromises.push(b);

                  b.then(function(v) {
                    rCnt++;
                    isReady = collectFn(v, myResults);
                    if ((isReady && !noMore) || (noMore == false && targetLen == rCnt)) {
                      allPromise.resolve(myResults);
                      noMore = true;
                    }
                  }, function(v) {
                    allPromise.reject(v);
                  });

                } else {
                  allPromise.reject("Not list of promises");
                }
              })

              return allPromise;

            });

        }
        _myTrait_.fail = function(fn) {
          return this.then(null, fn);
        }
        _myTrait_.fulfill = function(withValue) {
          // if(this._fulfilled || this._rejected) return;

          if (this._rejected) return;
          if (this._fulfilled && withValue != this._stateValue) return;

          // console.log("Fulfilling", this, " with value ", withValue);
          var me = this;
          this._fulfilled = true;
          this._stateValue = withValue;
          // console.log("Child promises ", this._childPromises);

          this._childPromises.forEach(function(p) {
            if (p._onFulfill) {
              try {
                // console.log("Calling child with ", withValue,p._onFulfill.toString());

                var x = p._onFulfill(withValue);
                // console.log("Returned ",x);
                if (typeof(x) != "undefined") {
                  p.resolve(x);
                } else {
                  p.fulfill(withValue);
                }
              } catch (e) {
                // console.error(e);
                /*
                           If either onFulfilled or onRejected throws an exception e, promise2 
                           must be rejected with e as the reason.            
                       */
                p.reject(e);
              }
            } else {
              /*
                       If onFulfilled is not a function and promise1 is fulfilled, promise2 must be 
                       fulfilled with the same value as promise1        
                   */
              p.fulfill(withValue);
            }
          });
          this._childPromises = [];
          this._state = 1;
          this.triggerStateChange();

        }
        _myTrait_.genPlugin = function(fname, fn) {
          var me = this;
          this.plugin(fname,
            function() {
              var args = Array.prototype.slice.call(arguments, 0);
              console.log("Plugin args", args);
              var myPromise = _promise();
              this.then(function(v) {
                var args2 = Array.prototype.slice.call(arguments, 0);
                var z = args.concat(args2);
                var res = fn.apply(this, z);
                myPromise.resolve(res);
              }, function(r) {
                myPromise.reject(r);
              });
              return myPromise;
              /*
                      log("..... now waiting "+ms);
                      var p = waitFor(ms);
                      p.then( function(v) {
                          myPromise.resolve(v);
                      });
                  */
            }
          );
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(onFulfilled, onRejected) {
          // 0 = pending
          // 1 = fullfilled
          // 2 = error
          this._state = 0;
          this._stateValue = null;
          this._isAPromise = true;
          this._childPromises = [];

          if (this.isFunction(onFulfilled))
            this._onFulfill = onFulfilled;
          if (this.isFunction(onRejected))
            this._onReject = onRejected;
        });
        _myTrait_.isFulfilled = function(t) {
          return this._state == 1;
        }
        _myTrait_.isPending = function(t) {
          return this._state == 0;
        }
        _myTrait_.isRejected = function(v) {
          return this._state == 2;
        }
        _myTrait_.nodeStyle = function(fname, fn) {
          var me = this;
          this.plugin(fname,
            function() {
              var args = Array.prototype.slice.call(arguments, 0);
              var last, userCb, cbIndex = 0;
              if (args.length >= 0) {
                last = args[args.length - 1];
                if (Object.prototype.toString.call(last) == '[object Function]') {
                  userCb = last;
                  cbIndex = args.length - 1;
                }
              }
              console.log("nodeStyle", args);
              var mainPromise = _promise();
              this.then(function() {
                var nodePromise = _promise();
                var args2 = Array.prototype.slice.call(arguments, 0);
                console.log("Orig args", args);
                console.log("Then args", args2);
                var z;
                if (args.length == 0)
                  z = args2;
                if (args2.length == 0)
                  z = args;
                if (!z) z = args2.concat(args);
                cbIndex = z.length; // 0,fn... 2
                if (userCb) cbIndex--;
                z[cbIndex] = function(err) {
                  if (err) {
                    console.log("Got error ", err);
                    nodePromise.reject(err);
                    mainPromise.reject(err);
                    return;
                  }
                  if (userCb) {
                    var args = Array.prototype.slice.call(arguments);
                    var res = userCb.apply(this, args);
                    mainPromise.resolve(res);
                  } else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    mainPromise.resolve.apply(mainPromise, args);
                  }
                }
                nodePromise.then(function(v) {
                  mainPromise.resolve(v);
                });

                console.log("nodeStyle after concat", z);
                var res = fn.apply(this, z);
                // myPromise.resolve(res);
                // return nodePromise;
                return nodePromise;
              }, function(v) {
                mainPromise.reject(v);
              });
              return mainPromise;
              /*
                      log("..... now waiting "+ms);
                      var p = waitFor(ms);
                      p.then( function(v) {
                          myPromise.resolve(v);
                      });
                  */
            }
          );
        }
        _myTrait_.onStateChange = function(fn) {

          if (!this._listeners)
            this._listeners = [];

          this._listeners.push(fn);
        }
        _myTrait_.plugin = function(n, fn) {

          _myTrait_[n] = fn;

          return this;
        }
        _myTrait_.props = function(obj) {
          var args = [];

          for (var n in obj) {
            if (obj.hasOwnProperty(n)) {
              args.push({
                name: n,
                promise: obj[n]
              });
            }
          }


          // console.log(args);
          var targetLen = args.length,
            rCnt = 0,
            myPromises = [],
            myResults = {};

          return this.then(
            function() {

              var allPromise = _promise();
              args.forEach(function(def) {
                var b = def.promise,
                  name = def.name;
                if (b.then) {
                  // console.log("All, looking for ", b, " state = ", b._state);
                  myPromises.push(b);

                  b.then(function(v) {
                    myResults[name] = v;
                    rCnt++;
                    if (rCnt == targetLen) {
                      allPromise.resolve(myResults);
                    }
                  }, function(v) {
                    allPromise.reject(v);
                  });

                } else {
                  allPromise.reject("Not list of promises");
                }
              })

              return allPromise;

            });

        }
        _myTrait_.reject = function(withReason) {

          // if(this._rejected || this._fulfilled) return;

          // conso

          if (this._fulfilled) return;
          if (this._rejected && withReason != this._rejectReason) return;


          this._state = 2;
          this._rejected = true;
          this._rejectReason = withReason;
          var me = this;

          this._childPromises.forEach(function(p) {

            if (p._onReject) {
              try {
                p._onReject(withReason);
                p.reject(withReason);
              } catch (e) {
                /*
                           If either onFulfilled or onRejected throws an exception e, promise2 
                           must be rejected with e as the reason.            
                       */
                p.reject(e);
              }
            } else {
              /*
                       If onFulfilled is not a function and promise1 is fulfilled, promise2 must be 
                       fulfilled with the same value as promise1        
                   */
              p.reject(withReason);
            }
          });

          this._childPromises = [];
          this.triggerStateChange();

        }
        _myTrait_.rejectReason = function(reason) {
          if (reason) {
            this._rejectReason = reason;
            return;
          }
          return this._rejectReason;
        }
        _myTrait_.resolve = function(x) {

          // console.log("Resolving ", x);

          // can not do this many times...
          if (this._state > 0) return;

          if (x == this) {
            // error
            this._rejectReason = "TypeError";
            this.reject(this._rejectReason);
            return;
          }

          if (this.isObject(x) && x._isAPromise) {

            // 
            this._state = x._state;
            this._stateValue = x._stateValue;
            this._rejectReason = x._rejectReason;
            // ... 
            if (this._state === 0) {
              var me = this;
              x.onStateChange(function() {
                if (x._state == 1) {
                  // console.log("State change");
                  me.resolve(x.value());
                }
                if (x._state == 2) {
                  me.reject(x.rejectReason());
                }
              });
            }
            if (this._state == 1) {
              // console.log("Resolved to be Promise was fulfilled ", x._stateValue);
              this.fulfill(this._stateValue);
            }
            if (this._state == 2) {
              // console.log("Relved to be Promise was rejected ", x._rejectReason);
              this.reject(this._rejectReason);
            }
            return;
          }
          if (this.isObject(x) && x.then && this.isFunction(x.then)) {
            // console.log("Thenable ", x);
            var didCall = false;
            try {
              // Call the x.then
              var me = this;
              x.then.call(x,
                function(y) {
                  if (didCall) return;
                  // we have now value for the promise...
                  // console.log("Got value from Thenable ", y);
                  me.resolve(y);
                  didCall = true;
                },
                function(r) {
                  if (didCall) return;
                  // console.log("Got reject from Thenable ", r);
                  me.reject(r);
                  didCall = true;
                });
            } catch (e) {
              if (!didCall) this.reject(e);
            }
            return;
          }
          this._state = 1;
          this._stateValue = x;

          // fulfill the promise...
          this.fulfill(x);

        }
        _myTrait_.state = function(newState) {
          if (typeof(newState) != "undefined") {
            this._state = newState;
          }
          return this._state;
        }
        _myTrait_.then = function(onFulfilled, onRejected) {

          var p = new _promise(onFulfilled, onRejected);
          var me = this;
          if (this._state == 1) {
            // console.log("Already done...");
            later().asap(function() {
              // console.log("Fulfilling this promise a bit late with ", me.value());
              me.fulfill(me.value());
            });
          }
          if (this._state == 2) {
            later().asap(function() {
              me.reject(me.rejectReason());
            });
          }

          this._childPromises.push(p);

          return p;



        }
        _myTrait_.triggerStateChange = function(t) {
          var me = this;
          if (!this._listeners) return;
          this._listeners.forEach(function(fn) {
            fn(me);
          });
          // one-timer
          this._listeners = [];
        }
        _myTrait_.value = function(v) {
          if (typeof(v) != "undefined") {
            this._stateValue = v;
            return this;
          }
          return this._stateValue;
        }
      }(this));
    }
    var _promise = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _promise) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _promise._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _promise(a, b, c, d, e, f, g, h);
    };
    _promise._classInfo = {
      name: '_promise'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_promise", _promise)
    _promise.prototype = new _promise_prototype();
    if (typeof(window) != 'undefined') window['_promise'] = _promise;
    if (typeof(window) != 'undefined') window['_promise_prototype'] = _promise_prototype;
    var _connectManager_prototype = function() {;
      (function(_myTrait_) {
        var _servers;
        _myTrait_.createSocketServer = function(options, port) {

          var sName = options.ip + ":" + options.port;

          if (_servers[sName]) {
            return _servers[sName];
          }

          var socketC = _connSocket({
            url: "http://" + sName + "/",
            ioOptions: {
              'reconnection delay': 500, // defaults to 500
              'reconnection limit': 100, // defaults to Infinity
              'max reconnection attempts': Infinity // defaults to 10
            }
          });
          _servers[sName] = socketC;
          return socketC;



          // var thePath = myDir+_sep_+ctxData.sandbox+_sep_+ctxData.path+_sep_+ctxData.file;







          /*
           {
                sandbox : "f365422c-986c-4630-852b-01871a294a0f",
                path : "objects",
                file : "testSvg2.json"
           }
           */

        }
        _myTrait_.genGUID = function(t) {
          return Math.random().toString(36).substring(2, 15) +
            Math.random().toString(36).substring(2, 15);
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(dataObj, options) {

          if (!_servers) {
            _servers = {};
          }

        });
      }(this));
    }
    var _connectManager = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _connectManager) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _connectManager._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _connectManager(a, b, c, d, e, f, g, h);
    };
    _connectManager._classInfo = {
      name: '_connectManager'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_connectManager", _connectManager)
    _connectManager.prototype = new _connectManager_prototype();
    if (typeof(window) != 'undefined') window['_connectManager'] = _connectManager;
    if (typeof(window) != 'undefined') window['_connectManager_prototype'] = _connectManager_prototype;
    var _connSocket_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.on = function(en, ef) {
          if (!this._ev) this._ev = {};
          if (!this._ev[en]) this._ev[en] = [];

          this._ev[en].push(ef);

          return this;
        }
        _myTrait_.trigger = function(en, data, fn) {

          if (!this._ev) return;
          if (!this._ev[en]) return;
          var me = this;
          this._ev[en].forEach(function(cb) {
            cb(me, data, fn)
          });
          return this;
        }
      }(this));;
      (function(_myTrait_) {
        var _channelIndex;
        var _rootData;
        _myTrait_.createChannel = function(options, url) {

          if (!this._channels) {
            this._channels = [];
          }

          if (!_channelIndex) {
            _channelIndex = {};
          }
          var chStr = options.sandbox + ":" + options.path + ":" + options.file;

          if (_channelIndex[chStr]) {
            return _channelIndex[chStr];
          }

          // create new channel object...
          var chObj = _connChannel(this, options, url);
          _channelIndex[chStr] = chObj;
          return chObj;






        }
        _myTrait_.genGUID = function(t) {
          return Math.random().toString(36).substring(2, 15) +
            Math.random().toString(36).substring(2, 15);
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(options, no) {

          console.log("_connSocket with ", options);
          // The connection initialization for the specific url
          this._socket = io.connect(options.url, options.ioOptions);
          this._options = options;
          this._connInfo = {
            cnt: 0,
            isConnected: false
          }


          var me = this,
            socket = this._socket;

          socket.on("disconnect", function() {
            me._connInfo.isConnected = false;
            me.trigger("disconnect");
          })

          socket.on("connect", function() {
            // Nothing real here... but
            me._connInfo.isConnected = true;
            me.trigger("connect");
          });



        });
        _myTrait_.localCmdBroadcast = function(cmdList) {

          console.log("Remote commands");
          console.log(cmdList);

          // We might here execute some data...
          _rootData._setCmdRemoteUpdate(true);
          _rootData.execCommands(cmdList);
          _rootData._setCmdRemoteUpdate(false);


        }
        _myTrait_.remoteCmdBroadcast = function(cmd) {

          /*
                       
                   dataObj.addCommandListener( function(cmd) {
                       
                       if(!connInfo.isConnected) {
                           sendLater.push(cmd);
                           console.log("Not connected, adding to 'send later buffer");
                           return;
                       }
                       
                       var cObj = {
                           senderId : myID,
                           line : cmd
                       };
                       if(!socket.connected) {
                           alert("Socket not connected!!!");   
                       } else {
                           socket.emit("update_"+chId, cObj);
                       }
                   });
                   
           */
        }
      }(this));
    }
    var _connSocket = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _connSocket) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _connSocket._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _connSocket(a, b, c, d, e, f, g, h);
    };
    _connSocket._classInfo = {
      name: '_connSocket'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_connSocket", _connSocket)
    _connSocket.prototype = new _connSocket_prototype();
    if (typeof(window) != 'undefined') window['_connSocket'] = _connSocket;
    if (typeof(window) != 'undefined') window['_connSocket_prototype'] = _connSocket_prototype;
    var _connChannel_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.on = function(en, ef) {
          if (!this._ev) this._ev = {};
          if (!this._ev[en]) this._ev[en] = [];

          this._ev[en].push(ef);

          return this;
        }
        _myTrait_.trigger = function(en, data, fn) {

          if (!this._ev) return;
          if (!this._ev[en]) return;
          var me = this;
          this._ev[en].forEach(function(cb) {
            cb(me, data, fn)
          });
          return this;
        }
      }(this));;
      (function(_myTrait_) {
        var _myDoc;
        var _waitingAnswers;
        var _channelNamespace;
        _myTrait_.addAnswerCallback = function(id, fn, cmd) {
          if (!_waitingAnswers) _waitingAnswers = {};

          _waitingAnswers[id] = {
            fn: fn,
            cmd: cmd
          };


        }
        _myTrait_.ask = function(cmdObj, callBackFn) {

          var createQuestion = function() {

          }

          cmdObj.__aid = this.genGUID();

          if (callBackFn) {
            this.addAnswerCallback(cmdObj.__aid,
              function(resData) {
                callBackFn(resData.answer);
                delete _waitingAnswers[cmdObj.__aid];
              },
              cmdObj
            );
          }

          console.log("Asking with " + cmdObj.__aid);

          var sock = this.getSocket();
          sock.emit("ask_" + this._channelId, cmdObj);

          // SERVER WILL HANDLE IT LIKE THIS:
          /*
           socket.on("ask_"+_ctx.channelId, function(cObj) {
               if(cObj.cmd=="versionInfo") {
                   // figure out the version information for the server...
                   console.log("Asking version information from "+_ctx.channelId);
                   
                   // fold.fileInformation
                   
                    var fold = jsFolder(_ctx.relPath);
                    fold.fileInformation(_ctx.validFile, function(err, data) {
                        if(err) {
                            fn("readTheFile had error");
                            return;
                        }
                        _ctx.io.sockets.in(socket.id).emit("answer_"+_ctx.channelId, 
                        {
                           __aid : cObj.__aid,
                           question : cObj.cmd,
                           answer : {
                               modtime : data.data.mtime,
                               filesize : data.data.size
                           }
                        }); 
                    });        
           
               }  
           */


          /*
           socket.on("ask_"+_ctx.channelId, function(cObj) {
               
               if(cObj.cmd=="question") {
                   console.log("Got command 'question' with data to "+_ctx.channelId);
                   console.log(cObj);
               }
               
               if(cObj.cmd=="snapshot") {
                   me.createSnapshot();
               }
               if(cObj.cmd=="journalRecord" && cObj.t) {
                var fold = jsFolder(_ctx.relPath);
                fold.getJournalCommandsSince(_ctx.validFile, cObj.t, function(err, data) {
                   //console.log("****** JOURNAL COMMANDS ****** ");
                   //console.log(data);
                });        
               }
           });
           */
        }
        _myTrait_.genGUID = function(t) {
          return Math.random().toString(36).substring(2, 15) +
            Math.random().toString(36).substring(2, 15);
        }
        _myTrait_.getFileData = function(fn) {
          var me = this;
          me._tryCnt = 0;

          var socket = this.getSocket();

          var baseData,
            changeList;

          var feedBackFn = function(d) {
            baseData = JSON.parse(d);
            socket.removeListener("fileData_" + me._channelId, feedBackFn);
          }

          var changeFn = function(d) {
            var chList = [];
            if (d.length > 2) {
              var lines = d.split("\n"),
                len = lines.length;
              for (var i = 0; i < len; i++) {
                var line = lines[i];
                if (!line || line.length < 2) continue;
                //console.log("LINE : "+line);
                chList.push(JSON.parse(line));
              }
            }
            fn(baseData, chList);
            socket.removeListener("changeData_" + me._channelId, changeFn);
          }

          // fetching the filedata...
          socket.on("fileData_" + this._channelId, feedBackFn);
          socket.on("changeData_" + this._channelId, changeFn);

          socket.emit(this._channelId, {
            cmd: "getFile"
          });
        }
        _myTrait_.getID = function(t) {
          return this._channelId;
        }
        _myTrait_.getSocket = function(t) {
          return this._socketObj._socket;
        }
        _myTrait_.getURL = function(t) {

          return this._url;
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(socketObj, options, url) {

          var me = this;

          var socket = socketObj._socket;
          this._socketObj = socketObj;
          this._options = options;
          this._url = url;

          //console.log("***** init channel with options *****");
          //console.log(options);

          if (!_myDoc) _myDoc = _docUp();

          var myGUID = this.genGUID();
          this._options.responseId = myGUID;
          me._tryCnt = 0;
          var respEvent = function(response) {

            var data = response.channelId,
              namespace = response.namespace;

            if (!_channelNamespace) {
              _channelNamespace = {};
            }

            // here are the channel namespace commands, of course the namespaced objects are
            // acting on the local space only
            if (!_channelNamespace[url]) {
              _channelNamespace[url] = namespace;
            }

            var rad = docRadio();
            rad.namespace(url, namespace);

            if (me._tryCnt == 0) {

              // TODO: rewrite 

              socket.on("ctxupd_" + data, function(cObj) {

                if (!_myDoc._enterCtx(me._channelId)) return;

                // --- remote update might be set here on / off
                cObj.forEach(function(c) {
                  _myDoc._setCtx(c.ctx);
                  options.listeners.onCommand.forEach(function(fn) {
                    fn(c.cmd, c.ctx);
                  })
                  // options.onCommand( c.cmd );
                  _myDoc._resetCtx();
                });
                _myDoc._leaveCtx(me._channelId);
              });

              socket.on("answer_" + data, function(cObj) {
                if (!_waitingAnswers) return;
                var w = _waitingAnswers[cObj.__aid];
                if (w) {
                  w.fn(cObj);
                }
              });
              /*
             _ctx.io.sockets.in(socket.id).emit("answer_"+_ctx.channelId, 
             {
                __aid : cObj.__aid,
                question : cObj.cmd,
                answer : {
                    modtime : data.data.mtime,
                    filesize : data.data.size
                }
             });         
        */
            }

            me._channelId = data;
            me._isConnected = true; // => should go false if socket is disconnected
            me._tryCnt++;
            me.trigger("connect");
            me.resolve(me._channelId);
            // socket.removeListener( respEvent );
          };

          socket.on(myGUID, respEvent);

          if (socket.connected) {
            console.log("Sending request for channel ");
            socket.emit("requestChannel", me._options);
          } else {

            // re-submit if not connected already..
            socket.on("connect", function() {
              console.log("Sending request for channel ");
              socket.emit("requestChannel", me._options);
            });

          }



        });
      }(this));
    }
    _connChannel_prototype.prototype = _promise.prototype
    var _connChannel = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _connChannel) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _connChannel._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _connChannel(a, b, c, d, e, f, g, h);
    };
    _connChannel._classInfo = {
      name: '_connChannel'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_connChannel", _connChannel)
    _connChannel.prototype = new _connChannel_prototype();
    if (typeof(window) != 'undefined') window['_connChannel'] = _connChannel;
    if (typeof(window) != 'undefined') window['_connChannel_prototype'] = _connChannel_prototype;;
    (function(_myTrait_) {
      var _eventOn;
      var _commands;
      _myTrait_.guid = function(t) {

        return Math.random().toString(36).substring(2, 15) +
          Math.random().toString(36).substring(2, 15);

        //return Math.random();
        // return Math.random().toString(36);

        /*    
           return Math.random().toString(36).substring(2, 15) +
                   Math.random().toString(36).substring(2, 15);
           */
        /*        
           function s4() {
               return Math.floor((1 + Math.random()) * 0x10000)
                          .toString(16)
                          .substring(1);
             }
           
           return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                  s4() + '-' + s4() + s4() + s4();*/
      }
      _myTrait_.isArray = function(t) {

        if (typeof(t) == "undefined") return this.__isA;

        return Object.prototype.toString.call(t) === '[object Array]';
      }
      _myTrait_.isFunction = function(fn) {
        return Object.prototype.toString.call(fn) == '[object Function]';
      }
      _myTrait_.isObject = function(t) {

        if (typeof(t) == "undefined") return this.__isO;

        return t === Object(t);
      }
    }(this));;
    (function(_myTrait_) {
      var _listeners;
      var _channels;
      var _loading;
      var _namespaces;
      var _myDoc;
      _myTrait_.ask = function(url, question, callBack, extraData) {

        var cmdObj = {
          cmd: question
        };
        if (extraData) cmdObj.data = extraData;

        var ch = _channels[url];
        if (!ch) return;

        console.log("About to send question ", cmdObj);

        var ch = ch.channel;
        if (ch) ch.ask(cmdObj, callBack);
      }
      _myTrait_.askPromise = function(url, options) {

        var ch = _channels[url];
        if (!ch) return;

        console.log("Creating ask promise");

        var myPromise = _wish();
        var ch = ch.channel;
        if (ch) ch.ask(options, function(res) {
          myPromise.resolve(res);
        });

        return myPromise;
      }
      _myTrait_.command = function(url, cmdData) {
        var cmdObj = {
          cmd: "cmd",
          data: cmdData
        };

        console.log("radio command called ");

        return _promise(function(resolve, fail) {

          fail("promise with : " + url);

          var ch = _channels[url];
          if (!ch) fail("no such channel : " + url);

          var ch = ch.channel;

          console.log("going to ask ", ch);
          if (ch) ch.ask(cmdObj, resolve);

        });

      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(main) {


        if (!_channels) {
          _channels = {};
          _loading = {};
          _namespaces = {};
          _myDoc = _docUp();
        }
      });
      _myTrait_.listen = function(url, options) {

        var chData = this.parseRemoteUrl(url);
        var channel = chData.channel;

        channel.listeners = {
          onCommand: []
        };

        if (options.onCommand) {
          channel.listeners.onCommand.push(options.onCommand);
        }

        var s = _connectManager().createSocketServer({
          ip: channel.ip,
          port: channel.port
        });

        var me = this;

        if (options && this.isObject(options) && options.createWith) {
          channel.createWith = options.createWith;
        }
        if (options && this.isObject(options) && options.dataNS) {
          channel.dataNS = options.dataNS;
        }

        var chPromise = _promise();

        // connecting to the selected file...
        var ch = s.createChannel(channel, url);

        var myChannel = {
          channel: ch,
          createdTime: (new Date()).getTime(),
          bConnected: false,
          bFileLoaded: false,
          createOptions: channel,
          listenerOptions: [] // The listener options for the channel...
        }

        _channels[url] = myChannel;
        myChannel.listenerOptions.push(options);

        ch.then(function() {
          myChannel.bConnected = true;
          ch.getFileData(function(remoteData, changeList) {

            console.log("*********** CHANNEL ID ", ch.getID());

            var lo = myChannel.listenerOptions;
            myChannel.initData = remoteData;
            myChannel.initChanges = changeList;
            for (var i = 0; i < lo.length; i++) {
              var opts = lo[i];
              if (opts.onFile) {
                opts.onFile(remoteData, changeList, ch.getURL());
              }
            }

            myChannel.bFileLoaded = true;
            chPromise.resolve(true);

          });
        });



        return chPromise;
      }
      _myTrait_.namespace = function(channelId, setValue) {

        if (typeof(setValue) != "undefined") {
          _namespaces[channelId] = setValue;
          return this;
        }

        return _namespaces[channelId] || "";
      }
      _myTrait_.parseRemoteUrl = function(url) {
        console.log("Parsing ", url);
        var parts1 = url.split("://");
        var protocol = parts1.shift(),
          rest = parts1.shift();
        var serverParts = rest.split("/"),
          ipAndPort = serverParts.shift(),
          iParts = ipAndPort.split(":"),
          ip = iParts[0],
          port = iParts[1],
          sandbox = serverParts.shift(),
          fileName = serverParts.pop(),
          path = serverParts.join("/");

        var reqData = {
          channel: {
            ip: ip,
            port: port,
            sandbox: sandbox,
            path: path,
            file: fileName,
            auth: {
              u: "abba",
              p: "nowp"
            }
          }
        };

        return reqData;
      }
      _myTrait_.send = function(url, cmdList) {
        if (_channels && _channels[url]) {

          var ch = _channels[url].channel;
          if (ch) {
            if (!_myDoc._enterCtx(ch._channelId)) return;
            // console.log("Found the channel, ready to broadcast in theory");
            var s = ch.getSocket();
            // list of commands to be sent...
            s.emit("ctxupd_" + ch._channelId, cmdList);
            _myDoc._leaveCtx(ch._channelId);
          }

        }
        /*
            myT._addCommandChannel({
                broadcast : function(obj) {
                    console.log("***** SENDING DATA *****");
                    //console.log(JSON.stringify( obj.__ctxCmdList, null, 2) );
                    
                    var ch = myT._findActiveChannel();
                    if(ch) {
                        if(!myT._enterCtx(ch._channelId)) return;
                        // console.log("Found the channel, ready to broadcast in theory");
                        var s = ch.getSocket();
                        s.emit("ctxupd_"+ch._channelId, obj.__ctxCmdList);
                        myT._leaveCtx(ch._channelId);
                    }
                                  
                }
            })
            
            */

      }
      _myTrait_.snapshot = function(url, data) {

        if (!data) return;

        var ch = _channels[url];
        if (!ch) return;

        var cmdObj = {
          cmd: "snapshot"
        };

        cmdObj.rawData = data;

        var ch = ch.channel;
        if (ch) ch.ask(cmdObj);
      }
    }(this));
  }
  var docRadio = function(a, b, c, d, e, f, g, h) {
    if (this instanceof docRadio) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != docRadio._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new docRadio(a, b, c, d, e, f, g, h);
  };
  docRadio._classInfo = {
    name: 'docRadio'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("docRadio", docRadio)
  docRadio.prototype = new docRadio_prototype();
  if (typeof(window) != 'undefined') window['docRadio'] = docRadio;
  if (typeof(window) != 'undefined') window['docRadio_prototype'] = docRadio_prototype;
  var DataSubClass_prototype = function() {;
    (function(_myTrait_) {
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {

      });
      _myTrait_.sayHelloToSub = function(t) {
        alert("Sub says hi!");
      }
    }(this));
  }
  DataSubClass_prototype.prototype = _data.prototype
  var DataSubClass = function(a, b, c, d, e, f, g, h) {
    if (this instanceof DataSubClass) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != DataSubClass._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new DataSubClass(a, b, c, d, e, f, g, h);
  };
  DataSubClass._classInfo = {
    name: 'DataSubClass'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("DataSubClass", DataSubClass)
  DataSubClass.prototype = new DataSubClass_prototype();
  if (typeof(window) != 'undefined') window['DataSubClass'] = DataSubClass;
  if (typeof(window) != 'undefined') window['DataSubClass_prototype'] = DataSubClass_prototype;
  var DataSubClass2_prototype = function() {;
    (function(_myTrait_) {
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {

      });
      _myTrait_.sayHelloToSub = function(t) {
        alert("Second sub says hi!");
      }
    }(this));
  }
  DataSubClass2_prototype.prototype = _data.prototype
  var DataSubClass2 = function(a, b, c, d, e, f, g, h) {
    if (this instanceof DataSubClass2) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != DataSubClass2._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new DataSubClass2(a, b, c, d, e, f, g, h);
  };
  DataSubClass2._classInfo = {
    name: 'DataSubClass2'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("DataSubClass2", DataSubClass2)
  DataSubClass2.prototype = new DataSubClass2_prototype();
  if (typeof(window) != 'undefined') window['DataSubClass2'] = DataSubClass2;
  if (typeof(window) != 'undefined') window['DataSubClass2_prototype'] = DataSubClass2_prototype;
  var channelDebug_prototype = function() {;
    (function(_myTrait_) {
      _myTrait_.getElem = function(t) {
        return this._o;
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(channelID, dataObj) {

        this._id = channelID;
        this._up = _docUp();

        this._o = _e();
        var me = this;


        this._o.button().text("Step commands").on("click", function() {
          me._up._stepCommandList(channelID);
        });

        var cmdList = this._o.div("commandHistory");

        var cmdNames = [
          "",
          "Create Object",
          "Create Array",
          "Init property",
          "Set Value",
          "Set Member",
          "Push",
          "Push Object",
          "Remove",
          "",
          "Remove Property",
          "Insert Object At",
          "Move to Index",
          "",
          "",
          "",
          "Create Remote Object"
        ];

        // the current state of the commands...

        var lastIndex = 0;
        later().every(1 / 10, function() {

          var history = me._up._getCommandHistory(me._id);

          var index = me._up._getCommandPointer();

          while (history.length > lastIndex) {
            var cmdDiv = cmdList.div("cmdDiv"),
              cmdTable = cmdDiv.table(),
              cmd = history[lastIndex],
              cmdDetails = cmdDiv.div(),
              detailsBtn = _e("button"),
              status = _e();


            if (1) {
              (function(cmd, cmdDetails) {

                detailsBtn.text("Details").on("click", function() {
                  cmdDetails.clear();
                  var ul = cmdDetails.ul();
                  ul.li().text(cmd.cmd[0]);
                  ul.li().text(cmd.cmd[1]);
                  ul.li().text(cmd.cmd[2]);
                  ul.li().text(cmd.cmd[3]);
                  ul.li().text(cmd.cmd[4]);
                  ul.li().text(cmd.cmd[5]);
                  ul.li().text(cmd.cmd[6]);
                });

                var btn = status.button().text("Run").on("click", function() {
                  _docUp().execCommand(cmd.cmd, true);
                  btn.text("Done");
                });
              }(cmd, cmdDetails));
            } else {
              status.text("Executed");
            }
            cmdTable.addRow(status, cmd.cmd[0], "=", cmdNames[cmd.cmd[0]], detailsBtn);
            lastIndex++;
          }


        });


        /*
{"cmd":[1,"2o2zkfk56s10pjpxl4vizruow2",{},null,"2o2zkfk56s10pjpxl4vizruow2",1428922226511],"ctx":{},"r":true}
{"cmd":[7,0,"2o2zkfk56s10pjpxl4vizruow2",null,"0iosd0sojxb9bg377a70221emi",1428922226515],"ctx":{},"r":true}
{"cmd":[4,"name","test",null,"2o2zkfk56s10pjpxl4vizruow2",1428922226511],"ctx":{},"r":true}
*/
        /*
    _cmdIndex = {}; 
    _cmdIndex["createObject"] = 1;
    _cmdIndex["createArray"]  = 2;
    _cmdIndex["initProp"]  = 3;
    _cmdIndex["set"]  = 4;
    _cmdIndex["setMember"]  = 5;
    _cmdIndex["push"]  = 6;
    _cmdIndex["pushObj"]  = 7;
    _cmdIndex["removeItem"]  = 8;
    
    // reserved 9 for optimizations
    _cmdIndex["last"]  = 9;
    
    _cmdIndex["removeProperty"]  = 10;
    _cmdIndex["insertObjectAt"]  = 11;
    _cmdIndex["moveToIndex"]  = 12;
*/
      });
    }(this));
  }
  var channelDebug = function(a, b, c, d, e, f, g, h) {
    if (this instanceof channelDebug) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != channelDebug._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new channelDebug(a, b, c, d, e, f, g, h);
  };
  channelDebug._classInfo = {
    name: 'channelDebug'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("channelDebug", channelDebug)
  channelDebug.prototype = new channelDebug_prototype();
  if (typeof(window) != 'undefined') window['channelDebug'] = channelDebug;
  if (typeof(window) != 'undefined') window['channelDebug_prototype'] = channelDebug_prototype;
  var diffEngine_prototype = function() {;
    (function(_myTrait_) {
      var _eventOn;
      var _commands;
      _myTrait_.guid = function(t) {

        return Math.random().toString(36).substring(2, 15) +
          Math.random().toString(36).substring(2, 15);

        //return Math.random();
        // return Math.random().toString(36);

        /*    
           return Math.random().toString(36).substring(2, 15) +
                   Math.random().toString(36).substring(2, 15);
           */
        /*        
           function s4() {
               return Math.floor((1 + Math.random()) * 0x10000)
                          .toString(16)
                          .substring(1);
             }
           
           return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                  s4() + '-' + s4() + s4() + s4();*/
      }
      _myTrait_.isArray = function(t) {

        if (typeof(t) == "undefined") return this.__isA;

        return Object.prototype.toString.call(t) === '[object Array]';
      }
      _myTrait_.isFunction = function(fn) {
        return Object.prototype.toString.call(fn) == '[object Function]';
      }
      _myTrait_.isObject = function(t) {

        if (typeof(t) == "undefined") return this.__isO;

        return t === Object(t);
      }
    }(this));;
    (function(_myTrait_) {
      var _all;
      var _data1;
      var _data2;
      var _up;
      var _reals;
      var _missing;
      var _added;
      var _parents;
      _myTrait_._createModelCommands = function(obj, parentObj, intoList) {

        /*
               _cmdIndex = {}; 
               _cmdIndex["createObject"] = 1;
               _cmdIndex["createArray"]  = 2;
               _cmdIndex["initProp"]  = 3;
               _cmdIndex["set"]  = 4;
               _cmdIndex["setMember"]  = 5;
               _cmdIndex["push"]  = 6;
               _cmdIndex["pushObj"]  = 7;
               _cmdIndex["removeItem"]  = 8;
               
               // reserved 9 for optimizations
               _cmdIndex["last"]  = 9;
               
               _cmdIndex["removeProperty"]  = 10;
               _cmdIndex["insertObjectAt"]  = 11;
               _cmdIndex["moveToIndex"]  = 12;
           */

        if (!intoList) intoList = [];

        var data;

        if (obj.data && obj.__id) {
          data = obj.data;
        } else {
          data = obj;
        }

        if (this.isObject(data) || this.isArray(data)) {

          var newObj;

          if (obj.__id) {
            newObj = obj;
          } else {
            newObj = {
              data: data,
              __id: this.guid()
            }
          }

          if (this.isArray(data)) {
            var cmd = [2, newObj.__fork || newObj.__id, [], null, newObj.__fork || newObj.__id];
          } else {
            var cmd = [1, newObj.__fork || newObj.__id, {},
              null, newObj.__fork || newObj.__id
            ];
          }
          if (parentObj) {
            newObj.__p = parentObj.__id;
            // this._moveCmdListToParent( newObj );
          }
          intoList.push(cmd);

          // Then, check for the member variables...
          for (var n in data) {
            if (data.hasOwnProperty(n)) {
              var value = data[n];
              if (this.isObject(value) || this.isArray(value)) {
                // Then create a new...
                var oo = this._createModelCommands(value, newObj, intoList);
                var cmd = [5, n, oo.__fork || oo.__id, null, newObj.__fork || newObj.__id];
                intoList.push(cmd);
              } else {
                var cmd = [4, n, value, null, newObj.__fork || newObj.__id];
                intoList.push(cmd);
              }
            }
          }

          return newObj;
        } else {

        }



        /*
           var newObj = {
               data : data,
               __id : this.guid()
           }
           */
      }
      _myTrait_.addedObjects = function(t) {

        var res = [];

        for (var id in _data2) {
          if (_data2.hasOwnProperty(id)) {
            if (!_data1[id]) {
              res.push(id);
              _added[id] = _data2[id];
            }
          }
        }

        return res;
      }
      _myTrait_.commonObjects = function(t) {
        var res = [];

        for (var id in _all) {
          if (_data1[id] && _data2[id]) {
            res.push(id);
          }
        }

        return res;
      }
      _myTrait_.compareFiles = function(data1, data2) {

        _data1 = {};
        _data2 = {};
        _all = {};
        _reals = {};
        _missing = {};
        _added = {};
        _parents = {};

        this.findObjects(data1, _data1);
        this.findObjects(data2, _data2);

        var details = {
          missing: this.missingObjects(),
          added: this.addedObjects(),
          common: this.commonObjects(),
          cMod: [],
          cmds: []
        };

        var me = this;
        details.common.forEach(function(id) {
          var diff = me.objectDiff(_data1[id], _data2[id]);
          details.cMod.push(diff);
        });

        var me = this;
        details.added.forEach(function(cid) {
          var cmdList = [];
          var obj = _all[cid];
          me._createModelCommands(obj, null, cmdList);

          cmdList.forEach(function(cmd) {
            details.cmds.push(cmd);
          });
        });
        details.cMod.forEach(function(c) {
          c.cmds.forEach(function(cc) {
            details.cmds.push(cc);
          });
        });


        return details;

      }
      _myTrait_.findObjects = function(data, saveTo, parentObj) {

        console.log("findObjects called with ", data);
        if (data && data.__id) {
          saveTo[data.__fork || data.__id] = data;
          _all[data.__fork || data.__id] = data;
          _reals[data.__id] = data;
        }

        if (data.data) {
          var sub = data.data;
          for (var n in sub) {
            if (sub.hasOwnProperty(n)) {
              var p = sub[n];
              if (this.isObject(p)) {
                _parents[p.__fork || p.__id] = data.__fork || data.__id;
                this.findObjects(p, saveTo);
              }
            }
          }
        }
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {

        if (!_up) {
          _up = _docUp();
          _reals = {};
        }
      });
      _myTrait_.missingObjects = function(t) {

        var res = [];

        for (var id in _data1) {
          if (_data1.hasOwnProperty(id)) {
            if (!_data2[id]) {
              _missing[id] = _data1[id];
              res.push(id);
            }
          }
        }

        return res;
      }
      _myTrait_.objectDiff = function(obj1, obj2) {
        var res = {
          modified: [],
          posMoved: [],
          sourcesAndTargets: [],
          cmds: []
        };

        if (obj1.data && obj2.data && this.isObject(obj1.data) && !this.isArray(obj1.data)) {
          var sub = obj1.data;
          for (var n in obj2.data) {
            if (obj2.data.hasOwnProperty(n)) {
              var v = sub[n],
                objid = obj1.__fork || obj1.__id;
              if (!this.isObject(v) && (!this.isArray(v))) {
                if (obj2.data[n] != v) {
                  res.modified.push({
                    id: objid,
                    prop: n,
                    from: v,
                    to: obj2.data[n]
                  });
                  res.cmds.push([4, n, obj2.data[n], v, objid]);
                }
              }
            }
          }
        }
        if (this.isArray(obj1.data)) {

          var arr1 = obj1.data,
            arr2 = obj2.data,
            sourceArray = [],
            targetArray = [],
            len1 = arr1.length,
            len2 = arr2.length;
          // insert
          // [7, 0, <insertedID>, 0, <parentId>]

          // remove
          // [8, 0, <insertedID>, 0, <parentId>]        
          for (var i = 0; i < len1; i++) {
            var o = arr1[i];
            if (this.isObject(o)) {
              var activeId = o.__fork || o.__id;
              if (!_missing[activeId]) {
                sourceArray.push(activeId);
              } else {
                // res.cmds.push("remove "+activeId);
                res.cmds.push([8, 0, activeId, 0, _parents[activeId]]);
              }
            }
          }
          var indexArr = {},
            reverseIndex = {},
            sourceReverseIndex = {};
          for (var i = 0; i < len2; i++) {
            var o = arr2[i];
            if (this.isObject(o)) {
              var activeId = o.__fork || o.__id;
              indexArr[activeId] = i;
              reverseIndex[i] = activeId;
              if (_added[activeId]) {
                sourceArray.push(activeId);
                // res.cmds.push("insert "+activeId);
                res.cmds.push([7, 0, activeId, 0, _parents[activeId]]);
              }
              targetArray.push(activeId);
            }
          }

          var list = [],
            i = 0;
          sourceArray.forEach(function(id) {
            list.push(indexArr[id]);
            sourceReverseIndex[id] = i;
            i++;
          });

          res.restackIndex = indexArr;
          res.restackList = list;
          res.reverseIndex = reverseIndex;
          res.restack = this.restackOps(list);


          // insert
          // [7, 0, <insertedID>, 0, <parentId>]

          // remove
          // [8, 0, <insertedID>, 0, <parentId>]

          // move
          // [12, <insertedID>, <index>, 0, <parentId>]       

          var cmdList = [],
            sourceArrayWork = sourceArray.slice();

          res.restack.forEach(function(c) {
            if (c[0] == "a") {
              var moveItemId = reverseIndex[c[1]],
                aboveItemId = reverseIndex[c[2]],
                atIndex = indexArr[aboveItemId],
                fromIndex = sourceArrayWork.indexOf(moveItemId);

              sourceArrayWork.splice(fromIndex, 1);
              var toIndex = sourceArrayWork.indexOf(aboveItemId);
              sourceArrayWork.splice(toIndex, 0, moveItemId);

              var obj = _all[moveItemId];

              res.cmds.push([12, moveItemId, toIndex, 0, _parents[moveItemId]]);
              //             cmdList.push(" move item "+moveItemId+" above "+aboveItemId+ " from "+fromIndex+ " to "+toIndex);


            } else {
              var moveItemId = reverseIndex[c[1]],
                aboveItemId = reverseIndex[c[2]],
                atIndex = indexArr[aboveItemId],
                fromIndex = sourceArrayWork.indexOf(moveItemId);
              sourceArrayWork.splice(fromIndex, 1);
              var toIndex = sourceArrayWork.indexOf(aboveItemId) + 1;
              sourceArrayWork.splice(toIndex, 0, moveItemId);
              // cmdList.push(" move item "+moveItemId+" above "+aboveItemId+ " from "+fromIndex+ " to "+toIndex);  
              res.cmds.push([12, moveItemId, toIndex, 0, _parents[moveItemId]]);
            }
          });
          res.stackCmds = cmdList;
          res.sourceArrayWork = sourceArrayWork;


          res.sourcesAndTargets.push([sourceArray, targetArray]);

        }


        return res;
      }
      _myTrait_.restackOps = function(input) {
        var moveCnt = 0,
          cmds = [];

        function restack(input) {
          var data = input.slice(0);
          var dataIn = input.slice(0);
          var goalIn = input.slice(0).sort(function(a, b) {
            return a - b;
          });

          var mapper = {};
          var indexes = {};
          // Testing this kind of simple system...
          for (var i = 0; i < dataIn.length; i++) {
            var mm = goalIn.indexOf(dataIn[i]);
            mapper[dataIn[i]] = mm;
            indexes[mm] = dataIn[i];
            data[i] = mm;
          }

          var goal = data.slice(0).sort(function(a, b) {
            return a - b;
          });

          var minValue = data[0],
            maxValue = data[0],
            partDiffs = [],
            partCum = 0,
            avgDiff = function() {
              var i = 0;
              len = data.length, df = 0;
              for (; i < len; i++) {
                var v = data[i];
                if (v > maxValue) maxValue = v;
                if (v < minValue) minValue = v;
                if (i > 0) partDiffs.push(goal[i] - goal[i - 1]);
                if (i > 0) partCum += Math.abs(goal[i] - goal[i - 1]);
                df += Math.abs(v - goal[i]);
              }
              partCum = partCum / len;
              return df / len;
            }();

          partDiffs.sort(function(a, b) {
            return a - b;
          });
          var minDelta = partDiffs[0];

          // collects one "acceptable" array 
          var accept = function(fn) {
            var collect = function(i, sx, last) {
              var res = [];
              var len = data.length;
              if (!sx) sx = 0;
              for (; i < len; i++) {
                var v = data[i];
                if ((v - last) == 1) {
                  res.push(v);
                  last = v;
                  continue;
                }
                var gi = i + sx;
                if (gi < 0) gi = 0;
                if (gi >= len) gi = len - 1;
                if (fn(v, goal[gi], v, last, i, len)) {
                  if ((data[i + 1] && data[i + 1] < v && data[i + 1] > last)) {
                    // skip, if next should be taken instead 
                  } else {
                    res.push(v);
                    last = v;
                  }
                }
              }
              return res;
            }

            var m = [];
            var ii = 0,
              a = 0;
            // small tricks to improve the algo, just for comp's sake...
            while (a < 0.1) {
              for (var sx = -5; sx <= 5; sx++)
                m.push(collect(Math.floor(data.length * a), sx, minValue - 1));
              a += 0.05;
            }
            m.sort(function(a, b) {
              return b.length - a.length;
            });
            return m[0];
          };

          // different search agents...
          var test = [
            accept(function(dv, gv, v, last, i, len) {
              // console.log(Math.abs(v-last)+" vs "+partCum);
              if (v < last) return false;
              if (i > 0)
                if (Math.abs(v - last) > partDiffs[i - 1]) return false;
              if (Math.abs(v - last) > avgDiff) return false;
              if (Math.abs(dv - gv) <= avgDiff * (i / len) && v >= last) return true;
              if (Math.abs(last - v) <= avgDiff * (i / len) && v >= last) return true;
              return false;
            }),
            accept(function(dv, gv, v, last, i, len) {
              if (v < last) return false;
              if (Math.abs(v - last) > avgDiff) return false;
              if (Math.abs(dv - gv) <= avgDiff * (i / len) && v >= last) return true;
              if (Math.abs(last - v) <= avgDiff * (i / len) && v >= last) return true;
              return false;
            }),
            accept(function(dv, gv, v, last, i, len) {
              if (v < last) return false;
              if (Math.abs(v - last) > avgDiff) return false;
              if (Math.abs(dv - gv) <= avgDiff * (i / len) && v >= last) return true;
              if (Math.abs(last - v) <= avgDiff * (i / len) && v >= last) return true;
              return false;
            }),
            accept(function(dv, gv, v, last, i, len) {
              if (v < last) return false;
              if (Math.abs(dv - gv) <= avgDiff * (i / len) && v >= last) return true;
              if (Math.abs(last - v) <= avgDiff * (i / len) && v >= last) return true;
              return false;
            }),
            accept(function(dv, gv, v, last, i, len) {
              if (v < last) return false;
              if (Math.abs(dv - gv) <= avgDiff && v >= last) return true;
              if (Math.abs(last - v) <= avgDiff * (i / len) && v >= last) return true;
              return false;
            }),
            accept(function(dv, gv, v, last, i, len) {
              if (v < last) return false;
              if (Math.abs(v - last) < partCum) return true;
              if (Math.abs(dv - gv) <= partCum && v >= last) return true;
              return false;
            }),
            accept(function(dv, gv, v, last, i, len) {
              if (v > last) return true;
              return false;
            }),
            accept(function(dv, gv, v, last, i, len) {
              if (v < last) return false;
              if (Math.abs(v - last) > avgDiff) return false;
              if (Math.abs(dv - gv) <= avgDiff && v >= last) return true;
              return false;
            }),
            accept(function(dv, gv, v, last, i, len) {
              if (v < last) return false;
              if (i > 0)
                if (Math.abs(v - last) > avgDiff) return false;
              if (Math.abs(dv - gv) <= avgDiff * (i / len) && v >= last) return true;
              if (i > 0)
                if (Math.abs(last - v) <= avgDiff * (i / len) && v >= last) return true;
              return false;
            }),
            accept(function(dv, gv, v, last, i, len) {
              if (v < last) return false;
              if (last >= minValue) {
                if (v >= last) return true;
              } else {
                if (v == minValue) return true;
              }
              return false;
            })
          ];


          // choose between algorithms
          var okVals = [],
            maxSet = 0;
          for (var i = 0; i < test.length; i++) {
            var set = test[i];
            if (set.length > maxSet) {
              okVals = set;
              maxSet = set.length;
            }
          }
          // if nothing, take something
          if (okVals.length == 0) okVals = [goal[Math.floor(goal.length / 2)]];

          // divide the list to big and small
          var big = [],
            small = [];
          var divide = function() {
            var min = minValue,
              max = okVals[0],
              okLen = okVals.length,
              oki = data.indexOf(max),
              index = 0;

            var i = 0;
            len = data.length;
            for (; i < len; i++) {
              var v = data[i];
              if (v >= min && v <= max && (i <= oki)) {
                big.push(v);
                min = v;
              } else {
                small.push(v);
              }
              if (v == max) {
                min = v;
                if (index < okLen - 1) {
                  index++;
                  max = okVals[index];
                  oki = data.indexOf(max);
                } else {
                  max = maxValue;
                  oki = len + 1;
                }
              }
            }

          }();

          // sort the small list before joining them
          small.sort(function(a, b) {
            return a - b;
          });

          //console.log(big);
          //console.log(small);

          var joinThem = function() {
            var si = 0,
              bi = 0,
              lastb = big[0],
              slen = small.length;
            while (si < slen) {
              var b = big[bi],
                s = small[si];
              if (typeof(b) == "undefined") {
                while (si < slen) {
                  cmds.push(["b", indexes[s], indexes[lastb]]);
                  // restackXBelowY(dataIn, indexes[s], indexes[lastb]);
                  lastb = s;
                  si++;
                  s = small[si]
                }
                return;
              }
              if (b < s) {
                // console.log("B was smaller");
                lastb = b;
                bi++;
              } else {
                cmds.push(["a", indexes[s], indexes[b]]);
                // restackXAboveY(dataIn, indexes[s], indexes[b]);
                si++;
              }
            }
          }();

          // console.log(dataIn);
          return data; // actually the return value is not used for anything    

        }
        restack(input);

        return cmds;

      }
    }(this));
  }
  var diffEngine = function(a, b, c, d, e, f, g, h) {
    if (this instanceof diffEngine) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != diffEngine._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new diffEngine(a, b, c, d, e, f, g, h);
  };
  diffEngine._classInfo = {
    name: 'diffEngine'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("diffEngine", diffEngine)
  diffEngine.prototype = new diffEngine_prototype();
  if (typeof(window) != 'undefined') window['diffEngine'] = diffEngine;
  if (typeof(window) != 'undefined') window['diffEngine_prototype'] = diffEngine_prototype;
  var sequenceStepper_prototype = function() {;
    (function(_myTrait_) {
      var _eventOn;
      var _commands;
      _myTrait_.guid = function(t) {

        return Math.random().toString(36).substring(2, 15) +
          Math.random().toString(36).substring(2, 15);

        //return Math.random();
        // return Math.random().toString(36);

        /*    
           return Math.random().toString(36).substring(2, 15) +
                   Math.random().toString(36).substring(2, 15);
           */
        /*        
           function s4() {
               return Math.floor((1 + Math.random()) * 0x10000)
                          .toString(16)
                          .substring(1);
             }
           
           return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                  s4() + '-' + s4() + s4() + s4();*/
      }
      _myTrait_.isArray = function(t) {

        if (typeof(t) == "undefined") return this.__isA;

        return Object.prototype.toString.call(t) === '[object Array]';
      }
      _myTrait_.isFunction = function(fn) {
        return Object.prototype.toString.call(fn) == '[object Function]';
      }
      _myTrait_.isObject = function(t) {

        if (typeof(t) == "undefined") return this.__isO;

        return t === Object(t);
      }
    }(this));;
    (function(_myTrait_) {
      var _instances;
      if (!_myTrait_.hasOwnProperty('__factoryClass')) _myTrait_.__factoryClass = []
      _myTrait_.__factoryClass.push(function(id, manual) {

        if (id === false && manual) return;

        if (!_instances) {
          _instances = {};
        }

        if (_instances[id]) {
          return _instances[id];
        } else {
          _instances[id] = this;
        }
      });
      _myTrait_.addCommands = function(cmdFunction, failure) {

        if (this.isArray(cmdFunction)) {
          var me = this;
          cmdFunction.forEach(function(c) {
            me.addCommands(c);
          });
          return this;
        }

        this._commands.push({
          fnCmd: cmdFunction,
          fnFail: failure,
          async: true
        });
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(myId, manual) {

        if (!this._commands) {
          this._commands = [];
          this.waitingList = [];
          this._index = 0;
        }

        var me = this;
        if (!manual) {
          later().every(1 / 30, function() {
            me.step();
          });
        }

      });
      _myTrait_.step = function(t) {
        var i = this._index,
          len = this._commands.length;

        if (i == len) return;

        var first = _promise(),
          currentProm = first,
          myPromise = _promise(),
          me = this;

        while (i < len) {
          var fn = this._commands[i];
          (function(fn) {
            currentProm = currentProm.then(function() {

              var p = _promise();

              // if(fn.async) {

              fn.fnCmd(function(res) {
                p.resolve(true);
              }, function(failReason) {
                p.resolve(true);
                if (fn.fnFail) fn.fnFail(failReason);
              });

              return p;
            }).fail(function(reason) {
              if (fn.fnFail) fn.fnFail(reason);
            });
          }(fn));
          this._index++;
          i++;
        }

        currentProm.then(function() {
          me.waitingList.shift(); // remvoe this promise from the queque
          myPromise.resolve(true);
          if (me.waitingList.length) {
            var newP = me.waitingList[0];
            newP.resolve(true);
          }
        }).fail(function(m) {

        });


        this.waitingList.push(first);
        if (this.waitingList.length == 1) {
          first.resolve(true);
        }
        return myPromise;

      }
    }(this));
  }
  var sequenceStepper = function(a, b, c, d, e, f, g, h) {
    if (this instanceof sequenceStepper) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != sequenceStepper._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new sequenceStepper(a, b, c, d, e, f, g, h);
  };
  sequenceStepper._classInfo = {
    name: 'sequenceStepper'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("sequenceStepper", sequenceStepper)
  sequenceStepper.prototype = new sequenceStepper_prototype();
  if (typeof(window) != 'undefined') window['sequenceStepper'] = sequenceStepper;
  if (typeof(window) != 'undefined') window['sequenceStepper_prototype'] = sequenceStepper_prototype;
  var commandEngine_prototype = function() {;
    (function(_myTrait_) {
      var _eventOn;
      var _commands;
      _myTrait_.guid = function(t) {

        return Math.random().toString(36).substring(2, 15) +
          Math.random().toString(36).substring(2, 15);

        //return Math.random();
        // return Math.random().toString(36);

        /*    
           return Math.random().toString(36).substring(2, 15) +
                   Math.random().toString(36).substring(2, 15);
           */
        /*        
           function s4() {
               return Math.floor((1 + Math.random()) * 0x10000)
                          .toString(16)
                          .substring(1);
             }
           
           return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                  s4() + '-' + s4() + s4() + s4();*/
      }
      _myTrait_.isArray = function(t) {

        if (typeof(t) == "undefined") return this.__isA;

        return Object.prototype.toString.call(t) === '[object Array]';
      }
      _myTrait_.isFunction = function(fn) {
        return Object.prototype.toString.call(fn) == '[object Function]';
      }
      _myTrait_.isObject = function(t) {

        if (typeof(t) == "undefined") return this.__isO;

        return t === Object(t);
      }
    }(this));;
    (function(_myTrait_) {
      var _instances;
      var _workers;
      var _activeCalls;
      _myTrait_.addEvent = function(objectId, messageId, responseId, data) {
        /*
           
           channel   MSGID    data
           channel   RESPID   data
           
           */

        if (this._workers) {
          if (this._workers[objectId]) {
            var callList = this._workers[objectId][messageId];
            // Then call this list of objects, but should it be sync or async operation?
            var me = this,
              ms = (new Date()).getTime();

            callList.forEach(function(c, i) {
              me._calls.push({
                objId: objectId,
                msgId: messageId,
                options: options,
                callData: data,
                responseId: data,
                time: ms
              });
            });

          }
        }

      }
      _myTrait_.call = function(callObj) {
        /*
           {
               objId : messageId,
               msgId : messageId,
               options     :  options,
               callData   : data,
               time : ms
           }
           */
        this.callCommand(callObj.id, callObj.msg, callObj.data);
      }
      _myTrait_.callCommand = function(objectId, messageId, data) {


        if (this._workers) {
          if (this._workers[objectId]) {
            var callList = this._workers[objectId][messageId];
            // Then call this list of objects, but should it be sync or async operation?
            var me = this,
              ms = (new Date()).getTime();

            callList.forEach(function(c, i) {
              me._calls.push({
                objId: objectId,
                msgId: messageId,
                options: options,
                callData: data,
                time: ms
              });
            });

          }
        }

      }
      _myTrait_.createWorker = function(objectId, messageId, options) {
        // console.log("**** called create workers ****");

        // ARRAY Worker:
        // m._createWorker( dataItem.__id, "*", <arrayWorker>, view, ???? );

        var a = this._workers[objectId];
        if (!a) a = (this._workers[objectId] = {});

        var b = a[messageId];
        if (!b) {
          b = (a[messageId] = []);
        }

        //
        if (options && this.isObject(options) && options.workerFn) {
          b.push(options);
        }

        /*
           
           SENDING MESSAGE FROM - TO MIGHT GO LIKE THIS
           --------------------------------------------
           
           
           // Create the event handler for the channel response with options...
           engine.createWorker( "channel", respid, options);
           
           // Then add the event to the channel using the message ID
           engine.addEvent("channel", msgid, respid, options);
           
           
           */
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {

        if (!this._workers) {
          this._workers = {};
          this._calls = [];
        }
      });
      _myTrait_.processCallList = function(t) {

        // TODO: check the name of the stepper
        var stepper = new sequenceStepper("engine");

        // sending incoming calls to their processors...
        me._calls.forEach(function(call) {

          // adding commands etc.
          stepper.addCommands(function(resolve) {

            // the worker function should get the data...
            call.options.workerFn(call.callData, function(res) {

              // now, you have the result from the worker
              // should you just remove the call from call list and remove the worker??

              if (call.options.responseFn) {
                call.options.responseFn(res);
              }

            }, call);
          });
        });

        /*
           
           var cc = new ChannelConv( <ChannelID> );
           
           
           
           
           
           OR, should you do it like...
           var stepper = new sequenceStepper("?????");
           stepper.addCommands( function(resolve) {
               // do something
           })
           
           
           // -----
           {
              chain : [
                  {}
              ]
           }
                   var stepper = new sequenceStepper("Left");
                   var toDiv = left;
                   var subStep = new sequenceStepper( "LeftSub", true);
                   stepper.addCommands( function(resolveThis, fail) 
           */
        /* {
               objId : objectId,
               msgId : messageId,
               options     :  options,
               callData   : data,
               time : ms
           });
           */
      }
    }(this));
  }
  var commandEngine = function(a, b, c, d, e, f, g, h) {
    if (this instanceof commandEngine) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != commandEngine._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new commandEngine(a, b, c, d, e, f, g, h);
  };
  commandEngine._classInfo = {
    name: 'commandEngine'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("commandEngine", commandEngine)
  commandEngine.prototype = new commandEngine_prototype();
  if (typeof(window) != 'undefined') window['commandEngine'] = commandEngine;
  if (typeof(window) != 'undefined') window['commandEngine_prototype'] = commandEngine_prototype;
  var messageStorage_prototype = function() {;
    (function(_myTrait_) {
      var _eventOn;
      var _commands;
      _myTrait_.guid = function(t) {

        return Math.random().toString(36).substring(2, 15) +
          Math.random().toString(36).substring(2, 15);

        //return Math.random();
        // return Math.random().toString(36);

        /*    
           return Math.random().toString(36).substring(2, 15) +
                   Math.random().toString(36).substring(2, 15);
           */
        /*        
           function s4() {
               return Math.floor((1 + Math.random()) * 0x10000)
                          .toString(16)
                          .substring(1);
             }
           
           return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                  s4() + '-' + s4() + s4() + s4();*/
      }
      _myTrait_.isArray = function(t) {

        if (typeof(t) == "undefined") return this.__isA;

        return Object.prototype.toString.call(t) === '[object Array]';
      }
      _myTrait_.isFunction = function(fn) {
        return Object.prototype.toString.call(fn) == '[object Function]';
      }
      _myTrait_.isObject = function(t) {

        if (typeof(t) == "undefined") return this.__isO;

        return t === Object(t);
      }
    }(this));;
    (function(_myTrait_) {
      var _instances;
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {

      });
    }(this));
  }
  var messageStorage = function(a, b, c, d, e, f, g, h) {
    if (this instanceof messageStorage) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != messageStorage._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new messageStorage(a, b, c, d, e, f, g, h);
  };
  messageStorage._classInfo = {
    name: 'messageStorage'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("messageStorage", messageStorage)
  messageStorage.prototype = new messageStorage_prototype();
  if (typeof(window) != 'undefined') window['messageStorage'] = messageStorage;
  if (typeof(window) != 'undefined') window['messageStorage_prototype'] = messageStorage_prototype;
  var commandStorage_prototype = function() {;
    (function(_myTrait_) {
      var _eventOn;
      var _commands;
      _myTrait_.guid = function(t) {

        return Math.random().toString(36).substring(2, 15) +
          Math.random().toString(36).substring(2, 15);

        //return Math.random();
        // return Math.random().toString(36);

        /*    
           return Math.random().toString(36).substring(2, 15) +
                   Math.random().toString(36).substring(2, 15);
           */
        /*        
           function s4() {
               return Math.floor((1 + Math.random()) * 0x10000)
                          .toString(16)
                          .substring(1);
             }
           
           return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                  s4() + '-' + s4() + s4() + s4();*/
      }
      _myTrait_.isArray = function(t) {

        if (typeof(t) == "undefined") return this.__isA;

        return Object.prototype.toString.call(t) === '[object Array]';
      }
      _myTrait_.isFunction = function(fn) {
        return Object.prototype.toString.call(fn) == '[object Function]';
      }
      _myTrait_.isObject = function(t) {

        if (typeof(t) == "undefined") return this.__isO;

        return t === Object(t);
      }
    }(this));;
    (function(_myTrait_) {
      var _commands;
      _myTrait_.addCommand = function(index, cmdFunction) {
        if (!_commands) {
          _commands = {};
        }
        _commands[index] = cmdFunction;



      }
      _myTrait_.createCommands = function(t) {

        if (!_commands) {
          _commands = {};
        }


      }
      _myTrait_.getCommand = function(index) {
        return _commands ? _commands[index] : null;
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {

      });
    }(this));
  }
  var commandStorage = function(a, b, c, d, e, f, g, h) {
    if (this instanceof commandStorage) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != commandStorage._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new commandStorage(a, b, c, d, e, f, g, h);
  };
  commandStorage._classInfo = {
    name: 'commandStorage'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("commandStorage", commandStorage)
  commandStorage.prototype = new commandStorage_prototype();
  if (typeof(window) != 'undefined') window['commandStorage'] = commandStorage;
  if (typeof(window) != 'undefined') window['commandStorage_prototype'] = commandStorage_prototype;
  var conversation_prototype = function() {;
    (function(_myTrait_) {
      var _eventOn;
      var _commands;
      _myTrait_.guid = function(t) {

        return Math.random().toString(36).substring(2, 15) +
          Math.random().toString(36).substring(2, 15);

        //return Math.random();
        // return Math.random().toString(36);

        /*    
           return Math.random().toString(36).substring(2, 15) +
                   Math.random().toString(36).substring(2, 15);
           */
        /*        
           function s4() {
               return Math.floor((1 + Math.random()) * 0x10000)
                          .toString(16)
                          .substring(1);
             }
           
           return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                  s4() + '-' + s4() + s4() + s4();*/
      }
      _myTrait_.isArray = function(t) {

        if (typeof(t) == "undefined") return this.__isA;

        return Object.prototype.toString.call(t) === '[object Array]';
      }
      _myTrait_.isFunction = function(fn) {
        return Object.prototype.toString.call(fn) == '[object Function]';
      }
      _myTrait_.isObject = function(t) {

        if (typeof(t) == "undefined") return this.__isO;

        return t === Object(t);
      }
    }(this));;
    (function(_myTrait_) {
      var _instances;
      var _workers;
      var _activeCalls;
      _myTrait_.ask = function(qObj) {

        return _promise(function(r) {

          // Do something and after it has been done, then...

          setTimeout(function() {
            r({
              msg: "Hello "
            });
          }, 1000);

        });
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {


        /*

// example of conversation between two remote entries...
// should the "ask" create a promise?

conv.ask( {
       q : "",
    }).then( function(answer, respond) {
       
    })
    .then( function(answer, respond) {
    
    }):
    

*/
      });
    }(this));
  }
  var conversation = function(a, b, c, d, e, f, g, h) {
    if (this instanceof conversation) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != conversation._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new conversation(a, b, c, d, e, f, g, h);
  };
  conversation._classInfo = {
    name: 'conversation'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("conversation", conversation)
  conversation.prototype = new conversation_prototype();
  if (typeof(window) != 'undefined') window['conversation'] = conversation;
  if (typeof(window) != 'undefined') window['conversation_prototype'] = conversation_prototype;
  var _docUp_prototype = function() {;
    (function(_myTrait_) {
      var _eventOn;
      var _commands;
      _myTrait_.addController = function(c) {
        if (!this._controllers)
          this._controllers = [];

        if (this._controllers.indexOf(c) >= 0) return;

        this._controllers.push(c);
      }
      _myTrait_.clone = function(t) {
        return _data(this.serialize());
      }
      _myTrait_.emitValue = function(scope, data) {
        if (this._processingEmit) return this;

        this._processingEmit = true;
        // adding controllers to the data...
        if (this._controllers) {
          var cnt = 0;
          for (var i = 0; i < this._controllers.length; i++) {
            var c = this._controllers[i];
            if (c[scope]) {
              c[scope](data);
              cnt++;
            }
          }
          this._processingEmit = false;
          if (cnt > 0) return this;
        }
        /*
           if(this._controller) {
               if(this._controller[scope]) {
                  this._controller[scope](data);
                  return;
               }
           }
           */

        if (this._valueFn && this._valueFn[scope]) {
          this._valueFn[scope](data);
        } else {
          if (this._parent) {
            if (!this._parent.emitValue) {
              // console.log("Strange... no emit value in ", this._parent);
            } else {
              this._parent.emitValue(scope, data);
            }
          }
        }
        this._processingEmit = false;
      }
      _myTrait_.guid = function(t) {

        return Math.random().toString(36).substring(2, 15) +
          Math.random().toString(36).substring(2, 15);

        //return Math.random();
        // return Math.random().toString(36);

        /*    
           return Math.random().toString(36).substring(2, 15) +
                   Math.random().toString(36).substring(2, 15);
           */
        /*        
           function s4() {
               return Math.floor((1 + Math.random()) * 0x10000)
                          .toString(16)
                          .substring(1);
             }
           
           return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                  s4() + '-' + s4() + s4() + s4();*/
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(data, options, notUsed, notUsed2) {

      });
      _myTrait_.isArray = function(t) {

        if (typeof(t) == "undefined") return this.__isA;

        return Object.prototype.toString.call(t) === '[object Array]';
      }
      _myTrait_.isFunction = function(fn) {
        return Object.prototype.toString.call(fn) == '[object Function]';
      }
      _myTrait_.isObject = function(t) {

        if (typeof(t) == "undefined") return this.__isO;

        return t === Object(t);
      }
    }(this));;
    (function(_myTrait_) {
      var _commands;
      var _objectCache;
      var _cmdIndex;
      var _lastCmdId;
      var _lastCmdVals;
      var _objSetValCmds;
      var _commandListener;
      var _isRemoteUpdate;
      var _hotObjects;
      var _hotSettings;
      var _hotDocs;
      var _incomingDataFn;
      var _listeners;
      var _execInfo;
      var _doingRemote;
      var _localReflections;
      var _channelCommands;
      var _channelForks;
      var _cmdNsMap;
      var _nsReverse;
      var _nsIndex;
      var _nsShortcuts;
      _myTrait_._addChannelFork = function(ID, forkCmd) {

        if (!_channelForks[ID]) {
          _channelForks[ID] = [];
        }
        _channelForks[ID].push(forkCmd);
      }
      _myTrait_._addCommandChannel = function(cmdChannel) {
        /* 
             Object which can send the stuff into some other place, whatever it is...
           */

        if (!this._cmdChannels) this._cmdChannels = [];

        if (this._cmdChannels.indexOf(cmdChannel) >= 0) return this;

        // added a new channel for communication...
        this._cmdChannels.push(cmdChannel);
      }
      _myTrait_._addHotDoc = function(doc) {

        var info = _hotDocs[doc._guid];
        if (!info) {
          _hotDocs[doc._guid] = {
            doc: doc,
            ms: (new Date()).getTime()
          }
        } else {
          info.ms = (new Date()).getTime();
        }
      }
      _myTrait_._addReflection = function(objectId, reflectionId) {

        if (!objectId || !reflectionId || (objectId == reflectionId)) return this;

        if (!_localReflections) _localReflections = {};

        if (!_localReflections[objectId]) _localReflections[objectId] = [];

        if (_localReflections[objectId].indexOf(reflectionId) < 0) {
          _localReflections[objectId].push(reflectionId);
        }
        return this;
      }
      _myTrait_._ask = function(question, data, callBackFn) {
        var rootData = this._data;

        var radio = rootData.__radio;
        var url = rootData.__radioURL;

        if (!data) data = {};

        radio.ask(url, question, callBackFn, data);

      }
      _myTrait_._askSnapshot = function(bUseRawData) {

        var data = this._data;

        var radio = data.__radio;
        var url = data.__radioURL,
          data = this._transformObjFromNs(data);

        radio.snapshot(url, data);

      }
      _myTrait_._broadcastToCmdChannels = function(cmdList) {

        if (this._cmdChannels) {
          //console.log("Channels", this._cmdChannels);
          this._cmdChannels.forEach(function(ch) {
            ch.broadcast(cmdList);
          });
        } else {
          //console.log("**** NO CHANNELS *****");
          //console.log(this);
        }
      }
      _myTrait_._clearCmdCache = function(t) {
        _objectCache = {};
        _commands = [];

      }
      _myTrait_._createHotObject = function(obj) {

        var hot = _hotSettings.index[obj._guid],
          me = this;
        if (!hot) {
          // make it hot...
          hot = {
            t: me._getCmdTime(),
            id: obj._guid,
            o: obj
          }
          obj._hotBuffer = [];
          _hotSettings.index[obj._guid] = hot;
          _hotSettings.list.push(hot);
        } else {
          hot.t = me._getCmdTime();
        }
        return hot;
      }
      _myTrait_._debugMode = function(t) {

        if (typeof(t) == "undefined") {
          return _execInfo.debugmode;
        }
        _execInfo.debugmode = t;
        return this;
      }
      _myTrait_._execCommandsPromise = function(listOfCommands, isRemote, reflection, rootDoc, opts) {

        var first = _promise(),
          myPromise = _promise(),
          me = this;

        var createPromise = function(p, cmd) {
          return p.then(
            function() {
              if (isRemote) {
                return me._realExecCmd(cmd, isRemote, reflection, rootDoc, opts);
              } else {
                return me.execCommand(cmd, isRemote, reflection, rootDoc, opts);
              }
            });
        }
        var len = listOfCommands.length,
          p = first;
        for (var i = 0; i < len; i++) {
          p = createPromise(p, listOfCommands[i]);
        }
        p.then(function() {
          myPromise.resolve(true);
        });
        first.resolve(true);

        return myPromise;
      }
      _myTrait_._findParentWithUrl = function(data) {
        if (!data) return data;
        if (!data.__p) return data;

        if (data.__radioURL) return data;

        var pid = data.__p;
        var p = this._find(pid),
          prevP;
        while (p) {
          if (p.__radioURL) return p;
          prevP = p;
          pid = p.__p;
          p = this._find(pid);
        }
        return prevP;
      }
      _myTrait_._findReflections = function(objId) {

        if (_localReflections) return _localReflections[objId];
      }
      _myTrait_._findRootDoc = function(data) {
        if (!data.__p) return data;

        if (data.__virtual) return data;

        var pid = data.__p;
        var p = this._find(pid);
        if (p) {
          return this._findRootDoc(p);
        }
        return data;
      }
      _myTrait_._getCmdTime = function(t) {
        return _hotSettings.time;
      }
      _myTrait_._getExecInfo = function(t) {
        return _execInfo;
      }
      _myTrait_._getNsFromUrl = function(url) {
        if (_nsShortcuts[url]) {
          return _nsShortcuts[url];
        }
        _nsReverse[_nsIndex] = url;
        _nsShortcuts[url] = _nsIndex++;

        return _nsShortcuts[url];
      }
      _myTrait_._getNsShorthand = function(nsName) {

        if (_nsShortcuts[nsName]) {
          return _nsShortcuts[nsName];
        }
        _nsReverse[_nsIndex] = nsName;
        _nsShortcuts[nsName] = _nsIndex++;

        return _nsShortcuts[nsName];
      }
      _myTrait_._getReflections = function(t) {
        return _localReflections;
      }
      _myTrait_._getReflectionsFor = function(objId) {

        if (_localReflections) {
          var list = _localReflections[objId];
          if (list) return list;
        }
        return [];
      }
      _myTrait_._getReverseNs = function(index) {

        return _nsReverse[index];
      }
      _myTrait_._idFromNs = function(id) {
        if (id) {

          var len = id.length;
          if (id[len - 1] == "#") {
            id = id.split("@").shift();
          }
        }
        return id;
      }
      _myTrait_._idToNs = function(id, ns) {

        if (id) {
          var len = id.length;
          // longString

          if (id[len - 1] == "#") {
            var ind = id.indexOf("@");
            var oldNs = id.substring(ind + 1, len - 1);
            if (oldNs != ns) {
              id = id.substring(0, ind) + "@" + ns + "#";
            }
          } else {
            id = id + "@" + ns + "#";
          }
        }
        return id;
      }
      _myTrait_._localExecCmd = function(a, isRemote, reflection, rootDoc, opts) {

        // IF the command is coming from the local execCommand function then this
        // function is called...

        var me = this;
        var myPromise = _promise();

        if (this.isArray(a[0])) {
          console.error("Array of promises NOT implemented.... ");
          /*
               this._execCommandsPromise(a, isRemote).then( function() {
                    myPromise.resolve(true);
               })
               */
          myPromise.resolve(true);
          return myPromise;
        }
        var ctxName = "local::" + a[0] + "::" + a[4]; // i.e 4::x == set, x 

        // var ctxName = "local::"+a.join();
        if (!me._enterCtx(ctxName, true)) {
          myPromise.resolve(true);
          return myPromise;
        }

        var execStatus = this._getExecInfo();
        var cmdCopy = a.slice();

        if (!reflection) {
          var rObj = this._find(a[4]);
          rootDoc = this._findParentWithUrl(rObj);
        }

        try {

          // FORK of the channel, the command structure is still undefined, what is does have???
          if (a[0] == 88) {
            // Forking the channel is just creating a mark in the stream, should you react to it somehow???
            // send this fork information to the remote channels...
            this._pushChannelCommand(rootDoc.__radioURL, cmdCopy.slice(), ctxName, false, rootDoc.__radio);

            myPromise.resolve(true);
          }

          // Create Object command...
          if (a[0] == 1) {
            var newObj = {
              data: {},
              __id: a[1]
            }
            var hash = this._getObjectHash();
            hash[newObj.__id] = newObj;
            this.writeCommand(a);
            myPromise.resolve(true);
          }

          if (a[0] == 2) {
            var newObj = {
              data: [],
              __id: a[1]
            }
            var hash = this._getObjectHash();
            hash[newObj.__id] = newObj;
            this.writeCommand(a);
            myPromise.resolve(true);
          }

          if (a[0] == 3) {
            myPromise.resolve(true);
          }

          if (a[0] == 4) {

            var obj = this._find(a[4]),
              prop = a[1];

            if (obj) {

              if (!reflection) {
                if (obj.__rid) {
                  // send the command to the reflection object...
                  // console.log("Sending to the real document the reflection "+obj.__rid);
                  a[4] = obj.__rid;
                  me._leaveCtx(ctxName);
                  me._localExecCmd(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }
              }

              if (!a[3]) {
                a[3] = obj.data[prop];
                cmdCopy[3] = obj.data[prop];
              }

              _execInfo.oldValue = obj.data[prop];
              obj.data[prop] = a[2]; // value is now set...
              this._cmd(a, obj, null);

              // local command must be broadcasted to remote listeners
              if (!reflection && !isRemote) {
                //console.log("%c not remote and not reflection", "background:green");
                //console.log("Context here was ", ctxName);
                //console.log("command "+JSON.stringify( cmdCopy ));
                this._pushChannelCommand(rootDoc.__radioURL, cmdCopy.slice(), ctxName, false, rootDoc.__radio);
              }

              if (_listeners) {
                var lName = obj.__id + "::" + prop,
                  eList = _listeners[lName];
                if (eList) {
                  // console.log("**** got", lName);
                  eList.forEach(function(fn) {
                    fn(obj, a[2]);
                  })
                }
              }
              if (!reflection) {
                me._leaveCtx(ctxName);
                me._sendCmdToRefs(cmdCopy, isRemote).then(function() {
                  //console.log("**** ... commands to refs done. **** ");
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                //console.log(".... looks like this was reflection??? ");
                myPromise.resolve(true);
              }
            } else {
              myPromise.resolve(true);
            }
          }

          // There is not the change list coming...
          if (a[0] == 13) {

            var obj = this._find(a[4]),
              prop = a[1];

            if (!reflection) {
              if (obj.__rid) {
                // send the command to the reflection object...
                // the command will then be reflected to all reflected objects...
                //console.log("**** sending ACE update command to the reflected object **** ");
                a[4] = obj.__rid;
                me._leaveCtx(ctxName);
                //console.log(JSON.stringify(a));
                me.execCommand(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              }
            }

            var conv = aceCmdConvert();

            // The string gets updated like this...
            obj.data[prop] = conv.runToString(obj.data[prop], a[2]);

            // ******* this was here but might be moved into the ace editor update ********
            _doingRemote = isRemote || _isRemoteUpdate;

            var tmpCmd = [4, prop, obj.data[prop], null, a[4]];
            this._cmd(tmpCmd, obj, null);

            // But, for the remote stuff, we are going to use this..
            if (!(isRemote || _isRemoteUpdate)) {
              // this.writeCommand(a); 
            } else {
              this._cmd(a, obj, null);
            }

            _doingRemote = false;

            if (!reflection && !isRemote) {
              this._pushChannelCommand(rootDoc.__radioURL, cmdCopy, ctxName, false, rootDoc.__radio);
            }

            if (_listeners) {
              var lName = obj.__id + "::" + prop,
                eList = _listeners[lName];
              if (eList) {
                // console.log("**** got", lName);
                eList.forEach(function(fn) {
                  fn(obj, obj.data[prop]);
                })
              }
            }

            if (!reflection) {
              me._leaveCtx(ctxName);
              me._sendCmdToRefs(a, isRemote).then(function() {
                myPromise.resolve(true);
              });
              return myPromise;
            } else {
              myPromise.resolve(true);
            }



          }

          // Setting the member of ...
          if (a[0] == 5) {

            //console.log("Hash contents");
            //console.log(this._getObjectHash());

            var obj = this._find(a[4]),
              prop = a[1],
              setObj = this._find(a[2]);

            if (!obj || !setObj) {
              me._leaveCtx(ctxName);
              myPromise.resolve(true);
              return;
            }

            // NOTE: there might be some problems with remote objects here too...
            var parentObj = obj;

            if (!reflection) {
              if (parentObj.__rid && (parentObj.__rid != a[4])) {
                // console.log("**** sending INSERT to the reflected object **** ");
                var newCmd = a.slice();
                newCmd[4] = parentObj.__rid;
                me._leaveCtx(ctxName);
                // console.log(JSON.stringify(a));
                me.execCommand(newCmd, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              }
            }

            setObj = this._transformToNsBeforeInsert(setObj, obj);

            obj.data[prop] = setObj; // value is now set...
            setObj.__p = obj.__id; // The parent relationship
            this._cmd(a, obj, setObj);

            // this._moveCmdListToParent(setObj);
            if (!reflection && !isRemote) {
              this._pushCmdListToChannel(setObj, rootDoc, ctxName);
              this._pushChannelCommand(rootDoc.__radioURL, a, ctxName, false, rootDoc.__radio);
            }

            if (!reflection) {
              me._leaveCtx(ctxName);
              me._sendCmdToRefs(a, isRemote).then(function() {
                myPromise.resolve(true);
              });
              return myPromise;
            } else {
              myPromise.resolve(true);
            }
          }


          // Remove the object property....
          if (a[0] == 10) {

            var obj = this._find(a[4]),
              prop = a[1];

            console.log("*** unsetting property ****", prop);

            if (!obj || !prop) {
              me._leaveCtx(ctxName);
              myPromise.resolve(true);
              return;
            }

            // NOTE: there might be some problems with remote objects here too...
            var parentObj = obj;

            if (!reflection) {
              if (obj.__rid) {
                // send the command to the reflection object...
                // console.log("Sending to the real document the reflection "+obj.__rid);
                a[4] = obj.__rid;
                me._leaveCtx(ctxName);
                me._localExecCmd(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              }
            }

            // unsetting a property does not work right now...
            delete obj.data[prop];
            if (setObj) {
              setObj.__oldp = parentObj.__id;
              setObj.__p = null; // The parent relationship
            }
            this._cmd(a, obj, setObj);

            // this._moveCmdListToParent(setObj);
            if (!reflection && !isRemote) {
              // this._pushCmdListToChannel( setObj, rootDoc, ctxName  );
              this._pushChannelCommand(rootDoc.__radioURL, cmdCopy, ctxName, false, rootDoc.__radio);
            }

            if (!reflection) {
              me._leaveCtx(ctxName);
              me._sendCmdToRefs(a, isRemote).then(function() {
                myPromise.resolve(true);
              });
              return myPromise;
            } else {
              myPromise.resolve(true);
            }
          }


          // Insert new object with id...
          // The object should be already created and thus it exists in the
          // object cache of this "domain"
          if (a[0] == 7) {

            var parentObj = this._find(a[4]),
              insertedObj = this._find(a[2]),
              prop = "*",
              index = parentObj.data.length; // might check if valid...

            // Moving the object in the array
            if (parentObj && insertedObj) {

              // console.log(" insert OK ");

              if (!reflection) {
                // usually a plain new object is without _rid, it is usually just object..

                // The insertion of object in cases that there is another __vpid and __vcid

                if (parentObj.__rid && (parentObj.__rid != a[4])) {
                  // console.log("**** sending INSERT to the reflected object **** ");
                  a[4] = parentObj.__rid;
                  me._leaveCtx(ctxName);
                  // console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }
              }

              insertedObj = this._transformToNsBeforeInsert(insertedObj, parentObj);

              // now the object is in the array...
              parentObj.data.push(insertedObj);
              insertedObj.__p = parentObj.__id;
              this._cmd(a, parentObj, insertedObj);

              // Q: should this be having cmd-list to parent??
              // if(!parentObj.__rid) this._moveCmdListToParent(insertedObj);
              // ==> perhaps should be sending the commands here to the channel URL...
              // unless there is __rid.. available

              if (!reflection && !isRemote) {
                // console.log("%c should be pushing the command list to channel", "background:green;");
                this._pushCmdListToChannel(insertedObj, rootDoc, ctxName);
                this._pushChannelCommand(rootDoc.__radioURL, cmdCopy, ctxName, false, rootDoc.__radio);
              }


              if (!reflection) {
                me._leaveCtx(ctxName);
                me._sendCmdToRefs(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                myPromise.resolve(true);
              }


            } else {
              myPromise.resolve(true);
            }

          }



          // Remove object, this might be also NOT from array...???
          if (a[0] == 8) {

            //console.log("%c COMMAND 8 ",  'background: red; color: #bada55');
            //console.log("*** remove item command ");
            //console.log(a);

            // ** skipping this command        
            /*
                   me._leaveCtx(ctxName);
                   myPromise.resolve(true);
                   
                   return myPromise;
           */

            // this.saveCommand("removeItem", i, this._removedItem._guid, null );
            // [8, index, removedid, null, parentid ]
            var parentObj = this._find(a[4]),
              removedItem = this._find(a[2]),
              prop = "*",
              index = parentObj.data.indexOf(removedItem); // might check if valid...

            // Moving the object in the array
            if (parentObj && removedItem) {

              // __radioURL

              var bothReflected = (parentObj.__rid && removedItem.__rid);

              var bSameDomain = true;

              if (removedItem.__vpid && (removedItem.__vpid != removedItem.__pid)) {
                bSameDomain = false;
              }
              // if( removedItem.__radioURL ) bSameDomain = false;



              if (!reflection) {

                if (bSameDomain && (removedItem.__rid && parentObj.__rid)) {
                  //console.log("**** sending remove command to the reflected object **** ");
                  a[4] = parentObj.__rid;
                  a[2] = removedItem.__rid;
                  me._leaveCtx(ctxName);
                  //console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }


                if (!bSameDomain && (removedItem.__rid && parentObj.__rid)) {

                  if (removedItem.__vcid != removedItem.__id) {

                    //console.log("%c --- not doing real delete yet --- ", "background:cyan");
                    //console.log("parent and removed below");
                    //console.log(parentObj);
                    //console.log(removedItem);
                    //console.log("Same domain : ", bSameDomain);
                    //console.log("Both have __rid ", ( removedItem.__rid && parentObj.__rid));

                    a[4] = removedItem.__vpid;
                    a[2] = removedItem.__vcid;

                    // debug code starting here:
                    /*
                                   me._leaveCtx(ctxName);
                                   console.log(JSON.stringify(a));
                                   
                                   myPromise.resolve(true);
                                   return myPromise;                    
                                   
                                   console.log("**** sending remove command to the reflected object **** ");
                                   a[4] = removedItem.__vpid;
                                   a[2] = removedItem.__rid; */

                    me._leaveCtx(ctxName);
                    // console.log(JSON.stringify(a));
                    me.execCommand(a, isRemote).then(function() {
                      myPromise.resolve(true);
                    });
                    return myPromise;
                  }
                }


                /*
                           console.log("*** Was not same domain, exiting...");
                           
                           me._leaveCtx(ctxName);
                           myPromise.resolve(true);
                           
                           return myPromise;  
                           
                           if(removedItem.__rid && parentObj.__pid) {
                                           
                                                 
                               console.log("**** sending remove command to the reflected object **** ");
                               a[4] = removedItem.__vpid || removedItem.__pid;
                               a[2] = removedItem.__rid;
                               me._leaveCtx(ctxName);
                               console.log(JSON.stringify(a));
                               me.execCommand(a, isRemote).then( function() {
                                   myPromise.resolve(true);
                               });
                               return myPromise;
                           }*/
              }

              //console.log("*** was able to find the object to remove ");
              // console.log("The index of the item to be remoed ", index);

              // now the object is in the array...
              parentObj.data.splice(index, 1);

              // Adding extra information to the object about it's removal
              removedItem.__removedAt = index;

              this._cmd(cmdCopy.slice(), parentObj, removedItem);

              if (!reflection && !isRemote) {
                this._pushChannelCommand(rootDoc.__radioURL, cmdCopy, ctxName, false, rootDoc.__radio);
              }

              removedItem.__p = null; // must be set to null...

              if (!reflection) {
                // HERE is a place to think about it...
                me._leaveCtx(ctxName);
                me._sendCmdToRefs(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });

                return myPromise;

              } else {
                myPromise.resolve(true);
              }


            } else {
              myPromise.resolve(true);
            }

          }



          if (a[0] == 12) {
            var obj = this._find(a[4]),
              prop = "*",
              len = obj.data.length,
              targetObj,
              i = 0;

            for (i = 0; i < len; i++) {
              var m = obj.data[i];
              if (m.__id == a[1]) {
                targetObj = m;
                break;
              }
            }

            // Questions here:
            // - should we move command list only on the parent object, not the child
            //  =>  this._moveCmdListToParent(targetObj); could be
            //      this._moveCmdListToParent(obj);
            // That is... where the command is really saved???
            // is the command actually written anywhere???
            //  - where is the writeCommand?
            // 
            // Moving the object in the array
            if (targetObj) {

              var targetIndex = parseInt(a[2]),
                mObj = this._find(a[1]),
                bBothRemote = obj.__rid && mObj.__rid;

              if (!reflection) {
                if (bBothRemote && (obj.__rid != obj.__id)) {


                  //console.log("%c --- not doing real delete yet --- ", "background:cyan");
                  //console.log("parent and removed below");
                  //console.log(mObj);
                  //console.log(this._find(a[4]));
                  //console.log("Same domain : ", bBothRemote);

                  if (mObj.__vpid && (mObj.__vpid != a[4])) {
                    a[4] = mObj.__vpid;
                    a[1] = mObj.__vcid;
                  } else {
                    a[4] = obj.__rid;
                    a[1] = mObj.__rid;
                  }
                  /*
                               me._leaveCtx(ctxName);
                               console.log(JSON.stringify(a));
                               myPromise.resolve(true);
                               return myPromise;           
                       
                       
                               a[4] = removedItem.__vpid;
                               a[2] = removedItem.__vcid;
                       
                               
                               // send the command to the reflection object...
                               // the command will then be reflected to all reflected objects...
                               // console.log("**** sending moveToIndex CMD to the reflected object **** ");
                               
                               if(mObj.__vpid) {
                                   a[4] = mObj.__vpid;
                                   a[1] = mObj.__vcid;                             
                               } else {
                                   a[4] = obj.__rid;
                                   a[1] = mObj.__rid;                        
                               }*/

                  me._leaveCtx(ctxName);
                  // console.log(JSON.stringify(a));
                  // myPromise.resolve(true);

                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }
              }

              //console.log("==== MOVING ==== ", targetObj);
              //console.log(i + "=> "+targetIndex);

              obj.__fromIndex = i;
              targetObj.__fromIndex = i;
              //             _execInfo.fromIndex = i;
              obj.data.splice(i, 1);
              obj.data.splice(targetIndex, 0, targetObj);
              this._cmd(cmdCopy, obj, targetObj);

              if (!reflection && !isRemote) {
                this._pushChannelCommand(rootDoc.__radioURL, cmdCopy, ctxName, false, rootDoc.__radio);
              }

              if (!reflection) {
                me._leaveCtx(ctxName);
                me._sendCmdToRefs(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                myPromise.resolve(true);
              }

            } else {
              myPromise.resolve(true);
            }

          }


          // push a remote object into array
          if (a[0] == 16) {

            // Object to in
            // _changeToRemote
            // [16, <URL>, <ID>, <LocalID>, <ParentObject> ]
            console.log("%c COMMAND 16 ", 'background: #222; color: #bada55');
            console.log(a);


            var objToChange = this._find(a[4]),
              remoteURL = a[1],
              remoteID = a[2],
              localID = a[3],
              parentID = a[4];

            if (objToChange && objToChange.data) {

              if (!reflection) {
                // usually a plain new object is without _rid, it is usually just object..
                if (objToChange.__rid) {
                  a[4] = objToChange.__rid;
                  me._leaveCtx(ctxName);
                  console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }
              }

              if (!reflection && !isRemote) {
                this._pushChannelCommand(rootDoc.__radioURL, cmdCopy, ctxName, false, rootDoc.__radio);
              }
              // reflection ...

              console.log(" - - - about to insert remote object into array - - - ");
              var isRemoteHere = this._find(remoteID),
                isLocalHere = this._find(localID);

              console.log("Checking if the objects are already here...");
              console.log("Remote object ", isRemoteHere);
              console.log("Local object ", isLocalHere);

              var mm = _data();
              console.log("Data find from cache, local ", mm.findFromCache(localID));

              //console.log(" - - - about to insert remote object into array - - - ");   
              //console.log("changeRemote - remoteID ", remoteID);
              //console.log("changeRemote - localID ", localID);
              //console.log("changeRemote - parentID ", parentID);

              var newRawData = {
                data: {},
                __rid: remoteID,
                __id: localID,
                __undone: true
              };
              var newObj;
              /*
                       var newObj = _data({
                               data : {},
                               __id : localID,
                               __rid : remoteID
                           });
                       */
              if (!me._waitingPromises) {
                me._waitingPromises = [];
              }
              me._waitingPromises.push(myPromise);

              // loading the object and inserting into the other reflections is the hardest thing to do here
              // how to make the insertion visible at the other object at real time...
              //newObj.then(
              //    function() {

              //console.log("%c COMMAND 16, did NEW object ",  'background: #222; color: #bada55');
              //console.log( newObj._docData );

              // adding the new object into the data array of the parent object
              // objToChange.data.push( newObj._docData );   
              objToChange.data.push(newRawData);

              newRawData.__radioURL = remoteURL;

              console.log("--- calling change to remote ---- ");

              var loaderPromise = _docUp()._changeToRemote(newRawData, remoteURL, remoteID);
              // it should now have the data...
              loaderPromise.then(function(d) {

                delete newRawData.__undone;

                console.log("The raw data for the object was ");
                console.log(JSON.parse(JSON.stringify(newRawData)));

                //console.log("%c COMMMAND 16 a "+remoteURL+" new object creation, loader promise Returned with ",  'background: #222; color: #bada55');
                //console.log(d);
                //console.log("The object to be changed is now ", newObj);

                var ff = me._find(localID);
                //console.log("From cache it is ", localID);
                //console.log(ff);

                //console.log("%c ---- checking here now... -----", "background : red");
                newRawData.__p = parentID;
                //console.log(JSON.parse(JSON.stringify(newObj._docData)));

                var oldObj = me._find(remoteID);
                //console.log("the old data was ");
                //console.log(oldObj);

                newRawData.__p = parentID;

                if (reflection && opts) {
                  newRawData.__vpid = opts.__vpid;
                  newRawData.__vcid = opts.__vcid;
                } else {
                  newRawData.__vpid = parentID;
                  newRawData.__vcid = localID;
                }
                me._addReflection(newRawData.__vcid, newRawData.__id);

                //console.log("Parent Id  ", parentID);
                //console.log("Local ID ", localID);
                //console.log(JSON.parse(JSON.stringify(newObj._docData)));


                newObj = _data(newRawData);

                newObj.then(
                  function() {

                    // THIS _cmd may be the problem, ????
                    // newObj
                    // objToChange
                    console.log("Did load remote object... the object is ");
                    console.log(newObj);

                    me._cmd([7, objToChange.data.length, localID, null, parentID], objToChange, newObj);
                    if (!reflection) {

                      me._sendCmdToRefs(a, isRemote).then(function() {
                        myPromise.resolve(d);
                      });

                      // myPromise.resolve(d);
                    } else {
                      myPromise.resolve(d);
                    }

                  });


              })
              //});

              // if this is the real document, then write the command down to the stream
              if (!(isRemote || _isRemoteUpdate)) {
                console.log("Writing the command .... ");
                // this.writeCommand(a);
              }
              me._leaveCtx(ctxName);


            } else {
              myPromise.resolve(true);
            }


          }


        } catch (e) {
          console.error(e.message);
          me._leaveCtx(ctxName);
          myPromise.resolve(e.message);
        }

        me._leaveCtx(ctxName);

        return myPromise;

        // this._virtualCommand( a, isRemote || _isRemoteUpdate );

      }
      _myTrait_._moveCmdListToParent = function(obj) {

        //console.log("Moving command list to parent");

        // _moveCmdListToParent
        if (obj.__ctxCmdList) {

          var root = this._findRootDoc(obj);
          if (root == obj) return;

          if (root) {
            if (!root.__ctxCmdList) root.__ctxCmdList = [];

            // Is _ctxCmdList used in anywhere??
            root.__ctxCmdList = root.__ctxCmdList.concat(obj.__ctxCmdList);
            delete obj.__ctxCmdList;
          }

        }

      }
      _myTrait_._nsFromId = function(id) {
        var ns;
        if (id) {
          id = id + "";
          var len = id.length;
          if (id[len - 1] == "#") {
            ns = id.split("@").pop();
            ns = ns.split("#").shift();
          }
        }
        return ns;
      }
      _myTrait_._pushCmdListToChannel = function(list, rootDoc, ctxName) {


        var cmdList;
        if (this.isObject(list) && list.__ctxCmdList) {
          cmdList = list.__ctxCmdList;
          delete list.__ctxCmdList;
        } else {
          cmdList = list;
        }
        var me = this;

        cmdList.forEach(function(c) {
          me._pushChannelCommand(rootDoc.__radioURL, c.cmd, c.ctx, false, rootDoc.__radio);
        });

      }
      _myTrait_._realExecCmd = function(a, isRemote, reflection, rootDoc, opts) {
        var me = this;
        var myPromise = _promise();

        if (this.isArray(a[0])) {
          // console.log("Array of promises.... ");
          this._execCommandsPromise(a, isRemote).then(function() {
            myPromise.resolve(true);
          });
          return myPromise;
        }



        // var ctxName = "realExec::"+a[0]+"::"+a[1]; // i.e 4::x == set, x 
        var ctxName = "realExec::" + a[0] + "::" + a[4];
        // var ctxName = "local::"+a.join();
        if (!me._enterCtx(ctxName)) {
          // console.log("===> could not enter");
          myPromise.resolve(true);
          return myPromise;
        }

        // console.log("*** execCommand ", a);

        // this object holds the status of the execution
        var execStatus = this._getExecInfo();
        var cmdCopy = a.slice();


        try {


          //console.log("Got command, the context is now");
          //console.log(JSON.stringify( me._getCtx() ));

          if (a[0] == 88) {
            // Currently do nothing...
            myPromise.resolve(true);
          }

          // Create Object command...
          if (a[0] == 1) {
            var newObj = {
              data: {},
              __id: a[1]
            }
            var hash = this._getObjectHash();
            // console.log("Hash ", hash);
            hash[newObj.__id] = newObj;
            // this._cmd(a, obj, null);

            // for remote objects we do not save the writeCommands, because the already
            // are coming from the "stream" of object commands
            // this.writeCommand(a);
            myPromise.resolve(true);
          }

          if (a[0] == 2) {
            var newObj = {
              data: [],
              __id: a[1]
            }
            var hash = this._getObjectHash();
            // console.log("Hash ", hash);
            hash[newObj.__id] = newObj;
            // this._cmd(a, obj, null);

            // for remote objects we do not save the writeCommands, because the already
            // are coming from the "stream" of object commands
            // this.writeCommand(a);

            myPromise.resolve(true);
          }

          if (a[0] == 3) {
            myPromise.resolve(true);
          }

          // console.log("Did execute the command");

          // The actual change of the object based on command "a"
          if (a[0] == 4) {

            var obj = this._find(a[4]),
              prop = a[1];

            if (obj) {

              if (!reflection) {
                if (obj.__rid) {
                  // send the command to the reflection object...
                  // the command will then be reflected to all reflected objects...
                  // console.log("**** sending command to the reflected object **** ");
                  a[4] = obj.__rid;
                  me._leaveCtx(ctxName);
                  //console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }
              }
              // console.log("Was asked to update ", prop, "to ", a[2]);

              _execInfo.oldValue = obj.data[prop];
              obj.data[prop] = a[2]; // value is now set...

              this._cmd(a, obj, null);


              if (_listeners) {
                var lName = obj.__id + "::" + prop,
                  eList = _listeners[lName];
                if (eList) {
                  // console.log("**** got", lName);
                  eList.forEach(function(fn) {
                    fn(obj, a[2]);
                  })
                }
              }
              if (!reflection) {
                me._leaveCtx(ctxName);
                // console.log("**** commands to the refs... **** ");
                me._sendCmdToRefs(a, isRemote).then(function() {
                  //console.log("**** ... commands to refs done. **** ");
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                // console.log(".... looks like this was reflection??? ");
                myPromise.resolve(true);
              }
            } else {
              myPromise.resolve(true);
            }
          }

          // There is not the change list coming...
          if (a[0] == 13) {

            // console.log("13 ... ");

            var obj = this._find(a[4]),
              prop = a[1];

            if (!reflection) {
              if (obj.__rid) {
                // send the command to the reflection object...
                // the command will then be reflected to all reflected objects...
                //console.log("**** sending ACE update command to the reflected object **** ");
                a[4] = obj.__rid;
                me._leaveCtx(ctxName);
                //console.log(JSON.stringify(a));
                me.execCommand(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              }
            }

            //console.log(" initializing aceCmdConvert ");

            var conv = aceCmdConvert();

            // The string gets updated like this...
            obj.data[prop] = conv.runToString(obj.data[prop], a[2]);

            //console.log(" did run aceCmdConvert ");

            // ******* this was here but might be moved into the ace editor update ********
            _doingRemote = isRemote || _isRemoteUpdate;

            var tmpCmd = [4, prop, obj.data[prop], null, a[4]];

            //console.log("sending tmp cmd with ace ");

            this._cmd(tmpCmd, obj, null);

            // But, for the remote stuff, we are going to use this..
            if (!(isRemote || _isRemoteUpdate)) {
              // this.writeCommand(a); 
            } else {
              //console.log("sending the REAL cmd for ace ");
              this._cmd(a, obj, null);
            }

            _doingRemote = false;

            // console.log("finished with cmds ");

            if (_listeners) {
              var lName = obj.__id + "::" + prop,
                eList = _listeners[lName];
              if (eList) {
                // console.log("**** got", lName);
                eList.forEach(function(fn) {
                  fn(obj, obj.data[prop]);
                })
              }
            }

            if (!reflection) {
              me._leaveCtx(ctxName);
              me._sendCmdToRefs(a, isRemote).then(function() {
                myPromise.resolve(true);
              });
              return myPromise;
            } else {
              myPromise.resolve(true);
            }



          }

          // Setting the member of ...
          if (a[0] == 5) {

            //console.log("Hash contents");
            //console.log(this._getObjectHash());

            var obj = this._find(a[4]),
              prop = a[1],
              setObj = this._find(a[2]);

            if (!obj) return;
            if (!setObj) return;

            // NOTE: there might be some problems with remote objects here too...
            var parentObj = obj;

            if (!reflection) {
              if (parentObj.__rid && (parentObj.__rid != a[4])) {
                // console.log("**** sending INSERT to the reflected object **** ");
                var newCmd = a.slice();
                newCmd[4] = parentObj.__rid;
                me._leaveCtx(ctxName);
                // console.log(JSON.stringify(a));
                me.execCommand(newCmd, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              }
            }

            obj.data[prop] = setObj; // value is now set...
            setObj.__p = obj.__id; // The parent relationship
            this._cmd(a, obj, setObj);

            // Q: why do we not move the command list to parent here?
            // A: because the commands are already coming from some remote source and they do not
            // need to re-created here
            // this._moveCmdListToParent(setObj);

            if (!reflection) {
              me._leaveCtx(ctxName);
              me._sendCmdToRefs(a, isRemote).then(function() {
                myPromise.resolve(true);
              });
              return myPromise;
            } else {
              myPromise.resolve(true);
            }
          }

          // Remove the object property....
          if (a[0] == 10) {

            var obj = this._find(a[4]),
              prop = a[1];

            if (!obj) return;
            if (!prop) return;


            if (!reflection) {
              if (obj.__rid) {
                // send the command to the reflection object...
                // the command will then be reflected to all reflected objects...
                // console.log("**** sending command to the reflected object **** ");
                a[4] = obj.__rid;
                me._leaveCtx(ctxName);
                //console.log(JSON.stringify(a));
                me.execCommand(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              }
            }

            delete obj.data[prop];
            // Remove object property 
            /*
                   console.log("--- should have deleted property "+ prop);
                   console.log("from object ", obj);
                   setObj.__oldp = parentObj.__id;
                   setObj.__p = null; // The parent relationship
                   this._cmd(a, obj, setObj);*/

            if (!reflection) {
              me._leaveCtx(ctxName);
              me._sendCmdToRefs(a, isRemote).then(function() {
                myPromise.resolve(true);
              });
              return myPromise;
            } else {
              myPromise.resolve(true);
            }
          }



          // Insert new object with id...
          // The object should be already created and thus it exists in the
          // object cache of this "domain"
          if (a[0] == 7) {

            var parentObj = this._find(a[4]),
              insertedObj = this._find(a[2]),
              prop = "*",
              index = parentObj.data.length; // might check if valid...

            // Moving the object in the array
            if (parentObj && insertedObj) {

              // console.log(" insert OK ");

              if (!reflection) {
                // usually a plain new object is without _rid, it is usually just object..
                if (parentObj.__rid) {
                  // console.log("**** sending INSERT to the reflected object **** ");
                  a[4] = parentObj.__rid;
                  me._leaveCtx(ctxName);
                  // console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }
              }

              // now the object is in the array...
              parentObj.data.push(insertedObj);
              insertedObj.__p = parentObj.__id;
              this._cmd(a, parentObj, insertedObj);



              if (!reflection) {
                me._leaveCtx(ctxName);
                me._sendCmdToRefs(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                myPromise.resolve(true);
              }

            } else {
              // console.error("Did not find the object to be inserted at all");
              myPromise.resolve(true);
            }

          }

          // Remove object, this might be also NOT from array...???
          if (a[0] == 8) {

            // this.saveCommand("removeItem", i, this._removedItem._guid, null );
            // [8, index, removedid, null, parentid ]
            var parentObj = this._find(a[4]),
              removedItem = this._find(a[2]),
              prop = "*",
              index = parentObj.data.indexOf(removedItem); // might check if valid...

            // Moving the object in the array
            if (parentObj && removedItem) {

              // __radioURL

              var bothReflected = (parentObj.__rid && removedItem.__rid);

              var bSameDomain = true;

              if (removedItem.__vpid && (removedItem.__vpid != removedItem.__pid)) {
                bSameDomain = false;
              }
              // if( removedItem.__radioURL ) bSameDomain = false;

              if (!reflection) {

                if (bSameDomain && (removedItem.__rid && parentObj.__rid)) {
                  //console.log("**** sending remove command to the reflected object **** ");
                  a[4] = parentObj.__rid;
                  a[2] = removedItem.__rid;
                  me._leaveCtx(ctxName);
                  // console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }


                if (!bSameDomain && (removedItem.__rid && parentObj.__rid)) {
                  if (removedItem.__vcid != removedItem.__id) {
                    //console.log("**** sending remove command to the reflected object **** ");
                    a[4] = removedItem.__vpid;
                    a[2] = removedItem.__vcid;
                    me._leaveCtx(ctxName);
                    //console.log(JSON.stringify(a));
                    me.execCommand(a, isRemote).then(function() {
                      myPromise.resolve(true);
                    });
                    return myPromise;
                  }
                }

              }

              // console.log("*** was able to find the object to remove ");
              // console.log("The index of the item to be remoed ", index);

              // now the object is in the array...
              parentObj.data.splice(index, 1);

              // Adding extra information to the object about it's removal
              removedItem.__removedAt = index;

              //console.log("Removed item");
              //console.log(removedItem);

              // console.log("===> making the _cmd");

              this._cmd(cmdCopy, parentObj, removedItem);
              removedItem.__p = null; // must be set to null...

              // Saving the write to root document
              if (!(bothReflected || isRemote || _isRemoteUpdate)) {
                // this.writeCommand(a);
              }

              if (!reflection) {

                // overriding a[2] is note really needed in normal case...

                me._leaveCtx(ctxName);
                // a[2] = removedItem.__rid; // just making sure that the reflection is used...
                me._sendCmdToRefs(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                myPromise.resolve(true);
              }


            } else {
              console.error("Could not find the removed object");
              myPromise.resolve(true);
            }

          }



          if (a[0] == 12) {
            var obj = this._find(a[4]),
              prop = "*",
              len = obj.data.length,
              targetObj,
              i = 0;

            for (i = 0; i < len; i++) {
              var m = obj.data[i];
              if (m.__id == a[1]) {
                targetObj = m;
                break;
              }
            }

            // Questions here:
            // - should we move command list only on the parent object, not the child
            //  =>  this._moveCmdListToParent(targetObj); could be
            //      this._moveCmdListToParent(obj);
            // That is... where the command is really saved???
            // is the command actually written anywhere???
            //  - where is the writeCommand?
            // 
            // Moving the object in the array
            if (targetObj) {

              var targetIndex = parseInt(a[2]),
                mObj = this._find(a[1]),
                bBothRemote = obj.__rid && mObj.__rid;

              if (!reflection) {
                if (bBothRemote) {
                  // send the command to the reflection object...
                  // the command will then be reflected to all reflected objects...
                  // console.log("**** sending moveToIndex CMD to the reflected object **** ");

                  if (mObj.__vpid) {
                    a[4] = mObj.__vpid;
                    a[1] = mObj.__vcid;
                  } else {
                    a[4] = obj.__rid;
                    a[1] = mObj.__rid;
                  }

                  //a[4] = obj.__rid;
                  //a[1] = mObj.__rid;
                  me._leaveCtx(ctxName);
                  // console.log(JSON.stringify(a));
                  //myPromise.resolve(true);

                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });

                  return myPromise;
                }
              }

              //console.log("==== MOVING ==== ", targetObj);
              //console.log(i + "=> "+targetIndex);

              _execInfo.fromIndex = i;
              obj.__fromIndex = i;
              targetObj.__fromIndex = i;

              obj.data.splice(i, 1);
              obj.data.splice(targetIndex, 0, targetObj);
              this._cmd(cmdCopy, obj, targetObj, {
                fromIndex: i
              });

              if (!(bBothRemote || isRemote || _isRemoteUpdate)) {
                // this.writeCommand(a);
              }

              if (!reflection) {
                me._leaveCtx(ctxName);
                me._sendCmdToRefs(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                myPromise.resolve(true);
              }

            } else {
              // console.error("object with ID "+a[1]+" not found");
              myPromise.resolve(true);
            }

          }



          // push a remote object into array
          if (a[0] == 16) {

            // Object to in
            // _changeToRemote
            // [16, <URL>, <ID>, <LocalID>, <ParentObject> ]
            //console.log("%c COMMAND 16 ",  'background: #222; color: #bada55');
            //console.log(a);


            var objToChange = this._find(a[4]),
              remoteURL = a[1],
              remoteID = a[2],
              localID = a[3],
              parentID = a[4];

            if (objToChange && objToChange.data) {

              // reflection ...

              console.log(" - - - about to insert remote object into array - - - ");

              var isRemoteHere = this._find(remoteID),
                isLocalHere = this._find(localID);

              console.log("Checking if the objects are already here...");
              console.log("Remote object ", isRemoteHere);
              console.log("Local object ", isLocalHere);

              //console.log("changeRemote - remoteID ", remoteID);
              //console.log("changeRemote - localID ", localID);
              //console.log("changeRemote - parentID ", parentID);

              var newRawData = {
                data: {},
                __rid: remoteID,
                __id: localID,
                __undone: true
              };
              var newObj;
              /*
                       var newObj = _data({
                               data : {},
                               __id : localID,
                               __rid : remoteID
                           });
                       */
              if (!me._waitingPromises) {
                me._waitingPromises = [];
              }
              me._waitingPromises.push(myPromise);

              // loading the object and inserting into the other reflections is the hardest thing to do here
              // how to make the insertion visible at the other object at real time...
              //newObj.then(
              //    function() {

              //console.log("%c COMMAND 16, did NEW object ",  'background: #222; color: #bada55');
              //console.log( newObj._docData );

              // adding the new object into the data array of the parent object
              // objToChange.data.push( newObj._docData );   
              objToChange.data.push(newRawData);

              newRawData.__radioURL = remoteURL;

              var loaderPromise = _docUp()._changeToRemote(newRawData, remoteURL, remoteID);
              // it should now have the data...
              loaderPromise.then(function(d) {

                delete newRawData.__undone;
                //console.log("%c COMMMAND 16 a "+remoteURL+" new object creation, loader promise Returned with ",  'background: #222; color: #bada55');
                //console.log(d);
                //console.log("The object to be changed is now ", newObj);

                var ff = me._find(localID);
                //console.log("From cache it is ", localID);
                //console.log(ff);

                //console.log("%c ---- checking here now... -----", "background : red");
                newRawData.__p = parentID;
                //console.log(JSON.parse(JSON.stringify(newObj._docData)));

                var oldObj = me._find(remoteID);
                //console.log("the old data was ");
                //console.log(oldObj);

                newRawData.__p = parentID;

                if (reflection && opts) {
                  newRawData.__vpid = opts.__vpid;
                  newRawData.__vcid = opts.__vcid;
                } else {
                  newRawData.__vpid = parentID;
                  newRawData.__vcid = localID;
                }
                me._addReflection(newRawData.__vcid, newRawData.__id);

                //console.log("Parent Id  ", parentID);
                //console.log("Local ID ", localID);
                //console.log(JSON.parse(JSON.stringify(newObj._docData)));

                console.log("The data before _data()");
                console.log(JSON.parse(JSON.stringify(newRawData)));

                newObj = _data(newRawData);

                newObj.then(
                  function() {

                    // THIS _cmd may be the problem, ????
                    // newObj
                    // objToChange
                    me._cmd([7, objToChange.data.length, localID, null, parentID], objToChange, newObj);
                    if (!reflection) {

                      me._sendCmdToRefs(a, isRemote).then(function() {
                        myPromise.resolve(d);
                      });

                      // myPromise.resolve(d);
                    } else {
                      myPromise.resolve(d);
                    }

                  });


              })
              //});

              // if this is the real document, then write the command down to the stream
              if (!(isRemote || _isRemoteUpdate)) {
                console.log("Writing the command .... ");
                // this.writeCommand(a);
              }
              me._leaveCtx(ctxName);


            }


          }


        } catch (e) {
          console.error(e.message);
          me._leaveCtx(ctxName);
          myPromise.resolve(e.message);
        }

        me._leaveCtx(ctxName);

        return myPromise;

        // this._virtualCommand( a, isRemote || _isRemoteUpdate );

      }
      _myTrait_._removeFromCache = function(obj) {

        if (!obj) {
          var me = this;
          this._forMembers(function(m) {
            if (m) m._removeFromCache();
          });
          this._removeFromCache(this);
        } else {

          if (this.isObject(obj)) {
            var g = obj._guid;
            if (g) {
              console.log("*** removing " + g);
              delete _objectCache[g];
            }
          } else {
            if (obj) {
              console.log("*** removing " + obj);
              delete _objectCache[obj];
            }
          }
        }
      }
      _myTrait_._sendCmdToRefs = function(a, isRemote) {

        // should send command to reflections of the source object

        // _localReflections[objectId] = list of reflections of the object

        var me = this;
        var myPromise = _promise(),
          bWaiting = false;

        // the command is similar but it will be targetted to the virtual instances of the
        // actual object, the problem might be how to keep them in sync - for example if you
        // do create another object under the other object how to inform the other object that
        // this object is now virtual copy etc. but that is perhaps only technical things nothing
        // very difficult in itself??

        // The first test should be quite simple, just setting a value and delegating it.
        if (a[0] == 4) {
          //console.log("***** sending to local reflections **** ");
          //console.log(_localReflections);
          if (_localReflections) {
            var list = _localReflections[a[4]];
            if (list && list.length) {
              _execInfo.reflection = true;
              bWaiting = true;
              var cmdList = [];
              list.forEach(function(objid) {
                a[4] = objid;
                cmdList.push(a.slice());
              });

              me._execCommandsPromise(cmdList, isRemote, true).then(function() {
                // console.log("The 4 command list was processed ");
                _execInfo.reflection = false;
                myPromise.resolve(true);
              });
            }
          }

        }

        if (a[0] == 13) {
          // console.log("***** sending ACE command to local reflections **** ");
          if (_localReflections) {
            var list = _localReflections[a[4]];
            if (list && list.length) {
              /*
                       _execInfo.reflection = true;
                       list.forEach( function(objid) {
                           a[4] = objid; 
                           console.log(JSON.stringify(a));
                           me.execCommand(a, isRemote);
                       });
                       _execInfo.reflection = false;
                       */

              _execInfo.reflection = true;
              bWaiting = true;
              var cmdList = [];
              list.forEach(function(objid) {
                a[4] = objid;
                console.log(JSON.stringify(a));
                cmdList.push(a.slice());
                // me.execCommand(a, isRemote);
              });

              me._execCommandsPromise(cmdList, isRemote, true).then(function() {
                _execInfo.reflection = false;
                myPromise.resolve(true);
              });

            }
          }

        }

        if (a[0] == 7) {
          // console.log("***** sending INSERT OBJECT to local reflections **** ");
          if (_localReflections) {
            var list = _localReflections[a[4]],
              newObjId = a[2];
            // console.log("list length was  ", list.length);
            if (list && list.length) {

              _execInfo.reflection = true;
              bWaiting = true;
              var cmdList = [],
                refProms = [];
              list.forEach(function(objid) {
                var newObj = me._find(newObjId);

                var myCmd = a.slice();
                myCmd[4] = objid;

                // create a reflection of the new object...
                var refProm = me._createReflection(newObj);
                // var refObj = me._createReflection( newObj );
                refProm.then(function(refObj) {
                  myCmd[2] = refObj.__id;
                  console.log(myCmd);
                  cmdList.push(myCmd);
                });
                refProms.push(refProm);
              });

              if (refProms.length) {
                var s = _promise();
                s.all(refProms).then(function() {
                  me._execCommandsPromise(cmdList, isRemote, true).then(function() {
                    _execInfo.reflection = false;
                    myPromise.resolve(true);
                  });
                });
                s.resolve(true);
              } else {
                myPromise.resolve(true);
              }
            }
          }
        }

        if ((a[0] == 5) || (a[0] == 10)) {
          // console.log("***** sending INSERT OBJECT to local reflections **** ");
          if (_localReflections) {
            var list = _localReflections[a[4]],
              newObjId = a[2];
            // console.log("list length was  ", list.length);
            if (list && list.length) {

              _execInfo.reflection = true;
              bWaiting = true;
              var cmdList = [],
                refProms = [];
              list.forEach(function(objid) {
                var newObj = me._find(newObjId);

                var myCmd = a.slice();
                myCmd[4] = objid;

                // create a reflection of the new object...
                var refProm = me._createReflection(newObj);
                // var refObj = me._createReflection( newObj );
                refProm.then(function(refObj) {
                  myCmd[2] = refObj.__id;
                  console.log(myCmd);
                  cmdList.push(myCmd);
                });
                refProms.push(refProm);
              });

              if (refProms.length) {
                var s = _promise();
                s.all(refProms).then(function() {
                  me._execCommandsPromise(cmdList, isRemote, true).then(function() {
                    _execInfo.reflection = false;
                    myPromise.resolve(true);
                  });
                });
                s.resolve(true);
              } else {
                myPromise.resolve(true);
              }
            }
          }
        }


        if (a[0] == 16) {
          // console.log("***** sending INSERT REMOTE OBJECT to local reflections **** ");
          if (_localReflections) {
            var list = _localReflections[a[4]];
            if (list && list.length) {
              /*
                       _execInfo.reflection = true;
                       list.forEach( function(objid) {
                           a[4] = objid; 
                           console.log(JSON.stringify(a));
                           me.execCommand(a, isRemote);                
                       });
                       _execInfo.reflection = false;
                       */
              _execInfo.reflection = true;

              // The real thingie might be here...

              var opts = {
                __vcid: a[3],
                __vpid: a[4]
              };
              //_execInfo.__vcid = a[3];
              //_execInfo.__vpid = a[4];

              bWaiting = true;
              var cmdList = [];
              list.forEach(function(objid) {
                a[4] = objid;
                a[3] = me.guid();
                console.log(JSON.stringify(a));
                cmdList.push(a.slice());
                // me.execCommand(a, isRemote);
              });

              me._execCommandsPromise(cmdList, isRemote, true, null, opts).then(function() {
                _execInfo.reflection = false;
                myPromise.resolve(true);
              });
            }
          }

        }

        if (a[0] == 8) {
          // console.log("***** sending REMOVE local reflections **** ");
          if (_localReflections) {
            // [8,0,"sxq58un8z1tt9e4e1hoeac7toi",null,"anll5dkp95cxfdn9dq9b0s3zhn"]
            /*
                   var list = _localReflections[a[4]];
                   if(list) {
                       _execInfo.reflection = true;
                       list.forEach( function(objid) {
                           a[4] = objid; 
                           var childRefs = _localReflections[a[2]];
                           
                           childRefs.forEach( function(chid) {
                               var theObj = me._find(chid);
                               if(theObj && theObj.__p == objid) {
                                   a[2] = chid;
                                   console.log(JSON.stringify(a));
                                   me.execCommand(a, isRemote);
                               }                    
                           });
                           
           
                       });
                       _execInfo.reflection = false;
                   }
                   */
            // console.log(a);
            var list = _localReflections[a[2]];
            // console.log(list);
            if (list && list.length) {
              /*
                       _execInfo.reflection = true;
                       list.forEach( function(objid) {
                           a[2] = objid; 
                           var theObj = me._find(objid);
                           if(theObj && theObj.__p) {
                               a[4] = theObj.__p;
                               console.log(JSON.stringify(a));
                               me.execCommand(a, isRemote);
                           }
                       });
                       _execInfo.reflection = false;
                       */
              _execInfo.reflection = true;
              bWaiting = true;
              var cmdList = [];
              list.forEach(function(objid) {
                a[2] = objid;
                var theObj = me._find(objid);
                if (theObj && theObj.__p) {
                  a[4] = theObj.__p;
                  // console.log(JSON.stringify(a));
                  cmdList.push(a.slice());
                }
              });

              me._execCommandsPromise(cmdList, isRemote, true).then(function() {
                _execInfo.reflection = false;
                myPromise.resolve(true);
              });

            }



          }

        }

        // move command reflection
        if (a[0] == 12) {
          // console.log("***** sending moveToIndex for local reflections **** ");
          if (_localReflections) {
            var list = _localReflections[a[1]];
            if (list && list.length) {
              /*
                       _execInfo.reflection = true;
                       list.forEach( function(objid) {
                           a[1] = objid; 
                           var theObj = me._find(objid);
                           if(theObj && theObj.__p) {
                               a[4] = theObj.__p;
                               console.log(JSON.stringify(a));
                               me.execCommand(a, isRemote);
                           }
                       });
                       _execInfo.reflection = false;*/

              _execInfo.reflection = true;
              bWaiting = true;
              var cmdList = [];
              list.forEach(function(objid) {
                a[1] = objid;
                var theObj = me._find(objid);
                if (theObj && theObj.__p) {
                  a[4] = theObj.__p;
                  // console.log(JSON.stringify(a));
                  cmdList.push(a.slice());
                }
              });

              me._execCommandsPromise(cmdList, isRemote, true).then(function() {
                _execInfo.reflection = false;
                myPromise.resolve(true);
              });


            }
          }

        }

        if (!bWaiting) myPromise.resolve(true);

        return myPromise;


      }
      _myTrait_._sendToInListeners = function(data) {

        if (_incomingDataFn) {
          _incomingDataFn.forEach(function(fn) {
            fn(data);
          });
        }
      }
      _myTrait_._setCmdRemoteUpdate = function(v) {
        _isRemoteUpdate = v;
      }
      _myTrait_._transformCmdFromNs = function(cmd, ns) {
        var map = _cmdNsMap,
          nextCmd = cmd.slice(),
          swap = map[cmd[0]],
          me = this;
        if (swap) {
          swap.forEach(function(index) {
            nextCmd[index] = me._idFromNs(nextCmd[index], ns);
          });
        }
        return nextCmd;
      }
      _myTrait_._transformCmdToNs = function(cmd, ns) {


        var map = _cmdNsMap,
          nextCmd = cmd.slice(),
          swap = map[cmd[0]],
          me = this;
        if (swap) {
          //console.log("Swap", swap);
          swap.forEach(function(index) {
            nextCmd[index] = me._idToNs(nextCmd[index], ns);
          });
        } else {
          //console.log("Did not have swap");
          //console.log(map);
        }
        return nextCmd;

      }
      _myTrait_._transformObjFromNs = function(obj, ns) {
        if (obj && obj.__id) {
          obj.__id = this._idFromNs(obj.__id, ns);
          for (var n in obj.data) {
            if (obj.data.hasOwnProperty(n)) {
              if (this.isObject(obj.data[n])) this._transformObjFromNs(obj.data[n], ns);
            }
          }
        }
        return obj;

      }
      _myTrait_._transformObjToNs = function(obj, ns) {

        if (obj && obj.__id) {

          var nsNext;
          if (obj.__radioURL) {
            var nsNext = this._getNsShorthand(obj.__radioURL);
          }

          if (!obj.__rid) {
            ns = nsNext || ns;
          }

          obj.__id = this._idToNs(obj.__id, ns);
          for (var n in obj.data) {
            if (obj.data.hasOwnProperty(n)) {
              if (this.isObject(obj.data[n])) this._transformObjToNs(obj.data[n], nsNext || ns);
            }
          }
        }

        return obj;


      }
      _myTrait_._transformToNsBeforeInsert = function(obj, parentObj, parentObj2) {

        // OK, so...

        var cmdList = obj.__ctxCmdList;
        var ns = this._nsFromId(parentObj.__id);

        console.log(" _transformToNsBeforeInsert ");

        var me = this;
        if (ns) {
          console.log("Using namespace " + ns);
          cmdList.forEach(function(c) {
            c.cmd = me._transformCmdToNs(c.cmd, ns);
          });
          obj = me._transformObjToNs(obj, ns);
          obj.__ctxCmdList = cmdList;
          this._addToCache(obj);
          return obj;
        }
        // this._addToCache( obj );
        return obj;



      }
      _myTrait_.addCommandListener = function(fn) {

        _commandListener = fn;
      }
      _myTrait_.addListener = function(path, fn) {

        if (!_listeners) _listeners = {};

        // For example items/0.x listens to first items .x variable jne.

        var parts = path.split(".");

        var pathPart = parts[0],
          mPart;
        if (parts.length > 1) {
          mPart = parts[1];
        }

        var obj = this.fetch(pathPart);

        if (obj && mPart) {
          // The object does exist
          var name = obj.__id + "::" + mPart;
          if (!_listeners[name]) _listeners[name] = [];
          _listeners[name].push(fn);
        } else {
          //console.error("Did not find ", path);
          //console.log(parts);
        }
      }
      _myTrait_.addToCache = function(obj) {

        if (!_objectCache) _objectCache = {};

        if (obj._guid) {
          _objectCache[obj._guid] = obj;
        }
      }
      _myTrait_.compressCmdBuffer = function(cmdList) {

        console.log(JSON.stringify(cmdList));

        // this simple code should compress the cmdBuffer
        var len = cmdList.length,
          setProps = {};

        for (var i = len - 1; i >= 0; i--) {
          var c = cmdList[i];
          // eliminate only set properties
          if (c[0] == 4) {
            var pName = c[1];
            if (!setProps[pName]) {
              setProps[pName] = true;
            } else {
              // should remove this line from the array...
              cmdList.splice(i, 1);
            }
          }
        }
        return cmdList;

      }
      _myTrait_.execCommand = function(a, isRemote, reflection, rootDoc, opts) {

        // The new version of the execCommand could be something like this;
        if (1) {

          // console.log("Exec cmd ", a);

          var obj = this._find(a[4]),
            url,
            cmd = a[0];
          var cmdCopy = a.slice();
          var rootDoc = this._findParentWithUrl(obj);
          var ctxName = "::" + a[0] + "::" + a[1];

          // console.log("Root doc", rootDoc);

          if (rootDoc && rootDoc.__radioURL) {
            url = rootDoc.__radioURL;
          }
          // Then, you have to push the command to the URL of the channel this command really belongs
          // to or no radio / url at all... ???????

          // IF url THEN push the command to the channel 

          // IF there is URL then push this command to the channel
          if (url) {
            // console.log("%c push Channel Command COMMAND "+cmd+" ctx : "+ctxName,  'background: orange; color: #bada55');

            // ** insert object may generate multiple commands here...
            var localP = this._localExecCmd(a, isRemote, reflection, rootDoc, opts);

            // This might be done from the _localExecCmd
            // this._pushChannelCommand( url, a, ctxName, false, rootDoc.__radio );

            return localP;
          } else {
            // ELSE standard write command to command buffer and create change for the
            // object according to the command
            // NOTE: should be the easiest case of all..

            // console.log("%c LOCAL COMMAND "+cmd+" ",  'background: blue; color: #bada55');
            var myPromise = _promise();

            // Create Object command...
            if (a[0] == 1) {
              // console.log("Staring to create the new object");
              var newObj = {
                data: {},
                __id: a[1]
              };
              this._addToCache(newObj);
              this.writeCommand(a);
              console.log("DID create the new object");
            }

            // Create Array command...
            if (a[0] == 2) {
              var newObj = {
                data: [],
                __id: a[1]
              };
              this._addToCache(newObj);
              this.writeCommand(a);
            }

            // console.log("Did execute the command");

            // The actual change of the object based on command "a"
            if (a[0] == 4) {

              var prop = a[1];

              if (obj) {

                // the exec info "oldValue" is only for the _cmd() function                
                _execInfo.oldValue = obj.data[prop];
                obj.data[prop] = a[2]; // value is now set...
                this._cmd(a, obj, null);
                this.writeCommand(a);
                if (_listeners) {
                  var lName = obj.__id + "::" + prop,
                    eList = _listeners[lName];
                  if (eList) {
                    // console.log("**** got", lName);
                    eList.forEach(function(fn) {
                      fn(obj, a[2]);
                    })
                  }
                }
              }
            }

            // There is not the change list coming...
            if (a[0] == 13) {

              var prop = a[1],
                conv = aceCmdConvert();

              // The string gets updated like this...
              obj.data[prop] = conv.runToString(obj.data[prop], a[2]);

              // always "not remote"
              _doingRemote = false;

              // for local entries, a "set" event is delegated, in case some objects are
              // listening for the SET
              var tmpCmd = [4, prop, obj.data[prop], null, a[4]];
              this._cmd(tmpCmd, obj, null);

              // But, for the writes, the ACE write is used
              this.writeCommand(a);

              if (_listeners) {
                var lName = obj.__id + "::" + prop,
                  eList = _listeners[lName];
                if (eList) {
                  // console.log("**** got", lName);
                  eList.forEach(function(fn) {
                    fn(obj, obj.data[prop]);
                  })
                }
              }
            }

            // Setting the member of ...
            if (a[0] == 5) {

              var prop = a[1],
                setObj = this._find(a[2]);

              if (!obj) return;
              if (!setObj) return;

              obj.data[prop] = setObj; // value is now set...
              setObj.__p = obj.__id; // The parent relationship
              this._cmd(a, obj, setObj);
              this._moveCmdListToParent(setObj);
              this.writeCommand(a);

            }


            // Insert new object with id...
            // The object should be already created and thus it exists in the
            // object cache of this "domain"
            if (a[0] == 7) {

              var parentObj = this._find(a[4]),
                insertedObj = this._find(a[2]),
                prop = "*",
                index = parentObj.data.length; // might check if valid...

              // Moving the object in the array
              if (parentObj && insertedObj) {

                // now the object is in the array...
                parentObj.data.push(insertedObj);
                insertedObj.__p = parentObj.__id;
                this._cmd(a, parentObj, insertedObj);

                this._moveCmdListToParent(insertedObj);
                this.writeCommand(a);
              }
            }

            // Remove object, this might be also NOT from array...???
            if (a[0] == 8) {

              var parentObj = this._find(a[4]),
                removedItem = this._find(a[2]),
                prop = "*",
                index = parentObj.data.indexOf(removedItem); // might check if valid...

              // Moving the object in the array
              if (parentObj && removedItem) {

                // now the object is in the array...
                parentObj.data.splice(index, 1);

                // Adding extra information to the object about it's removal
                removedItem.__removedAt = index;



                this._cmd(a, parentObj, removedItem);
                removedItem.__p = null; // must be set to null...
                this.writeCommand(cmdCopy);

              }

            }


            // Remove the object property....
            if (a[0] == 10) {

              var obj = this._find(a[4]),
                prop = a[1];
              console.log("*** unsetting property ****", prop);
              if (obj && prop) {
                // unsetting a property does not work right now...
                delete obj.data[prop];
                this.writeCommand(a);
              }
            }


            if (a[0] == 12) {
              var obj = this._find(a[4]),
                prop = "*",
                len = obj.data.length,
                targetObj,
                i = 0;

              for (i = 0; i < len; i++) {
                var m = obj.data[i];
                if (m.__id == a[1]) {
                  targetObj = m;
                  break;
                }
              }

              // Questions here:
              // - should we move command list only on the parent object, not the child
              //  =>  this._moveCmdListToParent(targetObj); could be
              //      this._moveCmdListToParent(obj);
              // That is... where the command is really saved???
              // is the command actually written anywhere???
              //  - where is the writeCommand?
              // 
              // Moving the object in the array
              if (targetObj) {

                var targetIndex = parseInt(a[2]),
                  mObj = this._find(a[1]);

                _execInfo.fromIndex = i;
                obj.__fromIndex = i;
                targetObj.__fromIndex = i;

                obj.data.splice(i, 1);
                obj.data.splice(targetIndex, 0, targetObj);
                this._cmd(a, obj, targetObj);
                this.writeCommand(cmdCopy);
              }

            }

            // Create a remote object...
            if (a[0] == 16) {

              var objToChange = this._find(a[4]),
                remoteURL = a[1],
                remoteID = a[2],
                localID = a[3],
                parentID = a[4];

              if (objToChange && objToChange.data) {

                var myPromise = _promise();
                var newObj = _data({
                  data: {},
                  __id: localID,
                  __rid: remoteID
                });

                if (!me._waitingPromises) {
                  me._waitingPromises = [];
                }
                me._waitingPromises.push(myPromise);
                me._enterCtx(ctxName);
                newObj.then(
                  function() {
                    // adding the new object into the data array of the parent object
                    objToChange.data.push(newObj._docData);
                    newObj._docData.__radioURL = remoteURL;
                    delete newObj._docData.__ctxCmdList;
                    delete newObj._docData.__cmdList;

                    var loaderPromise = _docUp()._changeToRemote(newObj._docData, remoteURL, remoteID);
                    // it should now have the data...
                    loaderPromise.then(function(d) {
                      var ff = me._find(localID);
                      newObj._docData.__p = parentID;
                      newObj._docData.__vpid = parentID;
                      newObj._initializeData(newObj._docData); // make sure functions do exist
                      var updateObj = _data(localID);
                      updateObj.then(
                        function() {
                          me._cmd([7, objToChange.data.length, localID, null, parentID], objToChange, updateObj);
                          if (!reflection) {
                            me._sendCmdToRefs(a, isRemote).then(function() {
                              myPromise.resolve(d);
                            });
                          } else {
                            myPromise.resolve(d);
                          }

                        });


                    })
                  });

                this.writeCommand(a);
                me._leaveCtx(ctxName);


              } else {
                myPromise.resolve(true);
              }


            } else {
              myPromise.resolve(true);
            }

            return myPromise;
          }
          // after retrun myPromise


        }
        return;

        // perhaps the execCommand is no longer a "remote" call in any case...
        /*
               var url = this._findRadioURL();
               me._pushChannelCommand( url, cmd, {}, true );
           */

        var me = this;
        var myPromise = _promise();

        if (this.isArray(a[0])) {
          console.log("Array of promises.... ");
          this._execCommandsPromise(a, isRemote).then(function() {
            myPromise.resolve(true);
          });
          return myPromise;
        }



        var ctxName = "::" + a[0] + "::" + a[1]; // i.e 4::x == set, x 
        if (!me._enterCtx(ctxName)) {
          console.log("===> could not enter");
          myPromise.resolve(true);
          return myPromise;
        }

        console.log("*** execCommand ", a);

        // this object holds the status of the execution
        var execStatus = this._getExecInfo();



        try {


          //console.log("Got command, the context is now");
          //console.log(JSON.stringify( me._getCtx() ));



          // Create Object command...
          if (a[0] == 1) {
            var newObj = {
              data: {},
              __id: a[1]
            }
            var hash = this._getObjectHash();
            // console.log("Hash ", hash);
            hash[newObj.__id] = newObj;
            // this._cmd(a, obj, null);

            // Saving the write to root document
            if (!(isRemote || _isRemoteUpdate)) {
              this.writeCommand(a);
            }

            myPromise.resolve(true);
          }

          if (a[0] == 2) {
            var newObj = {
              data: [],
              __id: a[1]
            }
            var hash = this._getObjectHash();
            // console.log("Hash ", hash);
            hash[newObj.__id] = newObj;
            // this._cmd(a, obj, null);

            // Saving the write to root document
            if (!(isRemote || _isRemoteUpdate)) {
              this.writeCommand(a);
            }
            myPromise.resolve(true);
          }

          // console.log("Did execute the command");

          // The actual change of the object based on command "a"
          if (a[0] == 4) {

            var obj = this._find(a[4]),
              prop = a[1];

            if (obj) {

              if (!reflection) {
                if (obj.__rid) {
                  // send the command to the reflection object...
                  // the command will then be reflected to all reflected objects...
                  console.log("**** sending command to the reflected object **** ");
                  a[4] = obj.__rid;
                  me._leaveCtx(ctxName);
                  //console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }
              }
              // console.log("Was asked to update ", prop, "to ", a[2]);

              _execInfo.oldValue = obj.data[prop];
              obj.data[prop] = a[2]; // value is now set...

              this._cmd(a, obj, null);

              // Saving the write to root document
              if (!obj.__rid && !(isRemote || _isRemoteUpdate)) {
                this.writeCommand(a);
              } else {
                // console.log("*remote cmd*");
              }

              if (_listeners) {
                var lName = obj.__id + "::" + prop,
                  eList = _listeners[lName];
                if (eList) {
                  // console.log("**** got", lName);
                  eList.forEach(function(fn) {
                    fn(obj, a[2]);
                  })
                }
              }
              if (!reflection) {
                me._leaveCtx(ctxName);
                console.log("**** commands to the refs... **** ");
                me._sendCmdToRefs(a, isRemote).then(function() {
                  console.log("**** ... commands to refs done. **** ");
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                console.log(".... looks like this was reflection??? ");
                myPromise.resolve(true);
              }
            } else {
              myPromise.resolve(true);
            }
          }

          // There is not the change list coming...
          if (a[0] == 13) {

            var obj = this._find(a[4]),
              prop = a[1];

            if (!reflection) {
              if (obj.__rid) {
                // send the command to the reflection object...
                // the command will then be reflected to all reflected objects...
                console.log("**** sending ACE update command to the reflected object **** ");
                a[4] = obj.__rid;
                me._leaveCtx(ctxName);
                console.log(JSON.stringify(a));
                me.execCommand(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              }
            }

            var conv = aceCmdConvert();

            // The string gets updated like this...
            obj.data[prop] = conv.runToString(obj.data[prop], a[2]);

            // ******* this was here but might be moved into the ace editor update ********
            _doingRemote = isRemote || _isRemoteUpdate;

            var tmpCmd = [4, prop, obj.data[prop], null, a[4]];
            this._cmd(tmpCmd, obj, null);

            // But, for the remote stuff, we are going to use this..
            if (!(isRemote || _isRemoteUpdate)) {
              this.writeCommand(a);
            } else {
              this._cmd(a, obj, null);
            }

            _doingRemote = false;

            if (_listeners) {
              var lName = obj.__id + "::" + prop,
                eList = _listeners[lName];
              if (eList) {
                // console.log("**** got", lName);
                eList.forEach(function(fn) {
                  fn(obj, obj.data[prop]);
                })
              }
            }

            if (!reflection) {
              me._leaveCtx(ctxName);
              me._sendCmdToRefs(a, isRemote).then(function() {
                myPromise.resolve(true);
              });
              return myPromise;
            } else {
              myPromise.resolve(true);
            }



          }

          // Setting the member of ...
          if (a[0] == 5) {

            //console.log("Hash contents");
            //console.log(this._getObjectHash());

            var obj = this._find(a[4]),
              prop = a[1];
            setObj = this._find(a[2]);


            if (!obj) return;
            if (!setObj) return;

            obj.data[prop] = setObj; // value is now set...
            setObj.__p = obj.__id; // The parent relationship
            this._cmd(a, obj, setObj);

            this._moveCmdListToParent(setObj);

            // Saving the write to root document
            if (!(isRemote || _isRemoteUpdate)) {
              this.writeCommand(a);
            } else {

            }
            myPromise.resolve(true);
          }


          // Insert new object with id...
          // The object should be already created and thus it exists in the
          // object cache of this "domain"
          if (a[0] == 7) {

            var parentObj = this._find(a[4]),
              insertedObj = this._find(a[2]),
              prop = "*",
              index = parentObj.data.length; // might check if valid...

            // Moving the object in the array
            if (parentObj && insertedObj) {

              console.log(" insert OK ");

              if (!reflection) {
                // usually a plain new object is without _rid, it is usually just object..
                if (parentObj.__rid) {
                  console.log("**** sending INSERT to the reflected object **** ");
                  a[4] = parentObj.__rid;
                  me._leaveCtx(ctxName);
                  console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }
              }

              // now the object is in the array...
              parentObj.data.push(insertedObj);
              insertedObj.__p = parentObj.__id;
              this._cmd(a, parentObj, insertedObj);

              if (!parentObj.__rid) this._moveCmdListToParent(insertedObj);

              if (parentObj.__rid) {
                console.log("Can not write command, because parent object has __rid");
              }

              // Saving the write to root document
              if (!(parentObj.__rid || isRemote || _isRemoteUpdate)) {
                console.log(" creating write ");
                this.writeCommand(a);
              }

              if (!reflection) {
                me._leaveCtx(ctxName);
                me._sendCmdToRefs(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                myPromise.resolve(true);
              }


            }

          }

          // Remove object, this might be also NOT from array...???
          if (a[0] == 8) {

            console.log("%c COMMAND 8 ", 'background: red; color: #bada55');
            console.log("*** remove item command ");
            console.log(a);

            // ** skipping this command        
            /*
                   me._leaveCtx(ctxName);
                   myPromise.resolve(true);
                   
                   return myPromise;
           */

            // this.saveCommand("removeItem", i, this._removedItem._guid, null );
            // [8, index, removedid, null, parentid ]
            var parentObj = this._find(a[4]),
              removedItem = this._find(a[2]),
              prop = "*",
              index = parentObj.data.indexOf(removedItem); // might check if valid...

            // Moving the object in the array
            if (parentObj && removedItem) {

              // __radioURL

              var bothReflected = (parentObj.__rid && removedItem.__rid);

              var bSameDomain = true;

              if (removedItem.__vpid && (removedItem.__vpid != removedItem.__pid)) {
                bSameDomain = false;
              }
              // if( removedItem.__radioURL ) bSameDomain = false;

              if (!reflection) {

                if (bSameDomain && (removedItem.__rid && parentObj.__rid)) {
                  console.log("**** sending remove command to the reflected object **** ");
                  a[4] = parentObj.__rid;
                  a[2] = removedItem.__rid;
                  me._leaveCtx(ctxName);
                  console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }


                if (!bSameDomain && (removedItem.__rid && parentObj.__rid)) {
                  console.log("**** sending remove command to the reflected object **** ");
                  a[4] = removedItem.__vpid;
                  a[2] = removedItem.__rid;
                  me._leaveCtx(ctxName);
                  console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }


                /*
                           console.log("*** Was not same domain, exiting...");
                           
                           me._leaveCtx(ctxName);
                           myPromise.resolve(true);
                           
                           return myPromise;  
                           
                           if(removedItem.__rid && parentObj.__pid) {
                                           
                                                 
                               console.log("**** sending remove command to the reflected object **** ");
                               a[4] = removedItem.__vpid || removedItem.__pid;
                               a[2] = removedItem.__rid;
                               me._leaveCtx(ctxName);
                               console.log(JSON.stringify(a));
                               me.execCommand(a, isRemote).then( function() {
                                   myPromise.resolve(true);
                               });
                               return myPromise;
                           }*/
              }

              console.log("*** was able to find the object to remove ");
              // console.log("The index of the item to be remoed ", index);

              // now the object is in the array...
              parentObj.data.splice(index, 1);

              // Adding extra information to the object about it's removal
              removedItem.__removedAt = index;

              //console.log("Removed item");
              //console.log(removedItem);

              // console.log("===> making the _cmd");

              this._cmd(a, parentObj, removedItem);
              removedItem.__p = null; // must be set to null...

              // Saving the write to root document
              if (!(bothReflected || isRemote || _isRemoteUpdate)) {
                this.writeCommand(a);
              }

              if (!reflection) {
                me._leaveCtx(ctxName);
                // a[2] = removedItem.__rid; // just making sure that the reflection is used...
                me._sendCmdToRefs(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                myPromise.resolve(true);
              }


            }

          }



          if (a[0] == 12) {
            var obj = this._find(a[4]),
              prop = "*",
              len = obj.data.length,
              targetObj,
              i = 0;

            for (i = 0; i < len; i++) {
              var m = obj.data[i];
              if (m.__id == a[1]) {
                targetObj = m;
                break;
              }
            }

            // Questions here:
            // - should we move command list only on the parent object, not the child
            //  =>  this._moveCmdListToParent(targetObj); could be
            //      this._moveCmdListToParent(obj);
            // That is... where the command is really saved???
            // is the command actually written anywhere???
            //  - where is the writeCommand?
            // 
            // Moving the object in the array
            if (targetObj) {

              var targetIndex = parseInt(a[2]),
                mObj = this._find(a[1]),
                bBothRemote = obj.__rid && mObj.__rid;

              if (!reflection) {
                if (bBothRemote) {
                  // send the command to the reflection object...
                  // the command will then be reflected to all reflected objects...
                  console.log("**** sending moveToIndex CMD to the reflected object **** ");
                  a[4] = obj.__rid;
                  a[1] = mObj.__rid;
                  me._leaveCtx(ctxName);
                  console.log(JSON.stringify(a));
                  myPromise.resolve(true);
                  /*
                               me.execCommand(a, isRemote).then( function() {
                                   myPromise.resolve(true);
                               });
                               */
                  return myPromise;
                }
              }

              //console.log("==== MOVING ==== ", targetObj);
              //console.log(i + "=> "+targetIndex);

              _execInfo.fromIndex = i;

              obj.data.splice(i, 1);
              obj.data.splice(targetIndex, 0, targetObj);
              this._cmd(a, obj, targetObj);

              if (!(bBothRemote || isRemote || _isRemoteUpdate)) {
                this.writeCommand(a);
              }

              if (!reflection) {
                me._leaveCtx(ctxName);
                me._sendCmdToRefs(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                myPromise.resolve(true);
              }

            }

          }



          // push a remote object into array
          if (a[0] == 16) {

            // Object to in
            // _changeToRemote
            // [16, <URL>, <ID>, <LocalID>, <ParentObject> ]
            console.log("%c COMMAND 16 ", 'background: #222; color: #bada55');
            console.log(a);


            var objToChange = this._find(a[4]),
              remoteURL = a[1],
              remoteID = a[2],
              localID = a[3],
              parentID = a[4];

            if (objToChange && objToChange.data) {

              if (!reflection) {
                // usually a plain new object is without _rid, it is usually just object..
                if (objToChange.__rid) {
                  a[4] = objToChange.__rid;
                  me._leaveCtx(ctxName);
                  console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }
              }

              console.log(" - - - about to insert remote object into array - - - ");
              var newObj = _data({
                data: {},
                __id: localID,
                __rid: remoteID
              });

              if (!me._waitingPromises) {
                me._waitingPromises = [];
              }
              me._waitingPromises.push(myPromise);

              newObj.then(
                function() {

                  console.log("%c COMMAND 16, did NEW object ", 'background: #222; color: #bada55');
                  console.log(newObj._docData);

                  // adding the new object into the data array of the parent object
                  objToChange.data.push(newObj._docData);
                  newObj._docData.__radioURL = remoteURL;
                  delete newObj._docData.__ctxCmdList;
                  delete newObj._docData.__cmdList;

                  var loaderPromise = _docUp()._changeToRemote(newObj._docData, remoteURL, remoteID);
                  // it should now have the data...
                  loaderPromise.then(function(d) {
                    console.log("%c COMMMAND 16 a new object creation, loader promise Returned with ", 'background: #222; color: #bada55');
                    console.log(d);
                    console.log("The object to be changed is now ", newObj);

                    var ff = me._find(localID);
                    console.log("From cache it is ", localID);
                    console.log(ff);

                    newObj._docData.__p = parentID;
                    newObj._docData.__vpid = parentID;

                    newObj._initializeData(newObj._docData);

                    var updateObj = _data(localID);
                    // updateObj._initializeData( newObj._docData );

                    updateObj.then(
                      function() {
                        me._cmd([7, objToChange.data.length, localID, null, parentID], objToChange, updateObj);
                        if (!reflection) {
                          me._sendCmdToRefs(a, isRemote).then(function() {
                            myPromise.resolve(d);
                          });
                        } else {
                          myPromise.resolve(d);
                        }

                      });


                  })
                });

              // if this is the real document, then write the command down to the stream
              if (!(isRemote || _isRemoteUpdate)) {
                console.log("Writing the command .... ");
                this.writeCommand(a);
              }
              me._leaveCtx(ctxName);


            }


          }


        } catch (e) {
          console.error(e.message);
          myPromise.resolve(e.message);
        }

        me._leaveCtx(ctxName);

        return myPromise;

        // this._virtualCommand( a, isRemote || _isRemoteUpdate );

      }
      _myTrait_.execCommandBackup = function(a, isRemote) {
        var me = this;

        if (this.isArray(a[0])) {
          a.forEach(function(cmd) {
            me.execCommand(cmd, isRemote);
          });
          return;
        }

        var ctxName = "::" + a[0] + "::" + a[1]; // i.e 4::x == set, x 
        if (!me._enterCtx(ctxName)) return;



        try {
          // console.log("*** execCommand ", a);

          //console.log("Got command, the context is now");
          //console.log(JSON.stringify( me._getCtx() ));



          // Create Object command...
          if (a[0] == 1) {
            var newObj = {
              data: {},
              __id: a[1]
            }
            var hash = this._getObjectHash();
            // console.log("Hash ", hash);
            hash[newObj.__id] = newObj;
            // this._cmd(a, obj, null);

            // Saving the write to root document
            if (!(isRemote || _isRemoteUpdate)) {
              this.writeCommand(a);
            }
          }

          if (a[0] == 2) {
            var newObj = {
              data: [],
              __id: a[1]
            }
            var hash = this._getObjectHash();
            // console.log("Hash ", hash);
            hash[newObj.__id] = newObj;
            // this._cmd(a, obj, null);

            // Saving the write to root document
            if (!(isRemote || _isRemoteUpdate)) {
              this.writeCommand(a);
            }
          }

          // console.log("Did execute the command");

          // The actual change of the object based on command "a"
          if (a[0] == 4) {

            var obj = this._find(a[4]),
              prop = a[1];

            if (obj) {
              // console.log("Was asked to update ", prop);
              obj.data[prop] = a[2]; // value is now set...
              this._cmd(a, obj, null);

              // Saving the write to root document
              if (!obj.__rid && !(isRemote || _isRemoteUpdate)) {
                this.writeCommand(a);
              } else {
                // console.log("*remote cmd*");
              }

              if (_listeners) {
                var lName = obj.__id + "::" + prop,
                  eList = _listeners[lName];
                if (eList) {
                  // console.log("**** got", lName);
                  eList.forEach(function(fn) {
                    fn(obj, a[2]);
                  })
                }
              }
            }
          }

          // There is not the change list coming...
          if (a[0] == 13) {

            // console.log("*** remote 13 ****", a);
            // var conv = aceCmdConvert();
            // conv.runToString(origString, commands);

            var obj = this._find(a[4]),
              prop = a[1];

            var conv = aceCmdConvert();

            // The string gets updated like this...
            obj.data[prop] = conv.runToString(obj.data[prop], a[2]);

            // Now the data has the correct value...

            // The command for the local workers could be just updating the string...

            // ******* this was here but might be moved into the ace editor update ********
            _doingRemote = isRemote || _isRemoteUpdate;

            var tmpCmd = [4, prop, obj.data[prop], null, a[4]];
            this._cmd(tmpCmd, obj, null);

            // But, for the remote stuff, we are going to use this..
            if (!(isRemote || _isRemoteUpdate)) {

              this.writeCommand(a); // ?????????
              //console.log("Writing the command as 'set' to the object ");
              //console.log(JSON.stringify(a));
            } else {
              //console.log("*** remote 13 => _cmd ****", a);
              //console.log("*remote cmd*");
              this._cmd(a, obj, null);
            }

            _doingRemote = false;

            if (_listeners) {
              var lName = obj.__id + "::" + prop,
                eList = _listeners[lName];
              if (eList) {
                // console.log("**** got", lName);
                eList.forEach(function(fn) {
                  fn(obj, obj.data[prop]);
                })
              }
            }
          }

          // Setting the member of ...
          if (a[0] == 5) {

            //console.log("Hash contents");
            //console.log(this._getObjectHash());

            var obj = this._find(a[4]),
              prop = a[1];
            setObj = this._find(a[2]);


            if (!obj) return;
            if (!setObj) return;

            obj.data[prop] = setObj; // value is now set...
            setObj.__p = obj.__id; // The parent relationship
            this._cmd(a, obj, setObj);

            this._moveCmdListToParent(setObj);

            // Saving the write to root document
            if (!(isRemote || _isRemoteUpdate)) {
              this.writeCommand(a);
            } else {

            }
          }


          // Insert new object with id...
          // The object should be already created and thus it exists in the
          // object cache of this "domain"
          if (a[0] == 7) {

            var parentObj = this._find(a[4]),
              insertedObj = this._find(a[2]),
              prop = "*",
              index = parentObj.data.length; // might check if valid...

            // Moving the object in the array
            if (parentObj && insertedObj) {

              // now the object is in the array...
              parentObj.data.push(insertedObj);
              insertedObj.__p = parentObj.__id;
              this._cmd(a, parentObj, insertedObj);

              this._moveCmdListToParent(insertedObj);

              // Saving the write to root document
              if (!(isRemote || _isRemoteUpdate)) {
                this.writeCommand(a);
              }



            }

          }

          // Remove object, this might be also NOT from array...???
          if (a[0] == 8) {

            // this.saveCommand("removeItem", i, this._removedItem._guid, null );
            // [8, index, removedid, null, parentid ]
            var parentObj = this._find(a[4]),
              removedItem = this._find(a[2]),
              prop = "*",
              index = parentObj.data.indexOf(removedItem); // might check if valid...

            // Moving the object in the array
            if (parentObj && removedItem) {

              // console.log("The index of the item to be remoed ", index);

              // now the object is in the array...
              parentObj.data.splice(index, 1);

              // Adding extra information to the object about it's removal
              removedItem.__removedAt = index;

              //console.log("Removed item");
              //console.log(removedItem);

              // console.log("===> making the _cmd");

              this._cmd(a, parentObj, removedItem);
              removedItem.__p = null; // must be set to null...

              // Saving the write to root document
              if (!(isRemote || _isRemoteUpdate)) {
                this.writeCommand(a);
              }

            }

          }



          if (a[0] == 12) {
            var obj = this._find(a[4]),
              prop = "*",
              len = obj.data.length,
              targetObj,
              i = 0;

            for (i = 0; i < len; i++) {
              var m = obj.data[i];
              if (m.__id == a[1]) {
                targetObj = m;
                break;
              }
            }

            // Questions here:
            // - should we move command list only on the parent object, not the child
            //  =>  this._moveCmdListToParent(targetObj); could be
            //      this._moveCmdListToParent(obj);
            // That is... where the command is really saved???
            // is the command actually written anywhere???
            //  - where is the writeCommand?
            // 
            // Moving the object in the array
            if (targetObj) {
              var targetIndex = parseInt(a[2]);

              //console.log("==== MOVING ==== ", targetObj);
              //console.log(i + "=> "+targetIndex);

              _execInfo.fromIndex = i;

              obj.data.splice(i, 1);
              obj.data.splice(targetIndex, 0, targetObj);
              this._cmd(a, obj, targetObj);

              if (!(isRemote || _isRemoteUpdate)) {
                this.writeCommand(a);
              }

            }

          }
        } catch (e) {
          console.error(e.message);
        }

        me._leaveCtx(ctxName);

        this._virtualCommand(a, isRemote || _isRemoteUpdate);

      }
      _myTrait_.execCommandBackup2 = function(t) {
        var me = this;
        var myPromise = _promise();

        if (this.isArray(a[0])) {
          console.log("Array of promises.... ");
          this._execCommandsPromise(a, isRemote).then(function() {
            myPromise.resolve(true);
          });
          return myPromise;
        }



        var ctxName = "::" + a[0] + "::" + a[1]; // i.e 4::x == set, x 
        if (!me._enterCtx(ctxName)) {
          console.log("===> could not enter");
          myPromise.resolve(true);
          return myPromise;
        }

        console.log("*** execCommand ", a);

        // this object holds the status of the execution
        var execStatus = this._getExecInfo();



        try {


          //console.log("Got command, the context is now");
          //console.log(JSON.stringify( me._getCtx() ));



          // Create Object command...
          if (a[0] == 1) {
            var newObj = {
              data: {},
              __id: a[1]
            }
            var hash = this._getObjectHash();
            // console.log("Hash ", hash);
            hash[newObj.__id] = newObj;
            // this._cmd(a, obj, null);

            // Saving the write to root document
            if (!(isRemote || _isRemoteUpdate)) {
              this.writeCommand(a);
            }

            myPromise.resolve(true);
          }

          if (a[0] == 2) {
            var newObj = {
              data: [],
              __id: a[1]
            }
            var hash = this._getObjectHash();
            // console.log("Hash ", hash);
            hash[newObj.__id] = newObj;
            // this._cmd(a, obj, null);

            // Saving the write to root document
            if (!(isRemote || _isRemoteUpdate)) {
              this.writeCommand(a);
            }
            myPromise.resolve(true);
          }

          // console.log("Did execute the command");

          // The actual change of the object based on command "a"
          if (a[0] == 4) {

            var obj = this._find(a[4]),
              prop = a[1];

            if (obj) {

              if (!reflection) {
                if (obj.__rid) {
                  // send the command to the reflection object...
                  // the command will then be reflected to all reflected objects...
                  console.log("**** sending command to the reflected object **** ");
                  a[4] = obj.__rid;
                  me._leaveCtx(ctxName);
                  //console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }
              }
              // console.log("Was asked to update ", prop, "to ", a[2]);

              _execInfo.oldValue = obj.data[prop];
              obj.data[prop] = a[2]; // value is now set...

              this._cmd(a, obj, null);

              // Saving the write to root document
              if (!obj.__rid && !(isRemote || _isRemoteUpdate)) {
                this.writeCommand(a);
              } else {
                // console.log("*remote cmd*");
              }

              if (_listeners) {
                var lName = obj.__id + "::" + prop,
                  eList = _listeners[lName];
                if (eList) {
                  // console.log("**** got", lName);
                  eList.forEach(function(fn) {
                    fn(obj, a[2]);
                  })
                }
              }
              if (!reflection) {
                me._leaveCtx(ctxName);
                console.log("**** commands to the refs... **** ");
                me._sendCmdToRefs(a, isRemote).then(function() {
                  console.log("**** ... commands to refs done. **** ");
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                console.log(".... looks like this was reflection??? ");
                myPromise.resolve(true);
              }
            } else {
              myPromise.resolve(true);
            }
          }

          // There is not the change list coming...
          if (a[0] == 13) {

            var obj = this._find(a[4]),
              prop = a[1];

            if (!reflection) {
              if (obj.__rid) {
                // send the command to the reflection object...
                // the command will then be reflected to all reflected objects...
                console.log("**** sending ACE update command to the reflected object **** ");
                a[4] = obj.__rid;
                me._leaveCtx(ctxName);
                console.log(JSON.stringify(a));
                me.execCommand(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              }
            }

            var conv = aceCmdConvert();

            // The string gets updated like this...
            obj.data[prop] = conv.runToString(obj.data[prop], a[2]);

            // ******* this was here but might be moved into the ace editor update ********
            _doingRemote = isRemote || _isRemoteUpdate;

            var tmpCmd = [4, prop, obj.data[prop], null, a[4]];
            this._cmd(tmpCmd, obj, null);

            // But, for the remote stuff, we are going to use this..
            if (!(isRemote || _isRemoteUpdate)) {
              this.writeCommand(a);
            } else {
              this._cmd(a, obj, null);
            }

            _doingRemote = false;

            if (_listeners) {
              var lName = obj.__id + "::" + prop,
                eList = _listeners[lName];
              if (eList) {
                // console.log("**** got", lName);
                eList.forEach(function(fn) {
                  fn(obj, obj.data[prop]);
                })
              }
            }

            if (!reflection) {
              me._leaveCtx(ctxName);
              me._sendCmdToRefs(a, isRemote).then(function() {
                myPromise.resolve(true);
              });
              return myPromise;
            } else {
              myPromise.resolve(true);
            }



          }

          // Setting the member of ...
          if (a[0] == 5) {

            //console.log("Hash contents");
            //console.log(this._getObjectHash());

            var obj = this._find(a[4]),
              prop = a[1];
            setObj = this._find(a[2]);


            if (!obj) return;
            if (!setObj) return;

            obj.data[prop] = setObj; // value is now set...
            setObj.__p = obj.__id; // The parent relationship
            this._cmd(a, obj, setObj);

            this._moveCmdListToParent(setObj);

            // Saving the write to root document
            if (!(isRemote || _isRemoteUpdate)) {
              this.writeCommand(a);
            } else {

            }
            myPromise.resolve(true);
          }


          // Insert new object with id...
          // The object should be already created and thus it exists in the
          // object cache of this "domain"
          if (a[0] == 7) {

            var parentObj = this._find(a[4]),
              insertedObj = this._find(a[2]),
              prop = "*",
              index = parentObj.data.length; // might check if valid...

            // Moving the object in the array
            if (parentObj && insertedObj) {

              console.log(" insert OK ");

              if (!reflection) {
                // usually a plain new object is without _rid, it is usually just object..
                if (parentObj.__rid) {
                  console.log("**** sending INSERT to the reflected object **** ");
                  a[4] = parentObj.__rid;
                  me._leaveCtx(ctxName);
                  console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }
              }

              // now the object is in the array...
              parentObj.data.push(insertedObj);
              insertedObj.__p = parentObj.__id;
              this._cmd(a, parentObj, insertedObj);

              if (!parentObj.__rid) this._moveCmdListToParent(insertedObj);

              if (parentObj.__rid) {
                console.log("Can not write command, because parent object has __rid");
              }

              // Saving the write to root document
              if (!(parentObj.__rid || isRemote || _isRemoteUpdate)) {
                console.log(" creating write ");
                this.writeCommand(a);
              }

              if (!reflection) {
                me._leaveCtx(ctxName);
                me._sendCmdToRefs(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                myPromise.resolve(true);
              }


            }

          }

          // Remove object, this might be also NOT from array...???
          if (a[0] == 8) {

            console.log("%c COMMAND 8 ", 'background: red; color: #bada55');
            console.log("*** remove item command ");
            console.log(a);

            // ** skipping this command        
            /*
                   me._leaveCtx(ctxName);
                   myPromise.resolve(true);
                   
                   return myPromise;
           */

            // this.saveCommand("removeItem", i, this._removedItem._guid, null );
            // [8, index, removedid, null, parentid ]
            var parentObj = this._find(a[4]),
              removedItem = this._find(a[2]),
              prop = "*",
              index = parentObj.data.indexOf(removedItem); // might check if valid...

            // Moving the object in the array
            if (parentObj && removedItem) {

              // __radioURL

              var bothReflected = (parentObj.__rid && removedItem.__rid);

              var bSameDomain = true;

              if (removedItem.__vpid && (removedItem.__vpid != removedItem.__pid)) {
                bSameDomain = false;
              }
              // if( removedItem.__radioURL ) bSameDomain = false;

              if (!reflection) {

                if (bSameDomain && (removedItem.__rid && parentObj.__rid)) {
                  console.log("**** sending remove command to the reflected object **** ");
                  a[4] = parentObj.__rid;
                  a[2] = removedItem.__rid;
                  me._leaveCtx(ctxName);
                  console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }


                if (!bSameDomain && (removedItem.__rid && parentObj.__rid)) {
                  console.log("**** sending remove command to the reflected object **** ");
                  a[4] = removedItem.__vpid;
                  a[2] = removedItem.__rid;
                  me._leaveCtx(ctxName);
                  console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }


                /*
                           console.log("*** Was not same domain, exiting...");
                           
                           me._leaveCtx(ctxName);
                           myPromise.resolve(true);
                           
                           return myPromise;  
                           
                           if(removedItem.__rid && parentObj.__pid) {
                                           
                                                 
                               console.log("**** sending remove command to the reflected object **** ");
                               a[4] = removedItem.__vpid || removedItem.__pid;
                               a[2] = removedItem.__rid;
                               me._leaveCtx(ctxName);
                               console.log(JSON.stringify(a));
                               me.execCommand(a, isRemote).then( function() {
                                   myPromise.resolve(true);
                               });
                               return myPromise;
                           }*/
              }

              console.log("*** was able to find the object to remove ");
              // console.log("The index of the item to be remoed ", index);

              // now the object is in the array...
              parentObj.data.splice(index, 1);

              // Adding extra information to the object about it's removal
              removedItem.__removedAt = index;

              //console.log("Removed item");
              //console.log(removedItem);

              // console.log("===> making the _cmd");

              this._cmd(a, parentObj, removedItem);
              removedItem.__p = null; // must be set to null...

              // Saving the write to root document
              if (!(bothReflected || isRemote || _isRemoteUpdate)) {
                this.writeCommand(a);
              }

              if (!reflection) {
                me._leaveCtx(ctxName);
                a[2] = removedItem.__rid; // just making sure that the reflection is used...
                me._sendCmdToRefs(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                myPromise.resolve(true);
              }


            }

          }



          if (a[0] == 12) {
            var obj = this._find(a[4]),
              prop = "*",
              len = obj.data.length,
              targetObj,
              i = 0;

            for (i = 0; i < len; i++) {
              var m = obj.data[i];
              if (m.__id == a[1]) {
                targetObj = m;
                break;
              }
            }

            // Questions here:
            // - should we move command list only on the parent object, not the child
            //  =>  this._moveCmdListToParent(targetObj); could be
            //      this._moveCmdListToParent(obj);
            // That is... where the command is really saved???
            // is the command actually written anywhere???
            //  - where is the writeCommand?
            // 
            // Moving the object in the array
            if (targetObj) {

              var targetIndex = parseInt(a[2]),
                mObj = this._find(a[1]),
                bBothRemote = obj.__rid && mObj.__rid;

              if (!reflection) {
                if (bBothRemote) {
                  // send the command to the reflection object...
                  // the command will then be reflected to all reflected objects...
                  console.log("**** sending moveToIndex CMD to the reflected object **** ");
                  a[4] = obj.__rid;
                  a[1] = mObj.__rid;
                  me._leaveCtx(ctxName);
                  console.log(JSON.stringify(a));
                  myPromise.resolve(true);
                  /*
                               me.execCommand(a, isRemote).then( function() {
                                   myPromise.resolve(true);
                               });
                               */
                  return myPromise;
                }
              }

              //console.log("==== MOVING ==== ", targetObj);
              //console.log(i + "=> "+targetIndex);

              _execInfo.fromIndex = i;

              obj.data.splice(i, 1);
              obj.data.splice(targetIndex, 0, targetObj);
              this._cmd(a, obj, targetObj);

              if (!(bBothRemote || isRemote || _isRemoteUpdate)) {
                this.writeCommand(a);
              }

              if (!reflection) {
                me._leaveCtx(ctxName);
                me._sendCmdToRefs(a, isRemote).then(function() {
                  myPromise.resolve(true);
                });
                return myPromise;
              } else {
                myPromise.resolve(true);
              }

            }

          }



          // push a remote object into array
          if (a[0] == 16) {

            // Object to in
            // _changeToRemote
            // [16, <URL>, <ID>, <LocalID>, <ParentObject> ]
            console.log("%c COMMAND 16 ", 'background: #222; color: #bada55');
            console.log(a);


            var objToChange = this._find(a[4]),
              remoteURL = a[1],
              remoteID = a[2],
              localID = a[3],
              parentID = a[4];

            if (objToChange && objToChange.data) {

              if (!reflection) {
                // usually a plain new object is without _rid, it is usually just object..
                if (objToChange.__rid) {
                  a[4] = objToChange.__rid;
                  me._leaveCtx(ctxName);
                  console.log(JSON.stringify(a));
                  me.execCommand(a, isRemote).then(function() {
                    myPromise.resolve(true);
                  });
                  return myPromise;
                }
              }

              console.log(" - - - about to insert remote object into array - - - ");
              var newObj = _data({
                data: {},
                __id: localID,
                __rid: remoteID
              });

              if (!me._waitingPromises) {
                me._waitingPromises = [];
              }
              me._waitingPromises.push(myPromise);

              newObj.then(
                function() {

                  console.log("%c COMMAND 16, did NEW object ", 'background: #222; color: #bada55');
                  console.log(newObj._docData);

                  // adding the new object into the data array of the parent object
                  objToChange.data.push(newObj._docData);
                  newObj._docData.__radioURL = remoteURL;
                  delete newObj._docData.__ctxCmdList;
                  delete newObj._docData.__cmdList;

                  var loaderPromise = _docUp()._changeToRemote(newObj._docData, remoteURL, remoteID);
                  // it should now have the data...
                  loaderPromise.then(function(d) {
                    console.log("%c COMMMAND 16 a new object creation, loader promise Returned with ", 'background: #222; color: #bada55');
                    console.log(d);
                    console.log("The object to be changed is now ", newObj);

                    var ff = me._find(localID);
                    console.log("From cache it is ", localID);
                    console.log(ff);

                    newObj._docData.__p = parentID;
                    newObj._docData.__vpid = parentID;

                    newObj._initializeData(newObj._docData);

                    var updateObj = _data(localID);
                    // updateObj._initializeData( newObj._docData );

                    updateObj.then(
                      function() {
                        me._cmd([7, objToChange.data.length, localID, null, parentID], objToChange, updateObj);
                        if (!reflection) {
                          me._sendCmdToRefs(a, isRemote).then(function() {
                            myPromise.resolve(d);
                          });
                        } else {
                          myPromise.resolve(d);
                        }

                      });


                  })
                });

              // if this is the real document, then write the command down to the stream
              if (!(isRemote || _isRemoteUpdate)) {
                console.log("Writing the command .... ");
                this.writeCommand(a);
              }
              me._leaveCtx(ctxName);


            }


          }


        } catch (e) {
          console.error(e.message);
          myPromise.resolve(e.message);
        }

        me._leaveCtx(ctxName);

        return myPromise;

        // this._virtualCommand( a, isRemote || _isRemoteUpdate );

      }
      _myTrait_.findFromCache = function(guid) {

        if (!_objectCache) return;

        return _objectCache[guid];
      }
      _myTrait_.getCommands = function(t) {
        return _commands;
      }
      _myTrait_.getObjectCache = function(t) {
        return _objectCache;
      }
      _myTrait_.getSetvalCmd = function(id, property) {

        if (!_objSetValCmds[id]) {
          _objSetValCmds[id] = {};
        }
        if (!_objSetValCmds[id][property]) {
          var a = _objSetValCmds[id][property] = [];
          // _commands.push(a);
        }

        return _objSetValCmds[id][property];
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {

        if (!_cmdIndex) {
          this.initCmdIndex();
          _execInfo = {};
          _channelCommands = {};
          _channelForks = {};

          _nsIndex = 1;

          _cmdNsMap = {
            1: [1],
            2: [1],
            4: [4],
            5: [2, 4],
            7: [2, 4],
            8: [2, 4],
            10: [2, 4],
            12: [4],
            13: [4],
            16: [3, 4]
          };

          _nsShortcuts = {};
          _nsReverse = {};

        }

      });
      _myTrait_.initCmdIndex = function(t) {
        _cmdIndex = {};
        _cmdIndex["createObject"] = 1;
        _cmdIndex["createArray"] = 2;
        _cmdIndex["initProp"] = 3;
        _cmdIndex["set"] = 4;
        _cmdIndex["setMember"] = 5;
        _cmdIndex["push"] = 6;
        _cmdIndex["pushObj"] = 7;
        _cmdIndex["removeItem"] = 8;

        // reserved 9 for optimizations
        _cmdIndex["last"] = 9;

        _cmdIndex["removeProperty"] = 10;
        _cmdIndex["insertObjectAt"] = 11;
        _cmdIndex["moveToIndex"] = 12;




        _lastCmdVals = [null, null, null, null, null];

        _objSetValCmds = {};

        _hotObjects = {};
        _hotDocs = {};
        _hotSettings = {
          time: (new Date()).getTime(),
          list: [],
          index: {}
        }

        later().every(1 / 20, function() {
          return; // remove this... does it still work???
          // console.log("Checking the hot docs");
          var t = _hotSettings.time = (new Date()).getTime();

          for (var id in _hotDocs) {
            if (_hotDocs.hasOwnProperty(id)) {
              var info = _hotDocs[id];

              var theDoc = info.doc._findRootDoc();
              // if has channel...???

              //console.log("** hotDoc **");
              //console.log(JSON.stringify(theDoc.__ctxCmdList));

              theDoc._broadcastToCmdChannels(theDoc, t - info.ms);
              theDoc.__ctxCmdList.length = 0;
              theDoc.__cmdList.length = 0;
              delete _hotDocs[id];
              delete _hotDocs[theDoc._guid];
              /*
                           if( t - info.ms > 2000) {
                               console.log("Might save document");
                               console.log(info.doc.__cmdList);
                               // broadcast & reset, should we reset?
                               info.doc._broadcastToCmdChannels(info.doc.__cmdList);
                               info.doc.__cmdList.length = 0;
                               delete _hotDocs[id];
                           }
                           */
            }
          }


        });

        // Disabled the "hot buffer" from this field
        /*
               setInterval( function() {
                   // console.log("Checking the hot buffer");
                   var t = _hotSettings.time = (new Date()).getTime();
                   
                   var list = _hotSettings.list,
                       len = list.length;
                   for(var i=len-1; i>=0;i--) {
                       var item = list[i];
                       // two seconds now the limit...
                       if(t - item.t > 2000) {
                           
                           if(item.o._hotBuffer) {
                               console.log("Compressing the buffer");
                               console.log(item.o.compressCmdBuffer(item.o._hotBuffer));
                               item.o._writeHotToDisk();
                               item.o._hotBuffer = null;
                               delete item.o._hotBuffer;
                           }
                           console.log("The item "+item.id+"age over 2 seconds, removing from hot buffer");
                           list.splice(i,1);
                           delete _hotSettings.index[item.id];
                           // TODO: compress and write to journal
                       }
                   }
                   
               },100);    
               */


      }
      _myTrait_.isDoingRemote = function(t) {
        return _doingRemote;
      }
      _myTrait_.isRecordingCommands = function(t) {
        return !this._isRecordCommandsOff;
      }
      _myTrait_.reverseCommand = function(cmd) {

        var newCmd = cmd.slice();

        if (cmd[0] == 4) {
          newCmd[2] = cmd[3];
          newCmd[3] = cmd[2];
        }


        return newCmd;
      }
      _myTrait_.saveCommand = function(action, property, value, oldValue) {


        if (!_commands) _commands = [];

        //console.log("** saveCommand ");
        if (_isRemoteUpdate) {
          //console.log("remote update is on");
          return;
        }

        /*
           if(this._isRecordCommandsOff)  {
               console.log("** recordCommands is off ");
               return this;
           }
           */

        // if legal command...
        var cmdPath = property;
        if (!_cmdIndex) {
          this.initCmdIndex();
        }
        var idx = _cmdIndex[action];
        if (!idx) {
          return;
        }

        var actionName = idx + ":" + property,
          me = this;

        if (!me._enterCtx(actionName)) return;

        // console.log("---- recording commands for "+this._guid);

        var useId = this._guid;
        // if(_lastCmdId && ( useId == _lastCmdId ) ) useId = "L";

        var a;
        if (idx == 4) {
          var hot = this._createHotObject(this);
          a = [];
          a[0] = idx;
          a[1] = property;
          a[2] = value;
          a[3] = oldValue;
          a[4] = this._guid;
        } else {
          a = [];
          // _commands.push(a);
          a[0] = idx;
          a[1] = property;
          a[2] = value;
          a[3] = oldValue;
          a[4] = useId;
        }

        if (this._hotBuffer) {
          this._hotBuffer.push(a);
        }

        if (_commandListener) _commandListener(a);


        var doc = this._findRootDoc();
        if (doc) {
          if (!doc.__cmdList)
            doc.__cmdList = [];

          if (!doc.__ctxCmdList)
            doc.__ctxCmdList = [];
          doc.__cmdList.push(a);
          doc.__ctxCmdList.push({
            ctx: this._getCtx(),
            cmd: a
          });
          //console.log("Just about to stringify the list");
          // console.log(JSON.stringify( doc.__ctxCmdList) );
          this._addHotDoc(doc);
          if (idx == 5) {
            //console.log('Root has currently this:');
            //     console.log(doc.__ctxCmdList);
            //console.log(JSON.stringify( doc.__ctxCmdList));
          }
        }

        //console.log("Save Command ", JSON.stringify( a ));


        me._leaveCtx(actionName);

        return this;


      }
      _myTrait_.setCommandRecOnOff = function(b) {

        if (b) {
          this._isRecordCommandsOff = false;
        } else {
          this._isRecordCommandsOff = true;
        }
        return this;
      }
      _myTrait_.writeCommand = function(a, obj) {

        if (!obj) obj = this._find(a[4]);

        a[5] = (new Date()).getTime();

        var myRoot = this._findRootDoc(obj);
        var rootData = myRoot;

        if (!rootData.__cmdList)
          rootData.__cmdList = [];
        // rootData.__cmdList.push(a);

        if (!rootData.__ctxCmdList)
          rootData.__ctxCmdList = [];

        if (rootData.__radio) {
          console.error("**** the RADIO should not be used with WRITE COMMAND ***** ");
          return;
          rootData.__ctxCmdList.push({
            ctx: this._getCtx(),
            cmd: a
          });

          console.log("RADIO");
          console.log("Sending", JSON.stringify(rootData.__ctxCmdList));
          rootData.__radio.send(rootData.__radioURL, rootData.__ctxCmdList);

          rootData.__ctxCmdList.length = 0;
          //            me._data.__radioURL = data;
          //            me._data.__radio = radio;    
        } else {
          rootData.__ctxCmdList.push({
            ctx: this._getCtx(),
            cmd: a
          });
        }

        //console.log("writeCmd, root data now");    
        //console.log(rootData)
      }
    }(this));;
    (function(_myTrait_) {
      var _callContext;
      var _localId;
      _myTrait_._createContextVar = function(withValue) {
        var v = {};

        if (!_localId) _localId = this.guid();

        var id = _localId + "" + withValue;

        v[id] = 1;

        return v;

      }
      _myTrait_._enterCtx = function(fname, allow) {

        if (!_callContext) {
          _callContext = {
            active: {}
          };
        }
        if (!_localId) _localId = this.guid();


        var id = _localId + fname;

        if (!_callContext.active[id]) {
          _callContext.active[id] = 1;
          return true;
        } else {
          if (allow) return true;
          // console.error("**** RECURSION PREVENTED **** ", id);
          return false;
        }
      }
      _myTrait_._getContextId = function(t) {

        return _localId;
      }
      _myTrait_._getCtx = function(t) {
        var o = {},
          a = _callContext.active;
        for (var n in a) {
          if (a.hasOwnProperty(n)) o[n] = a[n];
        }
        return o;
      }
      _myTrait_._leaveCtx = function(fname) {
        var id = _localId + fname;
        if (_callContext.active[id]) {
          delete _callContext.active[id];
        }

      }
      _myTrait_._resetCtx = function(t) {
        _callContext.active = {};
      }
      _myTrait_._setCtx = function(ctx) {
        _callContext.active = ctx;
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {

        // create local id
        if (!_localId) _localId = this.guid();

        if (!_callContext) {
          _callContext = {
            active: {}
          };
        }

        /*
    enter_call_ctx();
*/
      });
    }(this));;
    (function(_myTrait_) {
      var _commands;
      var _objectCache;
      var _cmdIndex;
      var _lastCmdId;
      var _lastCmdVals;
      var _objSetValCmds;
      var _commandListener;
      var _isRemoteUpdate;
      var _hotObjects;
      var _hotSettings;
      var _hotDocs;
      var _incomingDataFn;
      _myTrait_.forEach = function(filter, fn, obj) {


        if (filter) {

          var rawData, m, oo = this;
          if (obj) {
            if (!obj._data) return;
            m = obj.data[filter];
            if (m) rawData = m.data;
          } else {
            if (!this._data) return;
            m = this._data.data[filter];
            if (m) rawData = m.data;
          }
          if (rawData) {

            if (this.isArray(rawData)) {
              var i = 0,
                len = rawData.length;
              for (; i < len; i++) {
                var o = rawData[i];
                fn(o);
              }
            } else {

              if (this.isObject(rawData)) {
                for (n in rawData) {
                  if (rawData.hasOwnProperty(n)) {
                    var o = rawData[n];
                    fn(o);
                  }
                }
              }
            }



          }

        }
      }
    }(this));;
    (function(_myTrait_) {
      var _templateCompiler;
      var _views;
      var _eViews;
      var _controllers;
      var _isTransforming;
      var _transitionStatus;
      var _later;
      var _selectedItems;
      var _pushViews;
      var _clipBoard;
      var _dragState;
      var _oldViews;
      var _settingHash;
      var _uiCommands;
      _myTrait_._callController = function(ctrlId, dataId, domElem) {
        var pList = ctrlId.split("/");

        ctrlId = pList[0];
        pList.shift();

        console.log("Looking for '" + ctrlId + "' ");

        if (_controllers && _controllers[ctrlId]) {

          var model;
          console.log("Found it, data =  ", dataId);
          console.log(_controllers);
          if (dataId) {

            var model = this._find(dataId);
            _controllers[ctrlId](model, domElem, pList);
          }

        }
      }
      _myTrait_._clickResponder = function(event) {

        console.log("**** AT CLICK RESPONDER **** ");

        if (!_templateCompiler) {
          _templateCompiler = templateCompiler();
        }

        var ms = (new Date()).getTime();

        if (_dragState.hasClick) {
          if (ms - _dragState.hasClick < 80) return;
        }

        _dragState.hasClick = (new Date()).getTime();

        var me = this;
        var comp = _templateCompiler;

        var elem = event.target || event.srcElement;
        if (!elem) return;

        var popView = elem.getAttribute("data-click-pop");

        var bHadSomething = false;

        if (popView) {
          var vid = me.findPushId(elem);
          if (vid) {
            // console.log("The view was ", vid);
            me.popView(vid);

          }
        }

        var clickSel = elem.getAttribute("data-click-compile");
        if (clickSel) {
          var parts = clickSel.split("=>");
          console.log("Compiling", parts);
          var from = parts[0],
            to = parts[1];
          var dataId = elem.getAttribute("data-id");
          var d = me._find(dataId);
          if (d && from && to) {
            if (!_templateCompiler) {
              _templateCompiler = templateCompiler();
            }
            var comp = _templateCompiler, ///_getNamedViews
              me = this;
            var theData = comp.compile(d.data[from]);
            me.set(d, to, JSON.stringify(theData));
            var str = JSON.stringify(templateCompiler2().compile(d.data[from]));

            console.log(str);
            console.log("LENGTH", str.length)
            console.log("HTML size", d.data[from].length);
            console.log("Orig data size", JSON.stringify(theData).length);
          }

        }

        var clickSel = elem.getAttribute("data-click-set");
        if (clickSel) {
          var parts = clickSel.split("=");
          var varName = parts[0],
            varValue = parts[1];
          var dataId = elem.getAttribute("data-id");
          var d = me._find(dataId);

          me.query(varName, function(v, opts) {
            var d = opts.obj,
              varName = opts.name;
            console.log("Calling set for ", d, varName);
            if (d.data[varName] != varValue) {
              me.set(d, varName, varValue);
              // console.log("Setting to ", onVal);
            }
          }, d);

        }

        var clickSel = elem.getAttribute("data-click-clear");
        if (clickSel) {
          var list = clickSel.split(",");
          // data-click-clear="muuPalaute"
          list.forEach(
            function(varName) {
              var dataId = elem.getAttribute("data-id");
              var d = me._find(dataId);
              me.set(d, varName, "");
            });;
        }

        var clickSel = elem.getAttribute("data-toggle-this");
        if (clickSel) {
          var parts = clickSel.split("/");
          console.log("Data Toggle This ", parts);
          var varName = parts[0],
            onVal = parts[1],
            offVal = parts[2];
          var dataId = elem.getAttribute("data-id");
          var d = me._find(dataId);
          console.log("Calling set for ", d);
          if (d.data[varName] != onVal) {
            me.set(d, varName, onVal);
            // console.log("Setting to ", onVal);
          } else {
            me.set(d, varName, offVal);
          }
        }

        var clickSel = elem.getAttribute("data-toggle-sublevels");
        if (clickSel) {
          var parts = clickSel.split("/");
          //console.log(parts);
          var clickSel = parts[0],
            varName = parts[1],
            onVal = parts[2],
            offVal = parts[3];
          //console.log("***** MIGHT TOGGLE SUBLEVELS *****");
          var dataId = elem.getAttribute("data-id");
          var obj = me._find(dataId);
          //console.log(obj);
          if (obj && obj.data[clickSel]) {
            var tobble = obj.data[clickSel];
            if (tobble.data.length) {
              tobble.data.forEach(function(d) {

                if (d.data[varName] != onVal) {
                  me.set(d, varName, onVal);
                  console.log("Setting to ", onVal);
                } else {
                  me.set(d, varName, offVal);
                }
                console.log(d);
              })
            }
          }
        }

        var clickSel = elem.getAttribute("data-click-select");
        if (clickSel) {
          // then select this item into some model
          var dataId = elem.getAttribute("data-id"),
            model;
          if (dataId) {
            var model = me._find(dataId);

            if (!_selectedItems) _selectedItems = {};
            if (!_selectedItems[clickSel]) _selectedItems[clickSel] = [];

            var theList = _selectedItems[clickSel],
              theParentList;
            if (model.__p) {
              var parent = me._find(model.__p);
              if (parent) {
                if (!parent.__selected)
                  parent.__selected = {};
                if (!parent.__selected[clickSel])
                  parent.__selected[clickSel] = [];
                theParentList = parent.__selected[clickSel];
              }
            }
            var selClassBase = elem.getAttribute("data-sel-class"),
              selClass, selClassFilter,
              itemIndex;
            if (selClassBase) {
              var parts = selClassBase.split(":");
              selClassFilter = parts[0];
              if (selClassFilter == clickSel) selClass = parts[1];
            }

            if ((itemIndex = theList.indexOf(dataId)) >= 0) {
              // unselect the item...
              if (selClass) $(elem).removeClass(selClass);
              theList.splice(itemIndex, 1);
              if (theParentList) {
                var pid;
                if ((pid = theParentList.indexOf(dataId)) > 0) {
                  theParentList.splice(pid, 1);
                }
              }
            } else {
              // select the item...
              if (selClass) $(elem).addClass(selClass);
              theList.push(dataId);
              if (theParentList) {
                var pid;
                if (!((pid = theParentList.indexOf(dataId)) > 0)) {
                  theParentList.push(dataId);
                }
              }
            }

            bHadSomething = true;

          }
        }


        // clicking may start also a controller....
        var ctrlId = elem.getAttribute("data-click-ctrl");
        if (ctrlId) {

          var pList = ctrlId.split("/");

          ctrlId = pList[0];
          pList.shift();

          if (_controllers && _controllers[ctrlId]) {

            var dataId = elem.getAttribute("data-id"),
              model;
            if (dataId) {
              var model = me._find(dataId);
              bHadSomething = true;
            }
            _controllers[ctrlId](model, elem, pList);
          }

        }

        // send post data to URL

        var dataURL = elem.getAttribute("data-click-post-url");
        if (dataURL) {

          var dataId = elem.getAttribute("data-id"),
            model;
          if (dataId) {
            bHadSomething = true;
            var model = me._find(dataId);

            if (elem.getAttribute("data-post-only-id")) {
              if (me.isArray(model.data)) {
                model = {
                  __id: model.__id,
                  data: []
                };
              } else {
                model = {
                  __id: model.__id,
                  data: {}
                };
              }
            }
            $.ajax({
              type: "POST",
              url: dataURL,
              data: JSON.stringify(model),
              contentType: "application/json; charset=utf-8",
              dataType: "json",
              success: function(data) {
                // might get the response stream here, but not this time...
                console.log(data);
                if (data.__sCmds) me.execCommand(data.__sCmds, true);

                if (data.__uiCmds) {
                  data.__uiCmds.forEach(function(uiC) {
                    var fn = _uiCommands[uiC.cmd];
                    if (fn) {
                      fn.apply(me, uiC.data);
                    }
                  })
                }

              },
              failure: function(errMsg) {

              }
            });
          }

        }

        // Adding a new data -item as variable does not work as expected...
        var createItem = elem.getAttribute("data-click-create");
        if (createItem) {
          var str = "{" + createItem + "}";
          var dataObj = JSON.parse(str);
          console.log(str);
          console.log("To create ", JSON.stringify(dataObj));

          for (var n in dataObj) {
            var dataId = elem.getAttribute("data-id");
            if (dataId) {
              bHadSomething = true;
              // Then, how to add a document object
              var model = me._find(dataId);
              me.push(model.data[n], dataObj[n]);
            }
          }
        }

        var createItem = elem.getAttribute("data-click-copy");
        if (createItem) {

          var dataId = elem.getAttribute("data-id");
          if (dataId) {
            // Then, how to add a document object
            var model = me._find(dataId);
            var parent = me._find(model.__p);

            var theCopy = me.duplicate(model);

            me.push(parent, theCopy);
            bHadSomething = true;
          }

        }

        // _clipBoard

        var createItem = elem.getAttribute("data-click-to-clipboard");
        if (createItem) {

          var dataId = elem.getAttribute("data-id");
          if (dataId) {
            // Then, how to add a document object
            var model = me._find(dataId);
            var parent = me._find(model.__p);

            var theCopy = me.toPlainData(model);

            _clipBoard = theCopy;
            bHadSomething = true;
          }

        }

        var createItem = elem.getAttribute("data-click-from-clipboard");
        if (createItem) {

          var dataId = elem.getAttribute("data-id");
          if (dataId) {
            // Then, how to add a document object
            var mainModel = me._find(dataId);

            if (mainModel && mainModel.data) {
              var model = mainModel.data[createItem];
              if (model && _clipBoard && model.data && me.isArray(model.data)) {
                me.push(model, _clipBoard);
                bHadSomething = true;
              }
            }

          }

        }



        // clicking may start also a controller....
        var removeItem = elem.getAttribute("data-click-remove");
        if (removeItem) {
          var dataId = elem.getAttribute("data-id");
          if (dataId) {
            bHadSomething = true;
            if (confirm("Remove item?")) me.removeItem(dataId);
          }
        }

        // clicking may start also a controller....
        var moveItem = elem.getAttribute("data-click-moveup");
        if (moveItem) {
          var dataId = elem.getAttribute("data-id");
          if (dataId) {
            bHadSomething = true;
            me.moveItemUp(dataId);
          }
        }

        // clicking may start also a controller....
        var moveItem = elem.getAttribute("data-click-movedown");
        if (moveItem) {
          var dataId = elem.getAttribute("data-id");
          if (dataId) {
            bHadSomething = true;
            me.moveItemDown(dataId);
          }
        }





        var routeId = elem.getAttribute("data-click-view");


        if (routeId) {

          var routeList = routeId.split(",");

          routeList.forEach(
            function(routeId) {

              var parts = routeId.split("/"),
                itemId;
              if (parts.length > 1) {
                var defViewName = parts[1];
                routeId = parts[0];
              }
              var firstChar = routeId.charAt(0),
                whereTo;

              if (firstChar == ".") {
                itemId = routeId.substring(1);
                var par = elem.parentNode;
                while (par) {

                  if (!par.getAttribute) {
                    par = par.parentNode;
                    continue;
                  }
                  console.log("Looking for ", itemId);
                  if (par.getAttribute("data-viewclass") == itemId) {
                    whereTo = par;
                    break;
                  }
                  var cc;
                  if (cc = par.getAttribute("class")) {
                    if (cc.match(itemId)) {
                      whereTo = par;
                      break;
                    }
                  }
                  par = par.parentNode;
                }

              }
              if (firstChar == "#") {
                itemId = routeId.substring(1);
                var whereTo = document.getElementById(itemId);
              }

              if (!whereTo) console.log("Did not find ", routeId);

              if (whereTo) {
                bHadSomething = true;
                // data-id o
                var dataId = elem.getAttribute("data-id");
                console.log("data-id ", dataId);
                if (dataId) {
                  var model = me._find(dataId);
                  var bSet = false;
                  var eV = whereTo.getAttribute("data-e-view");
                  if (eV) {
                    if (_eViews && _eViews[eV]) {
                      // Then this is the function to create the view definitely...
                      var newView = _eViews[eV](model);
                      me.pushView(itemId, newView._dom, {
                        sourceElem: elem
                      });
                      bSet = true;
                    }
                  }

                  if (!bSet) {
                    var viewName;

                    if (defViewName) {
                      viewName = defViewName;
                    } else {
                      viewName = whereTo.getAttribute("data-use-view");
                    }

                    console.log("looking view ", viewName);
                    if (viewName) {
                      var w = me.findNamedView(viewName);
                      // still stupid way to do it...
                      console.log("found view ", w, "composing with", model);
                      if (w) {

                        var dd = comp.composeTemplate(model, w);
                        me.pushView(whereTo, dd, {
                          sourceElem: elem,
                          animMs: 400,
                          animFn: function(dom, ms) {
                            $(dom).addClass("bounceOut");
                          },
                          animEnd: function(dom) {
                            $(dom).removeClass("bounceOut");
                          }
                        });
                        //whereTo.innerHTML = "";
                        //whereTo.appendChild(dd);
                      }
                    }
                  }
                }
              }

            });

          // var dd = comp.composeTemplate( me._data,  jsonTplData );
        }

        return bHadSomething;
      }
      _myTrait_._createUploadFrame = function(options) {
        var o = _e();

        var form = o.form("", {
          "action": options.target,
          "enctype": "multipart/form-data",
          "method": "POST",
          "name": o.guid()
        });

        var maxCnt = options.maxCnt || 20;

        var onComplete = function(v) {
          if (options.onComplete) {
            options.onComplete(v);
          }
        };

        var chStr = "complete" + ((new Date()).getTime());
        window[chStr] = onComplete;
        form.input("", {
          type: "hidden",
          value: chStr,
          name: "onComplete"
        });
        form.label("control-label").text(options.title || "Valitse tiedostot");

        if (options.vars) {
          for (var n in options.vars) {
            if (options.vars.hasOwnProperty(n)) {
              form.input("", {
                type: "hidden",
                value: options.vars[n],
                name: n
              });
            }
          }
        }
        var uplFields = form.div("form-group");

        var maxFileCnt = options.maxFileCnt || 5,
          fileCnt = 0;

        var createUploadField = function() {
          if (fileCnt >= maxFileCnt) return;
          // <label for="exampleInputFile">File input</label>
          var inp = uplFields.input("", {
            type: "file",
            name: "file_" + fileCnt
          });
          inp.on("value", function() {
            if (options.autoUpload) {
              o.uploadFiles();
            } else {
              if (fileCnt < maxCnt) createUploadField();
            }
          });

          fileCnt++;
        }

        createUploadField();
        var iFrame = _e("iframe");
        var frame_id = o.guid();
        iFrame.q.attr("id", frame_id);
        iFrame.q.attr("name", frame_id);
        iFrame.absolute().x(-4000).y(-4000);

        o.add(iFrame);



        o.uploadFiles = function(vars) {
          if (vars) {
            for (var n in vars) {
              if (vars.hasOwnProperty(n)) {
                form.input("", {
                  type: "hidden",
                  value: vars[n],
                  name: n
                });
              }
            }
          }
          var targetForUpload = options.tElem.getAttribute("data-upload-to");
          if (targetForUpload) {
            form.attr({
              action: targetForUpload
            })
          }

          form._dom.target = frame_id; //'my_iframe' is the name of the iframe
          form._dom.submit();
          uplFields.clear();
          fileCnt = 0;
          createUploadField();

        }

        if (options.getUploader) {
          options.getUploader(o.uploadFiles);
        }


        return o;
      }
      _myTrait_._initUiCommands = function(t, dataId) {

        var me = this;
        if (!_templateCompiler) {
          _templateCompiler = templateCompiler();
        }
        var comp = _templateCompiler;


        _uiCommands["openView"] = function(routeId, dataId) {


          var bHadSomething = false;

          if (routeId) {

            var routeList = routeId.split(",");

            routeList.forEach(
              function(routeId) {

                var parts = routeId.split("/"),
                  itemId;
                if (parts.length > 1) {
                  var defViewName = parts[1];
                  routeId = parts[0];
                }
                var firstChar = routeId.charAt(0),
                  whereTo;

                // Simple method, OK?
                if (firstChar == "#") {
                  itemId = routeId.substring(1);
                  var whereTo = document.getElementById(itemId);
                }

                if (!whereTo) return; // console.log("Did not find ", routeId);

                if (whereTo) {
                  bHadSomething = true;
                  if (dataId) {
                    var model = me._find(dataId);
                    var bSet = false;
                    var eV = whereTo.getAttribute("data-e-view");
                    if (eV) {
                      if (_eViews && _eViews[eV]) {
                        // Then this is the function to create the view definitely...
                        var newView = _eViews[eV](model);
                        me.pushView(itemId, newView._dom, {
                          sourceElem: elem
                        });
                        bSet = true;
                      }
                    }

                    if (!bSet) {
                      var viewName;

                      if (defViewName) {
                        viewName = defViewName;
                      } else {
                        viewName = whereTo.getAttribute("data-use-view");
                      }

                      if (viewName) {
                        var w = me.findNamedView(viewName);
                        if (w) {
                          var dd = comp.composeTemplate(model, w);
                          me.pushView(whereTo, dd, {

                          });
                        }
                      }
                    }
                  }
                }

              });

            return bHadSomething;

            // var dd = comp.composeTemplate( me._data,  jsonTplData );
          }


        }


      }
      _myTrait_._mouseDownHandler = function(t) {


        _dragState.items = [];
        _dragState.itemsHash = {};
      }
      _myTrait_._mouseMoveHandler = function(event) {

        var elem = event.target;
        if (!elem) return;

        if (!elem.getAttribute) return;

        // return;

        // EXAMPLE of how to implement dragging etc. using this system...

        var dataId = elem.getAttribute("data-id"),
          model;
        if (dataId) {

          if (!_dragState.itemsHash[dataId]) {
            _dragState.itemsHash[dataId] = dataId;
            _dragState.items.push(dataId);
          }

          //         var model = me._find(dataId);
          //         console.log("Moving the mouse over ", dataId);
        }
      }
      _myTrait_._mouseUpHandler = function(event) {

        //    _dragState.itemsHash[dataId] = dataId;
        //    _dragState.items.push(dataId);

        console.log("Drag results");
        console.log(_dragState);
      }
      _myTrait_._valueResponder = function(obj, prop, value, elem) {

        var oldValue = obj.data[prop];
        obj.data[prop] = value;

        console.log("_valueResponder with ", prop, value);

        // AND emit then change event...
        _docUp()._emitEvent(obj.__id, "change", [4, prop, value, oldValue, obj.__id]);

        if (elem.getAttribute) {

          var f;
          if (f = elem.getAttribute("data-value-filter")) {
            // #model => x => result/on/off 

            var parts = f.split("=>"),
              me = this;

            var vName = $.trim(parts[1]),
              toggle = $.trim(parts[2]);

            var toggleParts = toggle.split("/"),
              toogleVar = toggleParts[0],
              toggleOn = toggleParts[1],
              toggleOff = toggleParts[2];

            var maxCnt = 50,
              mr;

            if (mr = elem.getAttribute("data-filter-maxcnt")) {
              maxCnt = mr;
            }

            this.query($.trim(parts[0]), function(model) {

              if (model && model.data && model.data.forEach) {
                model.data.forEach(function(m) {
                  if (maxCnt < 0) {
                    me.set(m, toogleVar, toggleOff);
                    return;
                  }
                  if (m.data[vName] && m.data[vName].toLowerCase().match(value.toLowerCase())) {
                    me.set(m, toogleVar, toggleOn);
                    maxCnt--;
                  } else {
                    me.set(m, toogleVar, toggleOff);
                  }
                });
              }

            });




          }
        }
      }
      _myTrait_.bindBaseEvents = function(elem) {

        if (!_templateCompiler) {
          _templateCompiler = templateCompiler();
        }

        // document.location.hash = "a=30,b=30,c=40";
        // console.log(document.location.hash);


        if (!_dragState) _dragState = {};

        _dragState.touchEnabled = false;
        var me = this;
        var comp = _templateCompiler;
        var o = {};

        if (!elem.addEventListener) {

          var ieStatus = {
            activeInput: null
          };

          elem.attachEvent("onkeyup", function(e) {

            if (ieStatus.activeInput && ieStatus.routeId) {
              var routeId = ieStatus.routeId;
              var elem = ieStatus.activeInput;
              var parts = routeId.split("::");
              var objid = parts[0];
              var obj = _docUp()._find(objid),
                prop = parts[1];

              if (!obj) {
                return;
              }

              // Change the object value...
              if (1) {
                //         if(typeof( obj.data[prop]) != "undefined") {
                var v = elem.value,
                  oldValue = obj.data[prop];
                if (v != oldValue) {
                  me._valueResponder(obj, prop, v, elem);
                }
              }
            }
            ieStatus.activeInput = window.event.srcElement;
          });

          elem.attachEvent("onfocusin", function(e) {
            var e = e || window.event;
            var elem = e.srcElement;
            ieStatus.activeInput = elem;
            ieStatus.routeId = elem.getAttribute("data-value-id");
            if (ieStatus.routeId) {
              // alert("Focus!!!");
            }
          });

          elem.attachEvent("onfocusout", function(e) {

            var e = e || window.event;
            var elem = e.srcElement;
            var r_id = elem.getAttribute("data-value-id");

            if (ieStatus.activeInput && (ieStatus.routeId == r_id)) {
              ieStatus.activeInput = null;
              ieStatus.routeId = 0;
            }
          })

          elem.attachEvent("onclick", function(event) {

            event = window.event;

            var timeNow = (new Date()).getTime();
            if (o.clickFired && ((timeNow - o.clickFired) < 600)) {
              return;
            }
            if (me._clickResponder(event)) {
              o.clickFired = timeNow;
            }
            o.clickFired = timeNow;
          });

          return;
        }

        // Might be mousedown handler separately....
        elem.addEventListener("mousedown", function(event) {
          me._mouseDownHandler(event);
        });

        elem.addEventListener("mousemove", function(event) {
          me._mouseMoveHandler(event);
        });

        elem.addEventListener("mouseup", function(event) {
          me._mouseUpHandler(event);
        });

        elem.addEventListener("click", function(event) {

          if (_dragState.touchEnabled) return;

          var timeNow = (new Date()).getTime();

          if (o.clickFired && ((timeNow - o.clickFired) < 200)) {
            return;
          }

          if (me._clickResponder(event)) {
            o.clickFired = timeNow;
          }

          return;
          var elem = event.target;
          if (!elem) return;

          var popView = elem.getAttribute("data-click-pop");

          if (popView) {
            var vid = me.findPushId(elem);
            if (vid) {
              console.log("The view was ", vid);
              me.popView(vid);
            }
          }

          var clickSel = elem.getAttribute("data-click-select");
          if (clickSel) {
            // then select this item into some model
            var dataId = elem.getAttribute("data-id"),
              model;
            if (dataId) {
              var model = me._find(dataId);

              if (!_selectedItems) _selectedItems = {};
              if (!_selectedItems[clickSel]) _selectedItems[clickSel] = [];

              var theList = _selectedItems[clickSel],
                theParentList;
              if (model.__p) {
                var parent = me._find(model.__p);
                if (parent) {
                  if (!parent.__selected)
                    parent.__selected = {};
                  if (!parent.__selected[clickSel])
                    parent.__selected[clickSel] = [];
                  theParentList = parent.__selected[clickSel];
                }
              }
              var selClassBase = elem.getAttribute("data-sel-class"),
                selClass, selClassFilter,
                itemIndex;
              if (selClassBase) {
                var parts = selClassBase.split(":");
                selClassFilter = parts[0];
                if (selClassFilter == clickSel) selClass = parts[1];
              }

              if ((itemIndex = theList.indexOf(dataId)) >= 0) {
                // unselect the item...
                if (selClass) $(elem).removeClass(selClass);
                theList.splice(itemIndex, 1);
                if (theParentList) {
                  var pid;
                  if ((pid = theParentList.indexOf(dataId)) > 0) {
                    theParentList.splice(pid, 1);
                  }
                }
              } else {
                // select the item...
                if (selClass) $(elem).addClass(selClass);
                theList.push(dataId);
                if (theParentList) {
                  var pid;
                  if (!((pid = theParentList.indexOf(dataId)) > 0)) {
                    theParentList.push(dataId);
                  }
                }
              }

              console.log("SELECT EVENT");
              console.log(_selectedItems);
              console.log(parent);

            }
          }


          // clicking may start also a controller....
          var ctrlId = elem.getAttribute("data-click-ctrl");
          if (ctrlId) {
            if (_controllers && _controllers[ctrlId]) {

              var dataId = elem.getAttribute("data-id"),
                model;
              if (dataId) {
                var model = me._find(dataId);
              }
              _controllers[ctrlId](model, elem);
            }

          }

          // send post data to URL

          var dataURL = elem.getAttribute("data-click-post-url");
          if (dataURL) {

            var dataId = elem.getAttribute("data-id"),
              model;
            if (dataId) {
              var model = me._find(dataId);
              $.ajax({
                type: "POST",
                url: dataURL,
                data: JSON.stringify(model),
                contentType: "application/json; charset=utf-8",
                dataType: "json",
                success: function(data) {
                  // might get the response stream here, but not this time...
                  console.log(data);
                  if (data.__sCmds) me.execCommand(data.__sCmds, true);
                },
                failure: function(errMsg) {

                }
              });
            }

          }

          // Adding a new data -item as variable does not work as expected...
          var createItem = elem.getAttribute("data-click-create");
          if (createItem) {
            var str = "{" + createItem + "}";
            var dataObj = JSON.parse(str);

            for (n in dataObj) {
              var dataId = elem.getAttribute("data-id");
              if (dataId) {
                // Then, how to add a document object
                var model = me._find(dataId);
                me.push(model.data[n], dataObj[n], n);
              }
            }
          }

          var createItem = elem.getAttribute("data-click-copy");
          if (createItem) {

            var dataId = elem.getAttribute("data-id");
            if (dataId) {
              // Then, how to add a document object
              var model = me._find(dataId);
              var parent = me._find(model.__p);

              var theCopy = me.duplicate(model);

              me.push(parent, theCopy);
            }

          }

          // _clipBoard

          var createItem = elem.getAttribute("data-click-to-clipboard");
          if (createItem) {

            var dataId = elem.getAttribute("data-id");
            if (dataId) {
              // Then, how to add a document object
              var model = me._find(dataId);
              var parent = me._find(model.__p);

              var theCopy = me.duplicate(model);

              _clipBoard = theCopy;

            }

          }

          var createItem = elem.getAttribute("data-click-from-clipboard");
          if (createItem) {

            var dataId = elem.getAttribute("data-id");
            if (dataId) {
              // Then, how to add a document object
              var mainModel = me._find(dataId);

              if (mainModel && mainModel.data) {
                var model = mainModel.data[createItem];
                if (model && _clipBoard && model.data && me.isArray(model.data)) {
                  me.push(model, _clipBoard);
                }
              }

            }

          }



          // clicking may start also a controller....
          var removeItem = elem.getAttribute("data-click-remove");
          if (removeItem) {
            var dataId = elem.getAttribute("data-id");
            if (dataId) {
              if (confirm("Remove item?")) me.removeItem(dataId);
            }
          }

          // clicking may start also a controller....
          var moveItem = elem.getAttribute("data-click-moveup");
          if (moveItem) {
            var dataId = elem.getAttribute("data-id");
            if (dataId) {
              me.moveItemUp(dataId);
            }
          }

          // clicking may start also a controller....
          var moveItem = elem.getAttribute("data-click-movedown");
          if (moveItem) {
            var dataId = elem.getAttribute("data-id");
            if (dataId) {
              me.moveItemDown(dataId);
            }
          }





          var routeId = elem.getAttribute("data-click-view");


          if (routeId) {

            var routeList = routeId.split(",");

            routeList.forEach(
              function(routeId) {

                var parts = routeId.split("/"),
                  itemId;
                if (parts.length > 1) {
                  var defViewName = parts[1];
                  routeId = parts[0];
                }
                var firstChar = routeId.charAt(0),
                  whereTo;

                if (firstChar == ".") {
                  itemId = routeId.substring(1);
                  var par = elem.parentNode;
                  while (par) {

                    if (!par.getAttribute) {
                      par = par.parentNode;
                      continue;
                    }
                    console.log("Looking for ", itemId);
                    if (par.getAttribute("data-viewclass") == itemId) {
                      whereTo = par;
                      break;
                    }
                    var cc;
                    if (cc = par.getAttribute("class")) {
                      if (cc.match(itemId)) {
                        whereTo = par;
                        break;
                      }
                    }
                    par = par.parentNode;
                  }

                }
                if (firstChar == "#") {
                  itemId = routeId.substring(1);
                  var whereTo = document.getElementById(itemId);
                }

                if (!whereTo) console.log("Did not find ", routeId);

                if (whereTo) {
                  // data-id o
                  var dataId = elem.getAttribute("data-id");
                  console.log("data-id ", dataId);
                  if (dataId) {
                    var model = me._find(dataId);
                    var bSet = false;
                    var eV = whereTo.getAttribute("data-e-view");
                    if (eV) {
                      if (_eViews && _eViews[eV]) {
                        // Then this is the function to create the view definitely...
                        var newView = _eViews[eV](model);
                        me.pushView(itemId, newView._dom, {
                          sourceElem: elem
                        });
                        bSet = true;
                      }
                    }

                    if (!bSet) {
                      var viewName;

                      if (defViewName) {
                        viewName = defViewName;
                      } else {
                        viewName = whereTo.getAttribute("data-use-view");
                      }

                      console.log("looking view ", viewName);
                      if (viewName) {
                        var w = me.findNamedView(viewName);
                        // still stupid way to do it...
                        console.log("found view ", w, "composing with", model);
                        if (w) {

                          var dd = comp.composeTemplate(model, w);
                          me.pushView(whereTo, dd, {
                            sourceElem: elem,
                            animMs: 400,
                            animFn: function(dom, ms) {
                              $(dom).addClass("bounceOut");
                            },
                            animEnd: function(dom) {
                              $(dom).removeClass("bounceOut");
                            }
                          });
                          //whereTo.innerHTML = "";
                          //whereTo.appendChild(dd);
                        }
                      }
                    }
                  }
                }

              });

            // var dd = comp.composeTemplate( me._data,  jsonTplData );
          }
        });


        window.addEventListener("hashchange", function() {
          if (_transitionStatus.hashSet) {
            console.log("In the middle of the hash setting");
            return;
          }

          var newHash = document.location.hash;
          console.log("We have a new hash " + newHash);
          console.log("No react is ", _transitionStatus.noReactOn);

          if (_transitionStatus.noReactOn) {
            if ("#" + _transitionStatus.noReactOn == newHash) {
              console.log("Should not react on ", newHash);
              return;
            }
          }

          var oldV = _oldViews.length;
          if (oldV > 0) {
            var ww = _oldViews[oldV - 1];
            me.popView(ww.pushId);
          }
        });

        elem.addEventListener("input", function(event) {
          var elem = event.target;
          if (!elem) return;
          var routeId = elem.getAttribute("data-value-id");

          // console.log("Input", routeId);

          if (routeId) {
            var parts = routeId.split("::");
            var objid = parts[0];
            var obj = _docUp()._find(objid),
              prop = parts[1];

            if (!obj) {
              return;
            }

            // Change the object value...
            if (1) {
              //         if(typeof( obj.data[prop]) != "undefined") {
              var v = elem.value,
                oldValue = obj.data[prop];
              if (v != oldValue) {
                me._valueResponder(obj, prop, v, elem);
              }
            }
          }
        }, true);

        // Problem: does not delegate for the lower levels...
        elem.addEventListener("change", function(event) {

          console.log("**** GOT CHANGE EVENT ****");

          var elem = event.target;
          if (!elem) return;
          var routeId = elem.getAttribute("data-value-id");

          console.log("**** TARGET FOR CHANGE EVENT ****");
          console.log(event.target);
          console.log(event.target.value);
          console.log(routeId);

          if (routeId) {
            var parts = routeId.split("::");
            var objid = parts[0];
            var obj = _docUp()._find(objid),
              prop = parts[1];

            if (!obj) {
              console.log("Could not find object with id ", objid);
              return;
            }

            // Change the object value...
            if (1) {
              console.log("==> value responder");
              //         if(typeof( obj.data[prop]) != "undefined") {
              var v = elem.value,
                oldValue = obj.data[prop];
              if (v != oldValue) {
                me._valueResponder(obj, prop, v, elem);
              }
            }
          }
        }, false);







        var touchStart = function(e) {

          _dragState.touchEnabled = true;
          // NOTE: Removed the windows lines below when looking for touch events
          // if (window.navigator.msPointerEnabled && !e.isPrimary) return;
          o._touchItems = [];
          var allTouches = e.touches;
          if (e.targetTouches) allTouches = e.targetTouches;
          o._touchCount = allTouches.length;
          for (var i = 0; i < allTouches.length; i++) {
            var item = {};

            item.startX = allTouches[0].pageX;
            item.startY = allTouches[0].pageY;
            o._touchItems[i] = item;
          }

          o.touchStartMs = (new Date()).getTime();
          o.bTouchOn = true;
          o.didMove = false;

          // o.trigger("touchstart");
          /*
                                 if(e.preventDefault) e.preventDefault();
                                 if(e.stopPropagation) e.stopPropagation();
                                 e.returnValue = false;
                                 */

        };

        var touchMove = function(e) {
          // TODO: windows specific things here....                      
          // var off = o.q.offset();
          var allTouches = e.touches;
          if (e.targetTouches) allTouches = e.targetTouches; // [0].pageX;)
          o._touchCount = allTouches.length;
          for (var i = 0; i < allTouches.length; i++) {
            var item = o._touchItems[i];
            item.dx = e.touches[i].pageX - item.startX;
            item.dy = e.touches[i].pageY - item.startY;
          }
          o.didMove = true;
          // TODO: EVENT TRIGGER TOUCH MOVE...
          // if(e.preventDefault) e.preventDefault();
        };

        var touchEnd = function(e) {
          // TODO: TRIGGER TOUCH END
          o.bTouchOn = false;
          var timeNow = (new Date()).getTime();
          var ms = timeNow - o.touchStartMs,
            cfDelta = timeNow - (o.clickFired || 0);

          //alert(ms);   
          //alert(cfDelta);  

          var dist = 0;
          if (o.didMove) {
            var dx = o._touchItems[0].dx,
              dy = o._touchItems[0].dy;

            dist = Math.sqrt(dx * dx + dy * dy);
          }


          if ((ms < 500) && (cfDelta > 100) && (dist < 20)) {

            o.clickFired = timeNow;
            if (me._clickResponder(e)) {
              if (e.preventDefault) e.preventDefault();
              if (e.stopPropagation) e.stopPropagation();
              e.returnValue = false;
              o.clickFired = timeNow;
            }
          }


        };


        var msHandler = function(event) {
          // o.trigger("mstouch",event);
          switch (event.type) {
            case "touchstart":
            case "MSPointerDown":
              touchStart(event);
              break;
            case "touchmove":
            case "MSPointerMove":
              touchMove(event);
              break;
            case "touchend":
            case "MSPointerUp":
              touchEnd(event);
              break;
          }
          event.returnValue = false;
        }

        // NOTE: Removed the windows lines below when looking at touch events
        /*
           if (window.navigator.msPointerEnabled) {
             elem.addEventListener("MSPointerDown", msHandler, false);
             elem.addEventListener("MSPointerMove", msHandler, false);
             elem.addEventListener("MSPointerUp", msHandler, false);
           } 
           */

        elem.addEventListener("touchstart", touchStart, false);
        elem.addEventListener("touchmove", touchMove, false);
        elem.addEventListener("touchend", touchEnd, false);

      }
      _myTrait_.createController = function(name, fn) {

        if (!_controllers) _controllers = {};

        _controllers[name] = fn;



      }
      _myTrait_.createView = function(viewName, viewFn) {

        if (!_eViews) {
          _eViews = {};
        }

        _eViews[viewName] = viewFn;
      }
      _myTrait_.findPushId = function(dom) {


        // newViewDOM.setAttribute("data-pushid", pushId);

        if (dom) {
          if (dom.getAttribute) {
            var id = dom.getAttribute("data-pushid");
            if (id && _pushViews) {
              var a = _pushViews[id];
              if (a) return id;
            }
          }
          if (dom.parentNode) {
            return this.findPushId(dom.parentNode);
          }
        }
      }
      _myTrait_.findSelection = function(name) {

        if (_selectedItems) {
          if (_selectedItems[name]) {
            return _selectedItems[name];
          }
        }
        return [];
      }
      _myTrait_.findViewElement = function(dom) {

        if (dom) {
          var id = dom.getAttribute("id");
          if (id) {
            var a = _views[id];
            if (a) return id;
          }
          if (dom.parentNode) {
            return this.findViewElement(dom.parentNode);
          }
        }
      }
      _myTrait_.findViewIdFromElem = function(dom) {
        if (dom) {
          if (dom.getAttribute) {
            var id = dom.getAttribute("id");
            if (id && _views) {
              var a = _views[id];
              if (a) return id;
            }
          }
          if (dom.parentNode) {
            return this.findViewIdFromElem(dom.parentNode);
          }
        }
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {

        if (!_transitionStatus) {
          _transitionStatus = {
            bTransform: false,
            hashSet: false
          }

          _oldViews = [];

          _dragState = {
            itemsHash: {},
            items: []
          };

          _uiCommands = {

          };

          this._initUiCommands();
          _templateCompiler = templateCompiler();

        }

        if (!_later)
          _later = later();
      });
      _myTrait_.popView = function(viewId) {

        if (_transitionStatus.on) return;

        if (this.isObject(viewId)) {
          var dom = viewId;
          viewId = this.findPushId(viewId);
        }

        // 
        if (_pushViews && _pushViews[viewId]) {

          _oldViews.pop();

          var saveViewDef = _pushViews[viewId].pop();
          if (saveViewDef) {
            // remove the old view...
            /*
                     var saveViewDef = {
               viewFrag : frag,
               parentDOM : dom
           }
                     */
            // don't know if this works with SVG elements
            var d = saveViewDef.parentDOM;
            while (d.firstChild) d.removeChild(d.firstChild);
            d.appendChild(saveViewDef.viewFrag);

            console.log(saveViewDef);

            if (saveViewDef.sourceElem) {
              // console.log("Should scroll to ", saveViewDef.sourceElem);
              this.scrollTo(saveViewDef.sourceElem);
            } else {
              this.scrollTo(d);
            }
            _transitionStatus.hashSet = true;
            _transitionStatus.noReactOn = (new Date()).getTime();
            document.location.hash = _transitionStatus.noReactOn;

            later().add(function() {
              _transitionStatus.hashSet = false;
            });
          }

        }
      }
      _myTrait_.pushView = function(viewId, newViewDOM, options) {

        console.log("pushView called ", viewId);


        var realViewId,
          dom,
          me = this;
        if (this.isObject(viewId)) {
          dom = viewId;
          viewId = dom.getAttribute("data-viewid");
          console.log("pushView with ", dom, viewId);
          if (!viewId) return;
        } else {
          realViewId = viewId;
          dom = document.getElementById(viewId);
        }
        if (_transitionStatus.on) return;

        if (!dom) return;
        if (!options) options = {};

        if (!_oldViews) {
          _oldViews = [];
        }

        _transitionStatus.hashSet = true;
        _transitionStatus.noReactOn = (new Date()).getTime();
        document.location.hash = _transitionStatus.noReactOn;

        later().add(function() {
          _transitionStatus.hashSet = false;
        });

        if (!_views) _views = {};
        if (!_views[viewId]) _views[viewId] = [];

        var pushId = this.guid();

        if (!_pushViews) _pushViews = {};
        if (!_pushViews[pushId]) _pushViews[pushId] = [];



        newViewDOM.setAttribute("data-pushid", pushId);

        if (options.animFn && options.animMs && 0) {

          _transitionStatus.on = true;

          console.log("About the create transform");
          // Switch the view to it's place...
          options.animFn(dom, options.animMs);

          _later.after(options.animMs / 1000, function() {


            // to remove the old view to invisible fragment...
            var frag = document.createDocumentFragment();

            while (dom.firstChild) {
              var fc = dom.firstChild;
              dom.removeChild(fc);
              frag.appendChild(fc);
            }

            // just position the view into the list of views...
            var saveViewDef = {
              viewFrag: frag,
              parentDOM: dom,
              sourceElem: options.sourceElem || null,
              pushId: pushId
            }
            _views[viewId].push(saveViewDef);
            _pushViews[pushId].push(saveViewDef);
            _oldViews.push(saveViewDef);

            dom.appendChild(newViewDOM);
            me.scrollTo(newViewDOM);

            _transitionStatus.on = false;

            options.animEnd(dom);


          });
          return;
        }

        // to remove the old view to invisible fragment...
        var frag = document.createDocumentFragment();

        while (dom.firstChild) {
          var fc = dom.firstChild;
          dom.removeChild(fc);
          frag.appendChild(fc);
        }

        // just position the view into the list of views...
        var saveViewDef = {
          viewFrag: frag,
          parentDOM: dom,
          sourceElem: options.sourceElem || null,
          pushId: pushId
        }
        _oldViews.push(saveViewDef);

        _views[viewId].push(saveViewDef);
        _pushViews[pushId].push(saveViewDef);
        me.scrollTo(newViewDOM);

        dom.appendChild(newViewDOM);

        return this;
      }
      _myTrait_.scrollTo = function(elem) {
        if (window) {

          var box = {
            left: 0,
            top: 0,
            width: 800,
            height: 800
          };

          try {
            // BlackBerry 5, iOS 3 (original iPhone)
            if (typeof elem.getBoundingClientRect !== "undefined") {
              box = elem.getBoundingClientRect();
            }
          } catch (e) {
            // for IE having this bg
            box = {
              left: 0,
              top: 0,
              width: 800,
              height: 800
            };
          }

          var currLeft = window.pageXOffset;

          var toY = box.top;
          if (toY < window.innerHeight / 2) return;
          if (box.top < window.innerHeight) {
            toY = toY / 2;
          } else {
            toY = toY - window.innerHeight * 0.2
          }

          window.scrollTo(currLeft || 0, parseInt(toY));
          // console.log(box);
          // alert((currLeft || 0)+","+ parseInt(box.top))
        }
      }
      _myTrait_.touchEvents = function(t) {

        // NOTE
        // http://blogs.msdn.com/b/davrous/archive/2013/02/20/handling-touch-in-your-html5-apps-thanks-to-the-pointer-events-of-ie10-and-windows-8.aspx
        // http://msdn.microsoft.com/en-us/library/ie/hh673557(v=vs.85).aspx
        // https://coderwall.com/p/egbgdw
        // http://jessefreeman.com/articles/from-webkit-to-windows-8-touch-events/

        var elem = this._dom;

        // No hope...
        if (!elem.addEventListener) return;

        var o = this;
        this._touchItems = [];

        var touchStart = function(e) {
          // NOTE: Removed the windows lines below when looking for touch events
          // if (window.navigator.msPointerEnabled && !e.isPrimary) return;
          o._touchItems = [];

          // NOTE: Removed the windows lines below when looking for touch events
          /*
                                 if(window.navigator.msPointerEnabled && e.pageX) {
                                    var item = {};
                                   
                                   item.startX = e.pageX;
                                   item.startY = e.pageY;
                                   o.trigger("touchstart");
                                   o._touchItems.push(item);
                                   if(e.preventDefault) e.preventDefault();
                                   return;
                               }*/
          // o.debug("touchStart");
          var allTouches = e.touches;
          if (e.targetTouches) allTouches = e.targetTouches;
          o._touchCount = allTouches.length;
          for (var i = 0; i < allTouches.length; i++) {
            var item = {};

            item.startX = allTouches[0].pageX;
            item.startY = allTouches[0].pageY;
            o._touchItems[i] = item;
          }

          o.trigger("touchstart");
          if (e.preventDefault) e.preventDefault();

          if (e.stopPropagation) e.stopPropagation();

          e.returnValue = false;


        };

        var touchMove = function(e) {
          // NOTE: Removed the windows lines below when looking at touch events
          /*
                               if (window.navigator.msPointerEnabled && !e.isPrimary) return;
                               if(window.navigator.msPointerEnabled && e.pageX) {
                                   //if(!o._touchItems) o._touchItems = [];
                                   //if(!o._touchItems[0]) o._touchItems[0] = {};
                                   var item = o._touchItems[0];
                                   item.dx = e.pageX - item.startX;
                                   item.dy = e.pageY - item.startY;
                                   o.trigger("touchmove");
                                   if(e.preventDefault) e.preventDefault();
                                   return;
                               }*/

          // var off = o.q.offset();
          var allTouches = e.touches;
          if (e.targetTouches) allTouches = e.targetTouches; // [0].pageX;)
          o._touchCount = allTouches.length;
          for (var i = 0; i < allTouches.length; i++) {
            var item = o._touchItems[i];

            item.dx = e.touches[i].pageX - item.startX;
            item.dy = e.touches[i].pageY - item.startY;
            //item.x = e.touches[i].pageX - off.left;
            //item.y = e.touches[i].pageY - off.top;
          }

          o.trigger("touchmove");


          if (e.preventDefault) e.preventDefault();
        };

        var touchEnd = function(e) {
          // o.q.css("transform", "rotate(20deg)");
          o.trigger("touchend");
          if (e.preventDefault) e.preventDefault();
          e.returnValue = false;
        };

        /*elem.addEventListener("touchcancel", function(e) {
                                 o.trigger("touchcancel");
                                 e.preventDefault();
                                 }, false);*/


        var msHandler = function(event) {
          // o.trigger("mstouch",event);
          switch (event.type) {
            case "touchstart":
            case "MSPointerDown":
              touchStart(event);
              break;
            case "touchmove":
            case "MSPointerMove":
              touchMove(event);
              break;
            case "touchend":
            case "MSPointerUp":
              touchEnd(event);
              break;
          }
          // if(event.preventDefault) event.preventDefault();
          event.returnValue = false;
          //                     event.preventDefault();
        }

        // NOTE: Removed the windows lines below when looking at touch events
        /*
           if (window.navigator.msPointerEnabled) {
             elem.addEventListener("MSPointerDown", msHandler, false);
             elem.addEventListener("MSPointerMove", msHandler, false);
             elem.addEventListener("MSPointerUp", msHandler, false);
           } 
           */

        elem.addEventListener("touchstart", touchStart, false);

        elem.addEventListener("touchmove", touchMove, false);

        elem.addEventListener("touchend", touchEnd, false);
        /*
           elem.addEventListener("touchcancel", function(e) {
                                 o.trigger("touchcancel");
                                 e.preventDefault();
                                 },                
           */

        return;
      }
    }(this));;
    (function(_myTrait_) {
      var _defaultSettings;
      _myTrait_.getDataAccessMethods = function(url) {

        // console.log("Parsing ", url);        


        // remove spaces from the start
        while (url && url.length && (url.charAt(0) == " ")) {
          url = url.substring(1);
        }

        var parts1 = url.split("://");

        var info = {
          bRemote: false
        };

        var dataQuery,
          rest;

        // **** examples of the remote URL methods...
        // http://someserver.com:1234/sandbox/path/fileName FETCH items/0/2 AS basedata
        // 
        // SELECT items/0 AS basedata
        // ----
        // --- > something like SQL query or similar

        // it could be also
        // SELECT ../items as mainPath



        if (parts1.length > 1) {

          var protocol = parts1.shift(),
            rest = parts1.shift();

          // The first space counts here a bit...
          var itemPaths = rest.split(" ");

          if (itemPaths.length > 0) {
            // There is something like "SELECT or similar"
            rest = itemPaths.shift();
            dataQuery = itemPaths.join(" ");
            info.dataQuery = dataQuery;
            info.queryInfo = this.getQueryInfo(dataQuery);
          }

          info.remoteUrl = protocol + "://" + rest;


          info.protocol = protocol;
          info.bRemote = true;

          var serverParts = rest.split("/"),
            ipAndPort = serverParts.shift(),
            iParts = ipAndPort.split(":"),
            ip = iParts[0],
            port = iParts[1];

          info.port = port;
          info.ip = ip;

          var sandbox = serverParts.shift(),
            fileName = serverParts.pop(),
            path = serverParts.join("/");

          info.remoteSandbox = sandbox;
          info.removeFileName = fileName;
          info.remotePath = path;

        } else {
          info.bCurrentData = true;
          info.dataQuery = parts1[0];
          info.queryInfo = this.getQueryInfo(info.dataQuery);
        }
        return info;
      }
      _myTrait_.getQueryInfo = function(query) {

        // console.log("getQueryInfo");
        // console.log(query);
        var info = {};

        // remove spaces from the start
        while (query && query.length && (query.charAt(0) == " ")) {
          query = query.substring(1);
        }

        var oneSpaceOnly = function(arr) {
          var len = arr.length;
          var bIsSpace = false;

          var i = len - 1;

          while (i >= 0) {
            // console.log(i, arr);
            // console.log(arr[i]);
            if (!arr[i] || arr[i].length == 0) {
              arr.splice(i, 1);
              i--;
              continue;
            }
            if (arr[i] == " ") {
              if (bIsSpace) {
                arr.splice(i, 1);
              } else {
                bIsSpace = true;
              }
            } else {
              bIsSpace = false;
            }
            i--;
          }
          // console.log(arr);
          return arr;
        }

        if (query) {
          var rest = query;
          var tokens = query.split(" ");

          tokens = oneSpaceOnly(tokens);

          if (rest.charAt(0) == "#") {
            var name = tokens.shift();
            info.bNamedView = true;
            info.viewName = name.substring(1);
            rest = tokens.join(" ");
          }

          if (rest.charAt(0) == "@") {
            var name = tokens.shift();
            info.bMetaData = true;
            info.metaName = name.substring(1);
            rest = tokens.join(" ");
          }

          if (tokens[0]) {
            if (tokens[0].toLowerCase() == "select") {
              info.selectCmd = tokens.shift();
              info.pathQuery = tokens.shift();
            } else {
              info.pathQuery = tokens.shift();
            }

            if (tokens[0]) {
              // can't do anything else now
              if (tokens[0].toLowerCase() == "as") {
                info.asCmd = tokens.shift();
                info.asName = tokens.shift();
              }
            }
          }

        }

        if (info.pathQuery) {
          var pp = info.pathQuery.split(":");
          if (pp.length > 1) {
            info.pathQuery = pp[0];
            info.customType = pp[1];
          }
        }

        return info;
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {

        if (!_defaultSettings) {
          _defaultSettings = {};
        }
      });
      _myTrait_.query = function(query, fn, baseData) {

        // console.log(query);
        var info = this.getDataAccessMethods(query);



        var me = this;

        if (info.bRemote) {

          var theData = _docUp(info.remoteUrl);

          theData.then(function() {

            var model = theData.fetch(info.queryInfo.pathQuery);
            // console.log("Fetch returned ", model);

            if (info.queryInfo.asName) {
              me.setNamedModel(info.queryInfo.asName, model);
            }

            fn(model);
          });

        } else {

          // console.log(info);

          // TODO: also the metadata query
          if (info.queryInfo.bNamedView) {
            baseData = me.getNamedModel(info.queryInfo.viewName);
            if (!baseData) {
              fn(null, null);
              return;
            }
          }

          if (!baseData) {
            baseData = me.getData();
          }

          if (info.queryInfo.bMetaData && baseData) {
            // console.log("Looking meta");
            baseData = me.getMeta(baseData, info.queryInfo.metaName);
            if (!baseData) {
              fn(null, null);
              return;
            }
          }

          if (!info.queryInfo.pathQuery)
            info.queryInfo.pathQuery = "/";


          var model = me.fetch(info.queryInfo.pathQuery, baseData);
          if (info.queryInfo.asName) {
            me.setNamedModel(info.queryInfo.asName, model);
          }

          if (info.queryInfo.customType) {
            var cType = templateCompiler().createViewType(info.queryInfo.customType, model, {});
            if (cType) {
              model = cType.textContent || cType.innerText || "";
            }
          }


          fn(model, {
            obj: me._lastQueryObj,
            name: me._lastQueryVar
          });
        }
        /*
           
           {
             "bRemote": false,
             "bCurrentData": true,
             "dataQuery": "#myChannel @theMeta items/0/html as basedata",
             "queryInfo": {
               "bNamedView": true,
               "viewName": "#myChannel",
               "bMetaData": true,
               "metaName": "@theMeta",
               "pathQuery": "items/0/html",
               "asCmd": "as",
               "asName": "basedata"
             }
           }
           
           
           {
             "bRemote": true,
             "dataQuery": "select items/0/html as basedata",
             "queryInfo": {
               "selectCmd": "select",
               "pathQuery": "items/0/html",
               "asCmd": "as",
               "asName": "basedata"
             },
             "remoteUrl": "http://someserver.com:1234/sandbox/path/fileName",
             "protocol": "http",
             "port": "1234",
             "ip": "someserver.com",
             "remoteSandbox": "sandbox",
             "removeFileName": "fileName",
             "remotePath": "path"
           }
           */


      }
    }(this));;
    (function(_myTrait_) {
      var _commands;
      var _cmdPoints;
      var _channelLoops;
      _myTrait_._disableChannel = function(chid) {

        var ch = this._getChannelPoints(chid);
        if (!ch.disabled) {
          ch.disableIndex = ch.i;
        }
        ch.disabled = true;
      }
      _myTrait_._enableChannel = function(chid) {
        var ch = this._getChannelPoints(chid);
        ch.disabled = false;
      }
      _myTrait_._getChannelPoints = function(id) {


        if (!_cmdPoints[id]) _cmdPoints[id] = {
          i: 0,
          o: 0,
          currentPointer: 0,
          currentPromise: null,
          currentMainPromise: null,
          waitingList: []
        };
        return _cmdPoints[id];
      }
      _myTrait_._getCommandCnt = function(channelId) {
        if (!_commands) return 0;
        if (!_commands[channelId]) return 0;

        var _cmdPoints = this._getChannelPoints(channelId);

        var i = _cmdPoints.i,
          ch = _commands[channelId];

        return ch.length - i;
      }
      _myTrait_._getCommandHistory = function(channelId) {
        if (!_commands) return [];
        if (!_commands[channelId]) return [];

        return _commands[channelId];
      }
      _myTrait_._getCommandPointer = function(t) {
        return _cmdPoints.i;
      }
      _myTrait_._hasNewCommands = function(channelID) {
        if (!_commands) return;
        if (!_commands[channelID]) return;

        var _cmdPoints = this._getChannelPoints(channelID);

        var i = _cmdPoints.i,
          ch = _commands[channelID],
          c = ch[i];

        if (!c) return false;

        return true;
      }
      _myTrait_._isAtEndNoWaiting = function(channelID) {

        var cInfo = this._getChannelPoints(channelID);

        if ((this._getCommandCnt(channelID) == 0) && cInfo.waitingList.length == 0) {

          if (!cInfo.currentMainPromise) {
            return true;
          }
        }
        return false;
      }
      _myTrait_._isChannelDisabled = function(chid) {
        var ch = this._getChannelPoints(chid);
        return ch.disabled;
      }
      _myTrait_._popChannelCommand = function(channelID) {
        if (!_commands) return;
        if (!_commands[channelID]) return;

        var _cmdPoints = this._getChannelPoints(channelID);

        var i = _cmdPoints.i,
          ch = _commands[channelID],
          c = ch[i];

        if (!c) return;

        _cmdPoints.i++;

        return c;
      }
      _myTrait_._pushChannelCommand = function(channelId, cmd, ctx, isRemote, radio) {

        if (!_commands[channelId]) {
          _commands[channelId] = [];
        }
        // console.log("Push channel command ", JSON.stringify( cmd ));
        cmd = cmd.slice();

        // set the command number...
        cmd[5] = _commands[channelId].length;

        if (this._isChannelDisabled(channelId)) {

          _commands[channelId].push({
            cmd: cmd,
            ctx: ctx,
            r: isRemote,
            radio: radio
          });
          return;
        }

        // write the set commands immediately, no promise based thingie if all is clear to run...
        if (isRemote && this._isAtEndNoWaiting(channelId) && (cmd[0] == 4)) {

          //console.log("---- passing through command to channel ----- ");
          //console.log(cmd);
          this._realExecCmd(cmd, true);
          _commands[channelId].push({
            cmd: cmd,
            ctx: ctx,
            r: isRemote,
            radio: radio,
            done: true
          });
          var _cmdPoints = this._getChannelPoints(channelId);
          _cmdPoints.i++;
        } else {
          cmd[6] = (new Date()).getTime();
          // console.log("---- can not pass thorugh command ----- ");
          _commands[channelId].push({
            cmd: cmd,
            ctx: ctx,
            r: isRemote,
            radio: radio
          });
        }



      }
      _myTrait_._startChannelLoop = function(url) {

        if (!_channelLoops[url]) {

          _channelLoops[url] = true;
          var me = this;
          later().every(1 / 30, function() {
            // Then, get the channel commands from the buffer...  
            if (me._isChannelDisabled(url)) return;
            if (me._hasNewCommands(url)) {

              me._stepCommandList(url);
            }
          });

        }
      }
      _myTrait_._stepCommandList = function(channelID) {

        var _cmdPoints = this._getChannelPoints(channelID);
        var bAddWaiting = false;
        if (_cmdPoints.currentMainPromise) {
          bAddWaiting = true;
        }

        var rad = docRadio();

        var ns = rad.namespace(channelID);

        var first = _promise(),
          myPromise = _promise(),
          me = this;

        var createPromise = function(p, cmd) {
          return p.then(
            function() {

              var reflection = false;
              if (cmd.ctx) {
                if (me.isObject(cmd.ctx)) {
                  me._setCtx(cmd.ctx);
                } else {
                  me._enterCtx(cmd.ctx);
                }
              }

              var pp;
              if (cmd.r) {
                // console.log(cmd.cmd);
                pp = me._realExecCmd(cmd.cmd, cmd.r, reflection);
              } else {
                pp = _promise();
              }

              if (!pp) {
                pp = _promise();
                pp.resolve(true);
                return pp;
              }
              cmd.cmd = me._transformCmdFromNs(cmd.cmd);

              _cmdPoints.currentPromise = pp;
              _cmdPoints.currentPromiseMs = (new Date()).getTime();

              pp.then(function() {
                //console.log("resolved command ", cmd);
                if (cmd.ctx) {
                  if (me.isObject(cmd.ctx)) {
                    me._resetCtx();
                  } else {
                    me._leaveCtx(cmd.ctx);
                  }
                }
              })
                .fail(function() {
                  console.error("FAILED command ", cmd);
                  if (cmd.ctx) {
                    if (me.isObject(cmd.ctx)) {
                      me._resetCtx();
                    } else {
                      me._leaveCtx(cmd.ctx);
                    }
                  }
                });

              return pp;
            });
        }

        // collect remote commands to list to be sent immediately...
        var p = first,
          cnt = 0,
          c,
          remoteCmdList = [],
          chRadio;

        while (c = this._popChannelCommand(channelID)) {

          if (c.done) continue;

          // Push remote commands to the remote list...
          if ((!c.r) && c.radio) {
            chRadio = c.radio; // NOTE! There is only one channel in this function
            remoteCmdList.push(this._wrapRemoteCmd(c));
          } else {
            // console.log(c);
            p = createPromise(p, c);
            cnt++;
          }
        }

        if (remoteCmdList.length) {
          chRadio.send(channelID, remoteCmdList);
        }

        p.then(function() {
          myPromise.resolve(true);
        }).fail(function(m) {
          console.error("*** _stepCommandList failed " + m);
        });
        //#ifdef DEBUG

        //#endif

        // here you could push the code into debug data, if not the production release...
        myPromise.then(function() {
          _cmdPoints.currentMainPromise = null;
          _cmdPoints.currentPromise = null;
          // console.log(" --- end --- all "+cnt+" commands resolved for "+channelID);

          if (_cmdPoints.waitingList.length) {
            // console.log("shifting a new promise");
            var newFirst = _cmdPoints.waitingList.shift();
            newFirst.resolve(true);
          }
        });

        if (bAddWaiting) {
          _cmdPoints.waitingList.push(first);
          first.then(function() {
            _cmdPoints.currentMainPromise = myPromise;
          });
        } else {
          _cmdPoints.currentMainPromise = myPromise;
          first.resolve(true);
        }

        return myPromise;


      }
      _myTrait_._wrapRemoteCmd = function(cmd) {

        var ctx;

        if (cmd.ctx) {
          if (this.isObject(cmd.ctx)) {
            ctx = cmd.ctx;
          } else {
            ctx = this._createContextVar(cmd.ctx);
          }
        }
        cmd.cmd = this._transformCmdFromNs(cmd.cmd.slice());
        return {
          ctx: ctx,
          cmd: cmd.cmd
        };
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {


        if (!_commands) {
          _commands = {};
          _cmdPoints = {};
          _channelLoops = {};

        }

      });
    }(this));;
    (function(_myTrait_) {
      var _commands;
      var _objectCache;
      var _cmdIndex;
      var _lastCmdId;
      var _lastCmdVals;
      var _objSetValCmds;
      var _commandListener;
      var _isRemoteUpdate;
      var _hotObjects;
      var _hotSettings;
      var _hotDocs;
      var _incomingDataFn;
      _myTrait_.createForkedObject = function(obj, theParent) {
        if (!this.isObject(obj) && (!this.isArray(obj))) return obj;

        var plain;

        if (this.isArray(obj.data)) {
          plain = [];
        } else {
          plain = {};
        }

        // create the new container object...
        var newObj = {
          data: plain,
          __id: this.guid(),
          __fork: obj.__id
        }

        if (theParent) {
          newObj.__p = theParent.__id;
        } else {
          if (obj.__radioURL) {
            newObj.__forkURL = obj.__radioURL;
          }
        }

        if (this.isArray(obj.data)) {
          var len = obj.data.length;
          for (var i = 0; i < len; i++) {
            plain[i] = this.createForkedObject(obj.data[i], newObj);
          }
        } else {
          for (var n in obj.data) {
            if (obj.data.hasOwnProperty(n)) {
              plain[n] = this.createForkedObject(obj.data[n], newObj);
            }
          }
        }


        return newObj;
      }
      _myTrait_.fork = function(obj) {

        // 
      }
    }(this));;
    (function(_myTrait_) {
      var _objectHash;
      var _eventListeners;
      var _workers;
      var _modelViews;
      var _hasRemoted;
      var _templateCompiler;
      var _valueBinded;
      var _namedModels;
      var _instanceCache;
      var _channelCommands;
      var _commandsIn;
      var _commandsOut;
      var _cmdPoints;
      var _commands;
      _myTrait_._addModelView = function(modelId, view, notUsed) {

        if (!_modelViews)
          _modelViews = {};
        if (!_modelViews[modelId])
          _modelViews[modelId] = [];

        _modelViews[modelId].push(view);
      }
      _myTrait_._addToCache = function(data) {

        if (data && data.__id) {
          _objectHash[data.__id] = data;
        }
      }
      _myTrait_._changeToRemote = function(obj, remoteURL, remoteID) {

        if (obj) {
          console.log("change to remote called " + remoteURL);
          var loaderPromise = _promise();

          var alreadyLoaded = _docUp()._find(remoteID);
          var me = this;

          if (alreadyLoaded) {

            var refP = me._createReflection(alreadyLoaded, remoteURL, obj);

            refP.then(function(ref) {

              console.log("reflection done");

              obj.data = ref.data;

              if (ref.__vpid) obj.__vpid = ref.__vpid;
              if (ref.__vcid) obj.__vcid = ref.__vcid;

              loaderPromise.resolve(alreadyLoaded);
            });
            return loaderPromise;

          }

          var myDataLoader = _docUp(remoteURL, {});


          console.log("starting loader ");

          // Loading the data and after thet
          myDataLoader.then(function() {
            console.log("finished loader ");

            // This is the original object
            var origObj = myDataLoader._find(remoteID);
            if (origObj) {

              console.log("Remote data ");
              console.log(JSON.parse(JSON.stringify(origObj)));

              console.log("creating reflection ");

              var refP = me._createReflection(origObj, remoteURL, obj);

              refP.then(function(ref) {

                console.log("reflection done");

                obj.data = ref.data;

                if (ref.__vpid) obj.__vpid = ref.__vpid;
                if (ref.__vcid) obj.__vcid = ref.__vcid;

                loaderPromise.resolve(origObj);
              });

            } else {
              console.error(" did not find " + remoteURL + "/" + remoteID);
              loaderPromise.fail(" did not find " + remoteURL + "/" + remoteID);
            }


          });
          return loaderPromise;
        }
      }
      if (!_myTrait_.hasOwnProperty('__factoryClass')) _myTrait_.__factoryClass = []
      _myTrait_.__factoryClass.push(function(data) {

        if (!this.isObject(data)) {
          if (data) {
            var o;
            if (o = this._myClassCache(data)) {
              return o;
            }
            this._myClassCache(data, this);
          }
        } else {
          /*
    if(data && data.__radioURL) {
        var o;
        if(o = this._myClassCache( data.__radioURL )) {
            return o;
        }
        this._myClassCache( data.__radioURL, this );        
    }*/
        }
      });
      _myTrait_._clearWorkers = function(view) {
        var me = this;

        //console.log("at _clearWorkers ");

        view.workers.forEach(function(ww) {
          //    console.log("calling _removeWorker ");
          me._removeWorker(ww);
        })

        view.childViews.forEach(function(ww) {
          //    console.log("calling child views _clearWorkers ", ww);
          me._clearWorkers(ww);
        });
      }
      _myTrait_._cmd = function(cmd, obj, targetObj) {


        // console.log("Got _cmd", cmd);

        // var testCommand = [4, 'cx', 30,20, '8vsngfc0rpe3i4wsoy63ydwxht']; 

        // Push object:
        // var pushCmd = [7, 3, '<insertedObjectId>', null, <parentGUID>]; 

        var objid = cmd[4],
          w = _workers;

        if (!obj) obj = this._find(objid);

        if (w && obj) {
          var ww;
          if (ww = w[objid]) {

            // property change, for example obj.x = 30
            if (cmd[0] == 4 || (cmd[0] == 13)) {
              var list;
              if (list = ww[cmd[1]]) {
                list = list.slice();
                var len = list.length;
                for (var i = 0; i < len; i++) {
                  var worker = list[i][0],
                    target = list[i][1],
                    propN = list[i][2];
                  worker.run(cmd, obj, target, propN);
                }
              }
              // if listening to changes to all variables
              if (list = ww["*"]) {
                list = list.slice();
                var len = list.length;
                for (var i = 0; i < len; i++) {
                  var worker = list[i][0],
                    target = list[i][1],
                    propN = list[i][2];
                  worker.run(cmd, obj, target, propN);
                }
              }
            }

            // is the "*" as the array modifications tag???
            if (cmd[0] == 12 || cmd[0] == 7 || cmd[0] == 8) {
              var list;
              if (list = ww["*"]) {
                list = list.slice();
                var len = list.length;
                for (var i = 0; i < len; i++) {
                  var worker = list[i][0],
                    target = list[i][1],
                    propN = list[i][2];

                  // IF there is array observer then it will be called...
                  // cmd = [...]
                  // targetObj = dataItem to be inserted
                  // target = information about the list
                  // obj = parent object id...
                  worker.run(cmd, targetObj, target, obj, propN);
                }
              }
            }
          }
        }

        /***********************************************
         * Design consideration: should the array commands to be set into different
         * variable than the _workers current
         *
         *   _workers[<objid>][<propertyid>]
         *
         * The property idea is to connect "x" => to some DOM elements attribute or
         * other kind of detail with a simple array
         *
         * _workers[<objid>][<propertyid>] =  [worker, target, targetProp]
         *
         * However, the array is slightly different, the commands are more like funtions
         *
         * _functionWorkers[objid]["arraycmd"] => execute the moveup, movedown
         *
         * It could also be something like
         *
         * _workers[objid][".functionName"]
         *
         * up._createWorker( objid, "*", ... array worker ... );
         *
         * OR....
         *
         * _workers[objid][4][cx] =>
         * _workers[objid][12] => run...
         *
         */
      }
      _myTrait_._createModelCommands = function(obj, parentObj, intoList) {

        /*
               _cmdIndex = {}; 
               _cmdIndex["createObject"] = 1;
               _cmdIndex["createArray"]  = 2;
               _cmdIndex["initProp"]  = 3;
               _cmdIndex["set"]  = 4;
               _cmdIndex["setMember"]  = 5;
               _cmdIndex["push"]  = 6;
               _cmdIndex["pushObj"]  = 7;
               _cmdIndex["removeItem"]  = 8;
               
               // reserved 9 for optimizations
               _cmdIndex["last"]  = 9;
               
               _cmdIndex["removeProperty"]  = 10;
               _cmdIndex["insertObjectAt"]  = 11;
               _cmdIndex["moveToIndex"]  = 12;
           */

        if (!intoList) intoList = [];

        var data;

        if (obj.data && obj.__id) {
          data = obj.data;
        } else {
          data = obj;
        }

        if (this.isObject(data) || this.isArray(data)) {

          var newObj;

          if (obj.__id) {
            newObj = obj;
          } else {
            newObj = {
              data: data,
              __id: this.guid()
            }
          }

          if (this.isArray(data)) {
            var cmd = [2, newObj.__id, [], null, newObj.__id];
          } else {
            var cmd = [1, newObj.__id, {},
              null, newObj.__id
            ];
          }
          if (parentObj) {
            newObj.__p = parentObj.__id;
            // this._moveCmdListToParent( newObj );
          }
          intoList.push(cmd);

          // Then, check for the member variables...
          for (var n in data) {
            if (data.hasOwnProperty(n)) {
              var value = data[n];
              if (this.isObject(value) || this.isArray(value)) {
                // Then create a new...
                var oo = this._createModelCommands(value, newObj, intoList);
                var cmd = [5, n, oo.__id, null, newObj.__id];
                intoList.push(cmd);
              } else {
                var cmd = [4, n, value, null, newObj.__id];
                intoList.push(cmd);
              }
            }
          }

          return newObj;
        } else {

        }



        /*
           var newObj = {
               data : data,
               __id : this.guid()
           }
           */
      }
      _myTrait_._createNewModel = function(data, parentObj) {

        /*
               _cmdIndex = {}; 
               _cmdIndex["createObject"] = 1;
               _cmdIndex["createArray"]  = 2;
               _cmdIndex["initProp"]  = 3;
               _cmdIndex["set"]  = 4;
               _cmdIndex["setMember"]  = 5;
               _cmdIndex["push"]  = 6;
               _cmdIndex["pushObj"]  = 7;
               _cmdIndex["removeItem"]  = 8;
               
               // reserved 9 for optimizations
               _cmdIndex["last"]  = 9;
               
               _cmdIndex["removeProperty"]  = 10;
               _cmdIndex["insertObjectAt"]  = 11;
               _cmdIndex["moveToIndex"]  = 12;
           */

        if (this.isObject(data) || this.isArray(data)) {

          var newObj = {
            data: data,
            __id: this.guid()
          }

          _objectHash[newObj.__id] = newObj;

          if (this.isArray(data)) {
            var cmd = [2, newObj.__id, [], null, newObj.__id];
          } else {
            var cmd = [1, newObj.__id, {},
              null, newObj.__id
            ];
          }

          if (parentObj) {
            newObj.__p = parentObj.__id;
            // this._moveCmdListToParent( newObj );
          }
          this.writeCommand(cmd, newObj);

          // Then, check for the member variables...
          for (var n in data) {
            if (data.hasOwnProperty(n)) {
              var value = data[n];
              if (this.isObject(value) || this.isArray(value)) {
                // Then create a new...
                var oo = this._createNewModel(value, newObj);
                newObj.data[n] = oo;
                var cmd = [5, n, oo.__id, null, newObj.__id];
                this.writeCommand(cmd, newObj);
                this._moveCmdListToParent(oo);
              } else {
                var cmd = [4, n, value, null, newObj.__id];
                this.writeCommand(cmd, newObj);
              }
            }
          }

          return newObj;

        } else {

        }


        /*
           var newObj = {
               data : data,
               __id : this.guid()
           }
           */
      }
      _myTrait_._createReflection = function(data, radioURL, useObj) {


        var refObj,
          refPromise = _promise(),
          me = this,
          refList = [];

        if (!radioURL && data.__radioURL && data.__rid) {
          // we should load the data first if the object does not exist
          var o = me._find(data.__rid);
          if (o) {
            // the object has been loaded, no need to create loader
          } else {
            var loader = _docUp(data.__radioURL);
            loader.then(function() {
              var p = me._createReflection(data, radioURL, useObj);
              p.then(function(refData) {
                refPromise.resolve(refData);
              });
            });
            return refPromise;
          }
        }

        // at this point we should have the data available...

        if (useObj) {
          refObj = useObj;
          if (data.__rid) {
            refObj.__rid = data.__rid;
          } else {
            refObj.__rid = data.__id;
          }

          // if data has virtual parent id, use it
          if (useObj.__vpid) {
            refObj.__vpid = useObj.__vpid;
            refObj.__vcid = useObj.__vcid;
          } else {
            refObj.__vpid = useObj.__p;
            refObj.__vcid = useObj.__id;
          }

        } else {
          refObj = {
            __id: this.guid(),
            __rid: data.__id,
            __radioURL: radioURL
          }
          if (data.__rid) {
            refObj.__rid = data.__rid;
          }
        }

        // if data has virtual parent id, use it
        if (data.__vpid) {
          refObj.__vpid = data.__vpid;
          refObj.__vcid = data.__vcid;
        }


        // register to the memory
        if (data.__rid) {
          this._addReflection(refObj.__rid, refObj.__id);
        } else {
          this._addReflection(refObj.__rid, refObj.__id);
        }

        // in case the object with __vcid is removed...
        if (refObj.__vcid) {
          this._addReflection(refObj.__vcid, refObj.__id);
        }

        _objectHash[refObj.__id] = refObj;

        if (radioURL) refObj.__radioURL = radioURL;
        if (data.__radioURL) refObj.__radioURL = data.__radioURL;

        if (this.isArray(data.data)) {
          refObj.data = [];
          var len = data.data.length;
          for (var i = 0; i < len; i++) {
            var v = data.data[i];
            if (this.isObject(v)) {
              var rp = this._createReflection(v);
              refList.push(rp);
              (function(i) {
                rp.then(function(refData) {
                  refObj.data[i] = refData;
                  refObj.data[i].__p = refObj.__id;
                });
              }(i));
            } else {
              refObj.data[i] = v;
            }

          }
        } else {
          refObj.data = {};
          for (var n in data.data) {
            if (data.data.hasOwnProperty(n)) {
              var v = data.data[n];
              if (this.isObject(v)) {
                var rp = this._createReflection(v);
                refList.push(rp);
                (function(n) {
                  rp.then(function(refData) {
                    refObj.data[n] = refData;
                    refObj.data[n].__p = refObj.__id;
                  });
                }(n));
              } else {
                refObj.data[n] = v;
              }
            }
          }
        }

        if (refList.length) {
          var s = _promise();
          s.all(refList).then(function() {
            refPromise.resolve(refObj);
          });
          s.resolve(true);
        } else {
          refPromise.resolve(refObj);
        }

        return refPromise;
      }
      _myTrait_._createWorker = function(objid, prop, worker, target, targetProp) {

        // console.log("**** called create workers ****");

        // ARRAY Worker:
        // m._createWorker( dataItem.__id, "*", <arrayWorker>, view, ???? );

        var a = _workers[objid];
        if (!a) {
          a = _workers[objid] = {};
        }
        var b = a[prop];
        if (!b) {
          b = _workers[objid][prop] = [];
        }
        var wDef = [worker, target, targetProp];
        b.push(wDef);

        // this is quite important, worker definition is 
        // 1. array of the objectid + property workers...
        // 2. the actual worker definition array with semantics
        // TODO: how to actually remove a worker using this def???

        return [b, wDef];

      }
      _myTrait_._emitEvent = function(objid, eventName, eventData) {

        var obj = _objectHash[objid];

        // console.log("emit", objid, eventName, eventData);

        if (obj) {

          // console.log("Found object to be emitted", obj);    
          // 
          var ev;
          if (_eventListeners && (ev = _eventListeners[objid])) {
            // console.log("The object had event listeners!!!");
            if (ev[eventName]) {
              ev[eventName].forEach(function(fn) {
                fn(eventData);
              });
            }
          }

          if (obj.__p) {
            this._emitEvent(obj.__p, eventName, eventData);
          } else {
            console.log("did not find the parent object...");
            if (eventName == "change" && !_eventListeners[objid]) {
              console.log("Might trigger the change for this object");
              if (obj.__rid) {
                console.log("it was also reflected object");
                console.log(obj);
                console.log(eventData);
                this.execCommand(eventData);
              }
            }
            // console.log("Found a parent object");
            // console.log(obj);
          }

          // Listeners for the object...

        }
      }
      _myTrait_._find = function(id) {


        return _objectHash[id];
      }
      _myTrait_._findObjects = function(data, parentId, whenReady) {

        var myPromise = _promise();

        if (!this.isObject(data)) {
          myPromise.resolve(data);
          return myPromise;
        }
        //     myPromise = _promise();

        data = this._wrapData(data);
        if (data.__id) {
          _objectHash[data.__id] = data;
        }

        var me = this;

        // the data has a remote ID, 
        if (data.__rid && data.__radioURL) {

          var myDataLoader = _docUp(data.__radioURL, {});
          var me = this;
          // Loading the data and after thet
          myDataLoader.then(function() {
            // console.log("%c *** find is looking at "+data.__radioURL+" ***", "background:cyan; ");
            var origObj = myDataLoader._find(data.__rid);
            if (origObj) {
              //console.log("%c *** should start reflecting "+data.__radioURL+" ***", "background:blue;color:white;");
              // creating the reflection of this object here...
              var refP = me._createReflection(origObj, data.__radioURL, data);
              refP.then(function(ref) {

                // console.log("%c *** reflection promise returned "+data.__radioURL+" ***", "background:blue;color:white;");

                data.__p = parentId; // virtual parent
                _objectHash[data.__id] = data;
                // The data has been loaded...
                myPromise.resolve(data);
              });

            } else {
              // console.error(" *** could not resolve the remote data from "+data.__radioURL+" ***", "background:red;color:white;");
              myPromise.resolve(data);
            }

          });

          return myPromise;
        }

        // setting the parentid for the object
        if (parentId) {
          data.__p = parentId;
        }

        var subPromises = [];

        if (data.data) {
          var sub = data.data;
          for (var n in sub) {
            if (sub.hasOwnProperty(n)) {
              var p = sub[n];
              if (this.isObject(p)) {
                var subP = this._findObjects(p, data.__id);
                subPromises.push(subP);
                (function(n, p) {
                  subP.then(function(newData) {
                    if (newData !== p) {
                      data.data[n] = newData;
                    }
                  });
                }(n, p))
              }
            }
          }
        }
        if (subPromises.length) {
          //console.log("%c ***waitinf for s.all *** "+data.__id, "backgorund:blue");
          var s = _promise();
          s.all(subPromises).then(function() {
            //console.log("%c *** s.all returned *** "+data.__id, "backgorund:cyan");
            //console.log("%c *** s.all returned *** "+data.__id, "backgorund:cyan");
            myPromise.resolve(data);
          });
          s.resolve(true);
        } else {
          myPromise.resolve(data);
        }

        return myPromise;
      }
      _myTrait_._findObjects2 = function(t) {

        if (!this.isObject(data)) {
          if (whenReady) whenReady.resolve(data);
          return data;
        }
        //     myPromise = _promise();

        data = this._wrapData(data);

        if (data.__id) {
          _objectHash[data.__id] = data;
        }

        var me = this;


        // the data has a remote ID, 
        if (data.__rid && data.__radioURL) {

          console.log("_findObjects with ", data);

          var myDataLoader = _docUp(data.__radioURL, {});
          var me = this;
          // me._unresolved.push(myDataLoader);

          // may cause system halt... problem!!!!
          if (!me._waitingPromises) me._waitingPromises = [];
          me._waitingPromises.push(myDataLoader)

          // Loading the data and after thet
          myDataLoader.then(function() {

            console.log("Finding ", data.__rid);
            // This is the original object
            var origObj = myDataLoader._find(data.__rid);
            if (origObj) {
              console.log("Creating reflection ", origObj, data.__radioURL, data);

              var ref = me._createReflection(origObj, data.__radioURL, data);

              console.log(ref);

              //data.data = ref.data;
              //data.__rid = ref.__rid;
              //data.__id = ref.__id;  

              // *** adding the parent link may cause problems ***
              data.__p = parentId; // virtual parent

              _objectHash[data.__id] = data;
              var i = me._unresolved.indexOf(myDataLoader);
              me._unresolved.splice(i, 1);
              if (me._unresolved.length == 0 && (me._waitingPromises.length == 0)) {
                // if we are ready...
                console.log("**** unresolved == 0 ****, resolving this ");
                me.resolve(me._data);
              }

            }

          });

          return data;
        }

        if (data.__virtual) {
          //console.log("***** found virtual data ******");
          //console.log(data.__radioURL);
          // Here it is now...
          var myDataLoader = _docUp(data.__radioURL, {});

          var me = this;
          me._unresolved.push(myDataLoader);

          // Loading the data and after thet
          myDataLoader.then(function() {
            console.log("Got remote data");
            console.log(myDataLoader);
            data.data = myDataLoader._data.data;
            data.__radio = myDataLoader._data.__radio;
            data.__id = myDataLoader._data.__id; // This is quite important perhaps here???
            _objectHash[data.__id] = data;
            var i = me._unresolved.indexOf(myDataLoader);
            me._unresolved.splice(i, 1);
            if (me._unresolved.length == 0) {
              // if we are ready...
              me.resolve(me._data);
            }
          });

          return data;


          // We should be getting a new docup object...
          // this._unresolved.push(); // something

        }

        // setting the parentid for the object
        if (parentId) {
          data.__p = parentId;
        }

        if (data.data) {
          var sub = data.data;
          for (var n in sub) {
            if (sub.hasOwnProperty(n)) {
              var p = sub[n];
              if (this.isObject(p)) {
                var newData = this._findObjects(p, data.__id);
                if (newData !== p) {
                  data.data[n] = newData;
                }
              }
            }
          }
        }
        return data;
      }
      _myTrait_._findRadioURL = function(o) {
        if (!o) o = this._data;

        while (0 && !o.__radioURL) {
          o = this._find(o.__p);
        }

        if (o && o.__radioURL) return o.__radioURL;
      }
      _myTrait_._getAllWorkers = function(t) {


        return _workers;
      }
      _myTrait_._getChannelCommands = function(url) {

        if (_channelCommands) {
          return _channelCommands[url];
        }
      }
      _myTrait_._getCommandsFor = function(channelId) {

      }
      _myTrait_._getModelViews = function(id) {

        return _modelViews[id];
      }
      _myTrait_._getObjectHash = function(t) {
        return _objectHash;
      }
      _myTrait_._getObjectInPath = function(path, data) {

        if (!path) return;

        var arr = path.split("/");
        if (!data) data = this._data;


        // children

        var lastObj = data,
          lastName = path;

        this._lastQueryObj = lastObj;
        this._lastQueryVar = lastName;

        while (arr.length > 0) {
          var pathName = arr.shift();
          if (pathName.length == 0) break;

          if (data.data) {

            // Then we go to the parent model...
            if (pathName == "..") {
              var pObj = this._find(data.__p);
              if (pObj) {
                data = pObj;
                lastObj = data;
                continue;
              } else {
                return;
              }
            }

            var sub = data.data[pathName];
            if (this.isObject(sub)) lastObj = sub;
            if (sub) {
              lastName = pathName;
              data = sub;
              continue;
            } else {
              return;
            }
          }
        }

        this._lastQueryObj = lastObj;
        this._lastQueryVar = lastName;

        if (this.isObject(data)) return data;

        return data;
      }
      _myTrait_._iterate = function(name) {

      }
      _myTrait_._myClassCache = function(url, obj) {

        if (!_instanceCache) _instanceCache = {};

        if (typeof(obj) == "undefined") {
          return _instanceCache[url];
        }

        _instanceCache[url] = obj;
      }
      _myTrait_._onValue = function(objid, eventName, callbackFn) {

        var list;

        if (!_eventListeners) _eventListeners = {};
        if (!_eventListeners[objid])
          _eventListeners[objid] = {};
        if (!_eventListeners[objid][eventName]) {
          _eventListeners[objid][eventName] = [];
        }

        list = _eventListeners[objid][eventName];

        // ...
        if (list.indexOf(callbackFn) < 0) {
          list.push(callbackFn);
          // Listeners for the object...

        }
      }
      _myTrait_._prepareData = function(data) {


        var d = this._wrapData(data);

        if (!_objectHash[d.__id]) {
          // it is a new object that should be added to the current model...
          d = this._findObjects(d);
        }

        return d;
      }
      _myTrait_._removeView = function(viewDef) {

        var dom = viewDef.dom;

        console.log("_removeView called ");

        if (dom.parentNode) {
          dom.parentNode.removeChild(dom);
        }

        var parent;
        if (parent = viewDef.parentView) {
          var i = parent.childViews.indexOf(viewDef);
          parent.childViews.splice(i, 1);
        }

        console.log("calling _clearWorkers ");
        this._clearWorkers(viewDef);
      }
      _myTrait_._removeWorker = function(wDefArray) {

        // var wDef = [worker, target, targetProp];
        // b.push(wDef);
        // return [b, wDef];

        if (!wDefArray) return;

        var b = wDefArray[0],
          wDef = wDefArray[1];

        if (!b || !wDef) return;

        var i = b.indexOf(wDef);
        if (i >= 0) b.splice(i, 1);

      }
      _myTrait_._triggerEvent = function(objId, eventName, eventData) {

        var obj = _objectHash[objid];

        if (obj) {


        }
      }
      _myTrait_._wrapData = function(data, parent) {

        // if instance of this object...
        if (data && data._wrapData) {
          // we can use the same pointer to this data
          return data._data;
        }

        // if the data is "well formed"
        if (data.__id && data.data) return data;

        // if new data, then we must create a new object and return it

        var newObj = this._createNewModel(data);
        /*
           var newObj = {
               data : data,
               __id : this.guid()
           }
           */
        return newObj;
      }
      _myTrait_.duplicate = function(obj) {

        var p = this.toPlainData(obj);

        var up = _docUp(p);

        return up.getData();
      }
      _myTrait_.fetch = function(str, baseData) {

        var o = this._getObjectInPath(str, baseData);

        if (o) return o;
      }
      _myTrait_.findNamedView = function(name) {

        if (!_templateCompiler) _templateCompiler = templateCompiler();

        return _templateCompiler._getNamedView(name);
      }
      _myTrait_.forTree = function(data, fn) {

        if (this.isFunction(data)) {
          fn = data;
          data = this._data;
        } else {
          if (this.isObject(data) && this.isFunction(fn)) {

          } else {
            return;
          }
        }

        fn(data);

        if (data.data) {
          var sub = data.data;
          for (var n in sub) {
            if (sub.hasOwnProperty(n)) {
              var p = sub[n];
              if (this.isObject(p)) {
                this.forTree(p, fn);
              }
            }
          }
        }

        return this;
      }
      _myTrait_.getData = function(t) {


        return this._data;
      }
      _myTrait_.getMeta = function(obj, name) {



        if (this.isObject(obj)) {

          if (!obj.__meta) {
            return;
          }

          var dd = obj.__meta[name];

          if (dd) {
            var mo = _docUp(dd);
            return mo.getData();
          }

        }
      }
      _myTrait_.getNamedModel = function(name) {

        if (_namedModels) return _namedModels[name];
      }
      _myTrait_.getNamedViews = function(t) {

        if (_templateCompiler) {
          return _templateCompiler._getNamedViews();
        }
      }
      _myTrait_.indexOf = function(item) {

        if (!item) item = this._data;

        if (!this.isObject(item)) {
          item = this._find(item);
        }
        if (!item) return;

        var parent = this._find(item.__p);

        if (!parent) return;
        if (!this.isArray(parent.data)) return;

        return parent.data.indexOf(item);

      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(data, options) {

        // which object hash has the data...10.000 object hashes, there might be
        // some problems to re-allocate the objects if they are not directly placed
        // under the correct hash...???

        if (!this._unresolved)
          this._unresolved = [];

        if (!_objectHash) {
          _objectHash = {};
          _workers = {};
        }

        var me = this;

        // Fetching the remote objects inside the object tree is a bit more difficult opertaion than
        // originally though...
        var bRemote = false;
        if (data && !this.isObject(data) && (data.substring(0, 7) == "http://")) {

          console.log("##### Fetching data from ", data);

          var myUrl = data;

          var chOptions = {
            onCommand: function(cmd, ctx) {

              cmd = me._transformCmdToNs(cmd, me._getNsFromUrl(myUrl));
              me._pushChannelCommand(myUrl, cmd, ctx, true);
            },
            onFile: function(remoteData, changeList, url) {

              console.log("---- ON FILE ---- ");

              // Try conversion to the namespaces
              remoteData = me._transformObjToNs(remoteData, me._getNsFromUrl(url));
              me._data = remoteData;

              // find objects is run here so that the commands can find their targets
              var findPromise = me._findObjects(remoteData);
              findPromise.then(
                function(d) {

                  //console.log("%c ======= FIND PROMISE DID RETURN!!!!! ====== "+myUrl, "background:yellow;");
                  //console.log(d);

                  if (me._data != d) {
                    me._data = d;
                  }
                  if (changeList && changeList.length) {

                    changeList.forEach(function(cmd) {
                      cmd = me._transformCmdToNs(cmd, me._getNsFromUrl(url));
                      me._pushChannelCommand(url, cmd, {}, true);
                    });

                    var p = me._stepCommandList(url);
                    if (p) {
                      p.then(function() {

                        me._data.__radioURL = data;
                        me._data.__radio = radio;

                        me._startChannelLoop(me._data.__radioURL);
                        me.resolve(me._data);
                      })
                        .fail(function() {

                        });
                    } else {

                    }
                  } else {
                    me._data.__radioURL = data;
                    me._data.__radio = radio;

                    if (me._data._cmdList) delete me._data._cmdList;
                    if (me._data._ctxCmdList) delete me._data._ctxCmdList;

                    me._startChannelLoop(me._data.__radioURL);
                    me.resolve(me._data);

                  }

                }
              )
                .fail(function(m) {
                  console.error("Failed for " + data);
                  console.error(m);
                });

              // bind for the _emitEvent "change" signal here... 
              if (!_valueBinded) _valueBinded = {};
              if (!_valueBinded[me._data.__id]) {
                _valueBinded[me._data.__id] = true;
                me.onValue(function(v) {
                  me.execCommand(v);
                });
              }

            }
          };

          if (options && this.isObject(options) && options.createWith) {
            chOptions.createWith = options.createWith;
          }
          if (options && this.isObject(options) && options.dataNS) {
            chOptions.dataNS = options.dataNS;
          }
          var radio = docRadio(),
            me = this;
          radio.listen(data, chOptions);

          return;
        }

        // Just testing this...
        // var remoteUrls = this.loadRemoteUrls();
        // console.log("Loading remote urls from the tpl");
        // onsole.log(remoteUrls);

        if (!data) {
          return;
        }

        this._data = data;


        var findPr = this._findObjects(data);

        findPr.then(
          function(d) {
            if (data != d) {
              me._data = d;
            }
            if (me._data) {
              if (!_valueBinded) _valueBinded = {};
              if (!_valueBinded[me._data.__id]) {
                _valueBinded[me._data.__id] = true;
                me.onValue(function(v) {
                  console.log("onValue ", JSON.stringify(v));
                  me.execCommand(v);
                });
              }
            }
            me.resolve(me._data);
          });

      });
      _myTrait_.listNamedModels = function(t) {

        return _namedModels;
      }
      _myTrait_.loadRemoteData = function(channel) {


        var s = _connectManager().createSocketServer({
          ip: channel.ip,
          port: channel.port
        });

        var me = this;

        // connecting to the selected file...
        var ch = s.createChannel(channel);
        ch.then(function() {
          ch.getFileData(function(remoteData, changeList) {

            me._data = remoteData;
            var d = me._findObjects(remoteData);
            if (me._data != d) {
              this._data = d;
            }
            if (changeList && changeList.length) {
              changeList.forEach(function(cmd) {
                me.execCommand(cmd, true);
              });
            }

            me.resolve(me._data);

            // TODO: think, might set the onChange here.... onValue( ... exec l... )

          });
        });
      }
      _myTrait_.loadRemoteUrls = function(t) {

        if (_hasRemoted) return _hasRemoted;

        _hasRemoted = true;

        var results = [];

        // just get all remote URL channels...
        var all = document.querySelectorAll("[data-src]");

        console.log("Data src list", all);

        for (var i = 0; i < all.length; i++) {
          var domWithData = all[i];

          var getTheFish = function(domWithData) {

            var url = domWithData.getAttribute("data-src");
            var reqData = this.parseRemoteUrl(url);
            results.push(reqData);

          }
          getTheFish(domWithData);
        }

        _hasRemoted = results;
        return results;
      }
      _myTrait_.moveItemDown = function(itemId) {
        var oldPos;

        var item = this._find(itemId);
        if (!item) return;

        var parent = this._find(item.__p);

        if (!parent) return;
        if (!this.isArray(parent.data)) return;

        oldPos = parent.data.indexOf(item);
        var newPos = oldPos - 1;
        var pLen = parent.data.length;
        if (newPos >= 0 && newPos < pLen) {
          this.execCommand([12, item.__id, newPos, oldPos, item.__p]);
        }

        // p.saveCommand("moveToIndex", myGUID, newPos, null );

        return this;
      }
      _myTrait_.moveItemToPos = function(itemId, newPos) {
        var oldPos;

        var item = this._find(itemId);
        if (!item) return;

        var parent = this._find(item.__p);

        if (!parent) return;
        if (!this.isArray(parent.data)) return;

        oldPos = parent.data.indexOf(item);

        var pLen = parent.data.length;
        if (newPos >= 0 && newPos < pLen) {
          this.execCommand([12, item.__id, newPos, oldPos, item.__p]);
        }

        return this;
      }
      _myTrait_.moveItemUp = function(itemId) {
        var oldPos;

        var item = this._find(itemId);
        if (!item) return;

        var parent = this._find(item.__p);

        if (!parent) return;
        if (!this.isArray(parent.data)) return;

        oldPos = parent.data.indexOf(item);
        var newPos = oldPos + 1;
        var pLen = parent.data.length;
        if (newPos >= 0 && newPos < pLen) {
          console.log("Got item up into ", newPos);
          this.execCommand([12, item.__id, newPos, oldPos, item.__p]);
        }

        // p.saveCommand("moveToIndex", myGUID, newPos, null );

        return this;
      }
      _myTrait_.onValue = function(objid, eventName, callbackFn) {

        if (this.isFunction(objid)) {
          if (this._data) {
            this._onValue(this._data.__id, "change", objid);
          }
          return this;
        }

        if (this.isFunction(eventName)) {
          if (this._data) {
            this._onValue(this._data.__id, objid, eventName);
          }
          return this;
        }

        return this._onValue(objid, eventName, callbackFn);
      }
      _myTrait_.parseRemoteUrl = function(url) {

        // console.log("Parsing ", url);        
        var parts1 = url.split("://");
        var protocol = parts1.shift(),
          rest = parts1.shift();
        var serverParts = rest.split("/"),
          ipAndPort = serverParts.shift(),
          iParts = ipAndPort.split(":"),
          ip = iParts[0],
          port = iParts[1],
          sandbox = serverParts.shift(),
          fileName = serverParts.pop(),
          path = serverParts.join("/");

        var reqData = {
          channel: {
            ip: ip,
            port: port,
            sandbox: sandbox,
            path: path,
            file: fileName,
            auth: {
              u: "abba",
              p: "nowp"
            }
          }
        };

        return reqData;
      }
      _myTrait_.push = function(path, newData, propName) {
        var me = this,
          myPromise = _promise();
        if (this.isObject(path) && this.isObject(path.data) && !this.isArray(path.data)) {
          var o = path;
          var tmpDoc = _docUp(newData);
          tmpDoc.then(function() {
            var data = tmpDoc._data;
            // tmpDoc._moveCmdListToParent( data );
            me.execCommand([5, propName, data.__id, null, o.__id]).then(function() {
              myPromise.resolve(true);
            });
            tmpDoc._moveCmdListToParent(data);
          });

          return myPromise;
        }

        if (this.isObject(path) && this.isArray(path.data)) {

          console.log("Pushing new object to array, about to create the obj");
          console.log("The new data is ", newData);
          var o = path;

          var tmpDoc = _docUp(newData);

          tmpDoc.then(function() {
            console.log("... got the new data from tmpDoc ");
            var data = tmpDoc._data;
            // tmpDoc._moveCmdListToParent( data );
            me.execCommand([7, o.data.length, data.__id, null, o.__id]).then(function() {
              myPromise.resolve(true);
            });
            tmpDoc._moveCmdListToParent(data);
          });

          return myPromise;
        }

        // console.log("Push ", path, newData, propName);

        var o = this._getObjectInPath(path);
        if (o) {
          if (this.isArray(o.data)) {

            var tmpDoc = _docUp(newData);
            tmpDoc.then(function() {
              var data = tmpDoc._data;
              // tmpDoc._moveCmdListToParent( data );
              me.execCommand([7, o.data.length, data.__id, null, o.__id]).then(function() {
                myPromise.resolve(true);
              });
              tmpDoc._moveCmdListToParent(data);
            });


          }
        }

        return myPromise;

      }
      _myTrait_.removeItem = function(itemId) {

        var o = this._find(itemId);
        console.log("removeItem", o);
        if (o && o.__id) {
          var p = this._find(o.__p);
          if (this.isObject(p) && this.isArray(p.data)) {
            // 8 = remove item from array
            /*
                       var parentObj = this._find( a[4] ),
                   removedItem = this._find( a[2] ),
                   */
            this.execCommand([8, 0, o.__id, null, p.__id]);

          }
        }
      }
      _myTrait_.render = function(withTemplate) {

        if (!_templateCompiler) {
          _templateCompiler = templateCompiler();
        }

        var comp = _templateCompiler, ///_getNamedViews
          me = this;

        // dkl2rb2foek7ft7xwxo2y8g33o

        var jsonTplData;

        if (this.isObject(withTemplate)) {
          jsonTplData = withTemplate;
        } else {
          jsonTplData = comp.compile(withTemplate);
        }

        var dd = comp.composeTemplate(me._data, jsonTplData);

        if (!_valueBinded) _valueBinded = {};

        if (!_valueBinded[me._data.__id]) {
          _valueBinded[me._data.__id] = true;
          me.onValue(function(v) {
            me.execCommand(v);
          });
        }

        return dd;
      }
      _myTrait_.renderFrom = function(url, path, varName, intoDOM) {

        var newDoc = _docUp(url),
          me = this;


        var loadTime2 = new Date();
        newDoc.then(
          function() {

            console.log("Got the DOC!");
            console.log(newDoc);

            // alert("Tpl load took "+ ( (new Date()).getTime()-(loadTime2.getTime()))+"ms");

            var pName = "";
            if (me.isFunction(path)) {
              pName = path();
            } else {
              pName = path;
            }

            var itemZero = newDoc.fetch(pName);

            // compiledTemplate

            var tplData;

            var bCompiled = false;

            // render using compiled template
            if (itemZero.data["compiledTemplate"]) {
              tplData = JSON.parse(itemZero.data["compiledTemplate"]);
              bCompiled = true;
            } else {
              tplData = itemZero.data[varName];
            }

            var loadTime = new Date();
            // Now, here is the channel for something, but what if we create a template channel to modify this data???
            var oldDom = me.render(tplData);

            if (intoDOM) {
              intoDOM.appendChild(oldDom);
            }

            // Not working really now... :/
            if (me.isFunction(path)) {
              path(function() {
                var pName = path();
                var itemZero = newDoc.fetch(pName);
                var html = itemZero.data[varName];

                var comp = templateCompiler();
                comp.clearTheView(oldDom.getAttribute("data-viewid"));
                var newDOM = me.render(html);
                if (oldDom.parentNode) {
                  oldDom.parentNode.replaceChild(newDOM, oldDom);
                  oldDom = newDOM;
                }
              });
            }

            // alert("Render took "+ ( (new Date()).getTime()-(loadTime.getTime()))+"ms");

            if (bCompiled) {

              newDoc.addListener(pName + ".compiledTemplate", function(a, html) {
                var comp = templateCompiler();
                comp.clearTheView(oldDom.getAttribute("data-viewid"));
                var newDOM = me.render(JSON.parse(html));
                if (oldDom.parentNode) {
                  oldDom.parentNode.replaceChild(newDOM, oldDom);
                  oldDom = newDOM;
                }
              });
            } else {
              newDoc.addListener(pName + "." + varName, function(a, html) {
                var comp = templateCompiler();
                comp.clearTheView(oldDom.getAttribute("data-viewid"));
                var newDOM = me.render(html);
                if (oldDom.parentNode) {
                  oldDom.parentNode.replaceChild(newDOM, oldDom);
                  oldDom = newDOM;
                }
              });
            }
          });
      }
      _myTrait_.set = function(obj, name, value) {

        // Now, try to implement here the setting of object property
        if (this.isObject(value)) {

          // load the document data and if necessary, creates also the commands required
          // to build the object, I suppose...
          var up = _docUp(value),
            me = this;
          up.then(function() {
            // loaded all items inside the object...
            var o = up.getData();

            console.log("set has now data ");
            console.log(o);

            // NOW, the data might be already set or there could be 
            // a member variable with the same name
            //   1. check if the object position is free
            //   2. check that the object does not have this data

            if (!obj.data[name] && (!o.__p)) {
              console.log("going to run the command now");
              console.log([5, name, o.__id, null, obj.__id]);
              // two very basic conditions seem to be now ok, lets go on
              me.execCommand([5, name, o.__id, null, obj.__id]);
            }


          })
            .fail(function(v) {
              console.log("creating the object failed ");
              console.log(v);
            })

        } else {

          // Executing the command to change the value...
          if (obj && obj.data && (obj.data[name] != value)) {
            var oldValue = obj.data[name];
            this.execCommand([4, name, value, oldValue, obj.__id]);
          }

        }

        return this;
      }
      _myTrait_.setMeta = function(intoObj, name, metaObj) {

        if (this.isObject(intoObj)) {

          if (!intoObj.__meta) {
            intoObj.__meta = {};
          }

          var mo = _docUp(metaObj);

          intoObj.__meta[name] = mo.getData();

        }
      }
      _myTrait_.setNamedModel = function(name, model) {


        if (!_namedModels) _namedModels = {};

        // TODO if overwriting a named model, you might as well update the views
        // that do correspond to this model...

        _namedModels[name] = model;
      }
      _myTrait_.toPlainData = function(obj) {

        if (!this.isObject(obj)) return obj;

        var plain;

        if (obj.getData) obj = obj.getData();

        if (this.isArray(obj.data)) {
          plain = [];
          var len = obj.data.length;
          for (var i = 0; i < len; i++) {
            plain[i] = this.toPlainData(obj.data[i]);
          }
        } else {
          plain = {};
          for (var n in obj.data) {
            if (obj.data.hasOwnProperty(n)) {
              plain[n] = this.toPlainData(obj.data[n]);
            }
          }
        }

        return plain;
      }
      _myTrait_.treeToList = function(fn, targetList) {

        var myList = _docUp({
          list: []
        });

        this.forTree(function(o) {
          if (fn(o)) {
            targetList.data.push(o);
          }
        });

        return targetList;
      }
      _myTrait_.unset = function(obj, propName) {

        if (!this.isObject(obj)) {
          obj = this._find(obj);
        }

        if (obj && obj.data && propName) {
          this.execCommand([10, propName, null, null, obj.__id]);
        }


        return this;
      }
    }(this));
  }
  _docUp_prototype.prototype = _promise.prototype
  var _docUp = function(a, b, c, d, e, f, g, h) {
    if (this instanceof _docUp) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != _docUp._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new _docUp(a, b, c, d, e, f, g, h);
  };
  _docUp._classInfo = {
    name: '_docUp'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_docUp", _docUp)
  _docUp.prototype = new _docUp_prototype();
  if (typeof(window) != 'undefined') window['_docUp'] = _docUp;
  if (typeof(window) != 'undefined') window['_docUp_prototype'] = _docUp_prototype;
  var simpleStream_prototype = function() {
    'use strict';
    var streamProcessor_prototype = function() {
      'use strict';;
      (function(_myTrait_) {
        _myTrait_.guid = function(t) {

          return Math.random().toString(36).substring(2, 15) +
            Math.random().toString(36).substring(2, 15);

        }
        _myTrait_.isArray = function(t) {

          if (typeof(t) == "undefined") return this.__isA;

          return Object.prototype.toString.call(t) === '[object Array]';
        }
        _myTrait_.isFunction = function(fn) {
          return Object.prototype.toString.call(fn) == '[object Function]';
        }
        _myTrait_.isObject = function(t) {

          if (typeof(t) == "undefined") return this.__isO;

          return t === Object(t);
        }
      }(this));;
      (function(_myTrait_) {
        _myTrait_.cont = function(withValue) {

          if (this.isArray(withValue)) {

            var me = this;
            var newList = this._list.slice(this._index + 1);

            if (newList.length == 0) {
              this.step();
              return;
            }

            var all = [];
            withValue.forEach(
              function(v) {
                var newList = me._list.slice(me._index + 1);
                var stream = simpleStream(me);
                stream.addObserver(newList);
                all.push(stream.pushValue(v));
              });

            var wait = _promise();
            wait.all(all).then(function() {
              var r = [];
              all.forEach(function(p) {
                r.push(p.value());
              });
              me.resolve(r);
            });
            wait.resolve(true);


          } else {

            if (typeof(withValue) != "undefined") {
              this._context.value = withValue;
            }

            this.step();

          }

        }
        _myTrait_.ctxVar = function(name, value) {

          if (typeof(value) == "undefined") {
            var v = this._contextVars[name];
            if (typeof(v) == "undefined") {
              if (this._parent) {
                return this._parent.ctxVar(name);
              }
            }
            return v;
          }

          this._contextVars[name] = value;


        }
        _myTrait_.get = function(name) {

          if (this._closure) {
            var v = this._contextVars[name];
            if (typeof(v) == "undefined") {
              return this._parent.get(name);
            }
            return v;
          }

          var v = this._contextVars[name];
          if (typeof(v) == "undefined") {
            if (this._parent) {
              return this._parent.get(name);
            }
          }
          return v;
        }
        _myTrait_.getRest = function(t) {

        }
        _myTrait_.getState = function(t) {


          return this._stopState;
        }
        _myTrait_.getValue = function(t) {

          // simple value processor

          if (!this._context && this._parent) {
            return this._parent.getValue();
          }

          if (this._context && !this._context.value && !this._context.initWith && this._parent) {
            return this._parent.getValue();
          }

          return this._context.value || this._context.initWith;
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(parentProcessor, isClosure) {

          // The context of the processor
          this._context = {};
          this._contextVars = {};

          this._stopState = 0;

          if (parentProcessor) {
            this._parent = parentProcessor;
          }

          if (isClosure) this._closure = true;



        });
        _myTrait_.run = function(withValue) {

          if (this._closure) {
            if (this._parent) {
              this._parent.run(withValue);
              return;
            } else {
              console.error("No parent for closure");
              console.trace();
            }
          }
          this._stopState = 1;
          this.cont(withValue);
          return;

        }
        _myTrait_.set = function(name, value) {
          if (typeof(value) != "undefined") {

            if (this._closure) {
              if (typeof(this._contextVars[name]) != "undefined") {
                this._contextVars[name] = value;
              } else {
                if (this._parent) {
                  this._parent.set(name, value);
                  return this;
                }
              }
            }

            if (typeof(this._contextVars[name]) == "undefined") {
              if (this._parent) {
                this._parent.set(name, value);
                return this;
              }
            }

            this._contextVars[name] = value;
            return this;
          }

        }
        _myTrait_.setContext = function(ctx) {
          this._context = ctx;
        }
        _myTrait_.setParent = function(newParent) {
          this._parent = newParent;
        }
        _myTrait_.start = function(list) {

          this._list = list;
          this._index = -1;

          this.step();

        }
        _myTrait_.step = function(t) {

          this._index++;
          var i = this._index,
            me = this;

          if (this._list[i]) {

            var obs = this._list[i];
            // Call the observer

            if (this.isObject(obs) && !this.isFunction(obs)) {

              if (obs.closure) {
                obs.closure.setParent(this);
                obs.fn(obs.closure);
              } else {
                // var ctx = streamProcessor()
                obs.fn(this);
              }
            } else {
              obs(this);
            }

          } else {
            if (typeof(this._context.value) == "undefined") {
              this._context.value = this._context.initWith;
            }
            if (this._stopState < 2) {
              this._stopState = 7;
            }
            this.resolve(this._context.value);
          }


        }
        _myTrait_.stopStream = function(t) {
          if (!this._context.value) {
            this._context.value = this._context.initWith;
          }
          this._stopState = 3;
          this.resolve(this._context.value);
        }
      }(this));
    }
    streamProcessor_prototype.prototype = _promise.prototype
    var streamProcessor = function(a, b, c, d, e, f, g, h) {
      if (this instanceof streamProcessor) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != streamProcessor._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new streamProcessor(a, b, c, d, e, f, g, h);
    };
    streamProcessor._classInfo = {
      name: 'streamProcessor'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("streamProcessor", streamProcessor)
    streamProcessor.prototype = new streamProcessor_prototype();
    if (typeof(window) != 'undefined') window['streamProcessor'] = streamProcessor;
    if (typeof(window) != 'undefined') window['streamProcessor_prototype'] = streamProcessor_prototype;;
    (function(_myTrait_) {
      _myTrait_.guid = function(t) {

        return Math.random().toString(36).substring(2, 15) +
          Math.random().toString(36).substring(2, 15);

      }
      _myTrait_.isArray = function(t) {

        if (typeof(t) == "undefined") return this.__isA;

        return Object.prototype.toString.call(t) === '[object Array]';
      }
      _myTrait_.isFunction = function(fn) {
        return Object.prototype.toString.call(fn) == '[object Function]';
      }
      _myTrait_.isObject = function(t) {

        if (typeof(t) == "undefined") return this.__isO;

        return t === Object(t);
      }
    }(this));;
    (function(_myTrait_) {
      var _streams;
      _myTrait_.addObserver = function(obs, closure) {

        if (this.isArray(obs)) {
          var m = this;
          obs.forEach(function(o) {
            m.addObserver(o, closure);
          })
          return;
        }

        if (this.isObject(obs) && !this.isFunction(obs)) {
          this._observers.push(obs);
          return;
        }

        // marching through the stream...
        // this._observers.push(obs);

        this._observers.push({
          fn: obs,
          closure: closure
        });

        return this;
      }
      _myTrait_.branch = function(fn, ms) {

        var me = this;
        var lastMs = (new Date()).getTime();

        me._lastBranch = lastMs;

        this.addObserver(function(m) {
          var nowTime = (new Date()).getTime(),
            value = m.getValue();
          setTimeout(function() {

            var currTime = (new Date()).getTime();
            if (currTime - lastMs < ms) return;

            var cnt = 0;
            if (cnt = me.isActiveRunning()) {
              return;
            }

            m = me.getLastProcess();
            if (m.getState() == 3) {
              me._lastBranch = currTime;
              lastMs = currTime;
              fn(value);
            }
          }, ms);
          m.run();
        });

        return this;
      }
      _myTrait_.branchIfOk = function(fn, ms) {

        var me = this;
        var lastMs = (new Date()).getTime();

        me._lastBranch = lastMs;

        this.addObserver(function(m) {
          var nowTime = (new Date()).getTime(),
            value = m.getValue();
          setTimeout(function() {
            var currTime = (new Date()).getTime();
            if (currTime - lastMs < ms) return;
            var cnt = 0;
            if (cnt = me.isActiveRunning()) {
              return;
            }
            m = me.getLastProcess();
            if (m.getState() == 7) {
              me._lastBranch = currTime;
              lastMs = currTime;
              fn(value);
            }
          }, ms);
          m.run();
        });
        return this;

      }
      _myTrait_.collectValuesFor = function(ms) {
        var me = this;
        var lastMs = (new Date()).getTime();

        me._lastBranch = lastMs;

        this.addObserver(function(m) {
          var nowTime = (new Date()).getTime(),
            value = m.getValue();

          setTimeout(function() {
            var currTime = (new Date()).getTime();

            if (currTime - lastMs < ms) return;

            var cnt = me.isActiveRunning();
            var lastProcess = me.getLastProcess();
            // stop if there is something in there...
            if (cnt > 1 && m != lastProcess) {
              m.stopStream(m.getValue()); // don't allow to go any further...
              return;
            }
            lastProcess.run(); // continue the process...
          }, ms);
          // m.run();
        });
        return this;
      }
      _myTrait_.combineLatest = function(streams, fn) {
        var me = this;

        var myRes = [],
          cnt = streams.length;

        var allHasValue = function() {
          var b = true;
          for (var i = 0; i < cnt; i++) {
            if (typeof(myRes[i]) == "undefined") b = false;
          }
          return b;
        }

        streams.forEach(function(s, index) {
          s.addObserver(function(myProcess) {
            myRes[index] = myProcess.getValue();
            if (allHasValue()) {
              me.pushValue(myRes);
            }
            myProcess.run();
          });
        });

        return this;

      }
      _myTrait_.filter = function(fn) {

        var me = this;

        this.addObserver(function(m) {
          var arr = m.getValue();
          var res = [];

          if (me.isArray(arr)) {
            arr.forEach(function(v) {
              if (fn(v)) res.push(v);
            });
          } else {
            if (fn(arr)) {
              m.run(arr);
              return;
            } else {
              m.stopStream();
            }
            return;
          }

          if (res.length) {
            m.run(res);
          } else {
            m.stopStream();
          }
        });

        return this;
      }
      _myTrait_.forContext = function(fn) {
        var me = this;
        me.addObserver(function(m) {
          var arr = m.getValue();
          var res = [];

          if (me.isArray(arr)) {
            arr.forEach(function(v, i) {
              res.push(fn(v, i, m));
            });
          } else {
            res.push(fn(arr, 0, m));
          }
          m.run(arr);
        });
      }
      _myTrait_.forEach = function(fn) {
        var me = this;
        me.addObserver(function(m) {
          var arr = m.getValue();
          var res = [];

          if (me.isArray(arr)) {
            arr.forEach(function(v) {
              res.push(fn(v));
            });
          } else {
            res.push(fn(arr));
          }
          m.run(arr);
        });
        return this;
      }
      _myTrait_.getLastProcess = function(t) {

        var i = this._active.length;
        if (i > 0) return this._active[i - 1];

        return this._lastProcess;
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(parentProcessor) {
        this._childIndex = 0;
        this._childStreams = [];
        this._values = [];
        this._active = [];

        this._lastProcess;

        // start these observers when a value arrives...
        this._observers = [];

        this._id = this.guid();
        if (!_streams) {
          _streams = {};
        }

        _streams[this._id] = this;

        if (parentProcessor) {
          this._parentProcessor = parentProcessor;
        }

      });
      _myTrait_.isActiveRunning = function(t) {
        return this._active.length;
      }
      _myTrait_.map = function(fn) {
        var me = this;
        me.addObserver(function(m) {
          var arr = m.getValue();
          var res = [];

          if (me.isArray(arr)) {
            arr.forEach(function(v) {
              res.push(fn(v));
            });
          } else {
            res.push(fn(arr));
          }
          m.run(res);
        });
        return this;
      }
      _myTrait_.pushValue = function(val) {


        var myProm = _promise();
        this.startProcess({
          initWith: val
        }, myProm);
        return myProm;
      }
      _myTrait_.reduce = function(fn, initWith) {
        var me = this;
        me.addObserver(function(m) {
          var arr = m.getValue();
          var res = [];

          if (me.isArray(arr)) {
            res = arr.reduce(fn, initWith);
          } else {
            res = [arr].reduce(fn, initWith);
          }
          m.run(res);
        });
        return this;
      }
      _myTrait_.startProcess = function(context, myProm) {


        // create copy of the observers...
        var list = this._observers.slice();

        var process = streamProcessor(this._parentProcessor);
        process.setContext(context);
        process.start(list);

        this._active.push(process);

        var me = this;
        // The process exits, all done...
        process.then(function(v) {
          // Should remove the process    
          var i = me._active.indexOf(process);
          me._active.splice(i, 1);
          myProm.resolve(v);
          me._lastProcess = process;
        });



      }
      _myTrait_.step = function(t) {

      }
    }(this));
  }
  var simpleStream = function(a, b, c, d, e, f, g, h) {
    if (this instanceof simpleStream) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != simpleStream._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new simpleStream(a, b, c, d, e, f, g, h);
  };
  simpleStream._classInfo = {
    name: 'simpleStream'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("simpleStream", simpleStream)
  simpleStream.prototype = new simpleStream_prototype();
  if (typeof(window) != 'undefined') window['simpleStream'] = simpleStream;
  if (typeof(window) != 'undefined') window['simpleStream_prototype'] = simpleStream_prototype;
  var _e_prototype = function() {
    'use strict';
    var _qc_prototype = function() {;
      (function(_myTrait_) {
        _myTrait_.attr = function(n, v) {

          if (this._host._svgElem) {


            if (this._host.isArray(v)) {

              // console.log("Taking array as ", v);

              var oo = v[0],
                fName = v[1],
                val = oo[fName](),
                me = this,
                domi = me._dom,
                host = this._host,
                list;
              //console.log("setting attr for ", oo.me._guid, "for ", oo.name);

              //console.log("The value is ", v);
              //console.log("The value of property is  ", val);

              if (n == "xlink:href") {
                list = host.uniqueListener("attr:" + n, function(o, newV) {
                  if (typeof(newV) != "undefined" && (newV !== null)) {
                    domi.setAttributeNS('http://www.w3.org/1999/xlink', 'href', newV);
                  }
                });
              } else {
                list = host.uniqueListener("attr:" + n, function(o, newV) {
                  if (typeof(newV) != "undefined" && (newV !== null)) {
                    domi.setAttributeNS(null, n, newV);
                  }
                });
              }
              oo.on(fName, list);
              if (typeof(val) != "undefined" && (val !== null)) {
                if (n == "xlink:href") {
                  this._dom.setAttributeNS('http://www.w3.org/1999/xlink', 'href', val);
                } else {
                  this._dom.setAttributeNS(null, n, val);
                }
              } else {

              }
              return this;
            }

            if (this._host.isFunction(v)) {

              var val = v();
              var oo = v(null, true),
                me = this,
                domi = me._dom,
                host = this._host,
                list;
              //console.log("setting attr for ", oo.me._guid, "for ", oo.name);

              if (n == "xlink:href") {
                list = host.uniqueListener("attr:" + n, function(o, newV) {
                  if (typeof(newV) != "undefined" && (newV !== null)) {
                    domi.setAttributeNS('http://www.w3.org/1999/xlink', 'href', newV);
                  }
                });
              } else {
                list = host.uniqueListener("attr:" + n, function(o, newV) {
                  if (typeof(newV) != "undefined" && (newV !== null)) {
                    domi.setAttributeNS(null, n, newV);
                  }
                });
              }
              oo.me.on(oo.name, list);
              if (typeof(val) != "undefined" && (val !== null)) {
                if (n == "xlink:href") {
                  this._dom.setAttributeNS('http://www.w3.org/1999/xlink', 'href', val);
                } else {
                  this._dom.setAttributeNS(null, n, val);
                }
              } else {

              }
              return this;
            }
            if (typeof(v) != "undefined") {
              if (n == "xlink:href") {
                this._dom.setAttributeNS('http://www.w3.org/1999/xlink', 'href', v);
              } else {
                this._dom.setAttributeNS(null, n, v);
              }
            }

            return this;
          }
          if (this._host.isFunction(v)) {

            var val = v();
            var oo = v(null, true),
              me = this,
              domi = me._dom,
              host = this._host;

            var list = host.uniqueListener("attr:" + n, function(o, newV) {
              if (typeof(newV) != "undefined")
                domi.setAttribute(n, newV);
            });
            oo.me.on(oo.name, list);
            if (typeof(val) != "undefined")
              this._dom.setAttribute(n, val);
            return this;
          }
          if (typeof(v) != "undefined")
            this._dom.setAttribute(n, v);
          return this;
        }
        _myTrait_.bindSysEvent = function(en, fn, stop) {
          en = en.toLowerCase();
          if (!this._sys) this._sys = {};
          if (this._sys[en]) return false;

          this._sys[en] = true;

          var me = this;

          if (this._dom.attachEvent) {
            this._dom.attachEvent("on" + en, function(e) {
              e = e || window.event;
              me._event = e;
              fn();
              if (stop) {
                e = window.event;
                if (e) e.cancelBubble = true;
              }
            });
          } else {
            this._dom.addEventListener(en, function(e) {
              e = e || window.event;
              me._event = e;
              if (stop) {
                if (e && e.stopPropagation) {
                  e.stopPropagation();
                } else {
                  e = window.event;
                  e.cancelBubble = true;
                }
              }
              fn();
            });
          }
          return true;
        }
        _myTrait_.blur = function(t) {
          if (this._dom.blur) this._dom.blur();
        }
        _myTrait_.css = function(n, v) {
          if (n == "background-color") n = "backgroundColor";
          if (n == "margin-left") n = "marginLeft";
          if (n == "font-size") {
            n = "fontSize";
            v = this.pxParam(v);
          }

          if (n == "left" || n == "top" || n == "bottom" || n == "right" || n == "width" || n == "height") {

            v = this.pxParam(v);
          }

          if (v.substring) {
            if (v.substring(0, 3) == "NaN") {
              return;
            }
          }
          this._dom.style[n] = v;
          return this;
        }
        _myTrait_.focus = function(t) {
          if (this._dom.focus) this._dom.focus();
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(myDom, host) {
          this._dom = myDom;
          this._host = host;
        });
        _myTrait_.pxParam = function(v) {

          if (v == "auto") return v;


          if (typeof(v.slice) != "undefined") {
            if (v.slice(-1) == "%") {
              return v;
            }
            if (v.slice(-2) == "em") {
              return v;
            }
            if (v.slice(-2) == "px") {
              return v;
            }
          }

          if (isNaN(parseInt(v))) {
            return "";
          }
          if (typeof(v) == "string") {
            return parseInt(v) + "px";
          } else {
            var i = parseInt(v);
            if (!isNaN(i)) {
              // this._dom.style.width = i+"px";
              return i + "px";
            }
          }
        }
      }(this));
    }
    var _qc = function(a, b, c, d, e, f, g, h) {
      if (this instanceof _qc) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != _qc._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new _qc(a, b, c, d, e, f, g, h);
    };
    _qc._classInfo = {
      name: '_qc'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_qc", _qc)
    _qc.prototype = new _qc_prototype();
    var later_prototype = function() {;
      (function(_myTrait_) {
        var _initDone;
        var _callers;
        var _oneTimers;
        var _everies;
        var _framers;
        _myTrait_.add = function(fn, thisObj, args) {
          if (thisObj || args) {
            var tArgs;
            if (Object.prototype.toString.call(args) === '[object Array]') {
              tArgs = args;
            } else {
              tArgs = Array.prototype.slice.call(arguments, 2);
              if (!tArgs) tArgs = [];
            }
            _callers.push([thisObj, fn, tArgs]);
          } else {
            _callers.push(fn);
          }
        }
        _myTrait_.after = function(seconds, fn, name) {

          if (!name) {
            name = "time" + (new Date()).getTime() + Math.random(10000000);
          }

          _everies[name] = {
            step: Math.floor(seconds * 1000),
            fn: fn,
            nextTime: 0,
            remove: true
          };
        }
        _myTrait_.asap = function(fn) {
          this.add(fn);

        }
        _myTrait_.every = function(seconds, fn, name) {

          if (!name) {
            name = "time" + (new Date()).getTime() + Math.random(10000000);
          }

          _everies[name] = {
            step: Math.floor(seconds * 1000),
            fn: fn,
            nextTime: 0
          };
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(interval, fn) {
          if (!_initDone) {

            this.polyfill();

            var frame, cancelFrame;
            if (typeof(window) != "undefined") {
              var frame = window['requestAnimationFrame'],
                cancelFrame = window['cancelRequestAnimationFrame'];
              ['', 'ms', 'moz', 'webkit', 'o'].forEach(function(x) {
                if (!frame) {
                  frame = window[x + 'RequestAnimationFrame'];
                  cancelFrame = window[x + 'CancelAnimationFrame'] || window[x + 'CancelRequestAnimationFrame'];
                }
              });
            }

            if (!frame)
              frame = function(cb) {
                return setTimeout(cb, 16);
              };

            if (!cancelFrame)
              cancelFrame = function(id) {
                clearTimeout(id);
              };

            _callers = [];
            _oneTimers = {};
            _everies = {};
            _framers = [];
            var lastMs = 0;

            var _callQueQue = function() {
              var ms = (new Date()).getTime();
              var fn;
              while (fn = _callers.shift()) {
                if (Object.prototype.toString.call(fn) === '[object Array]') {
                  fn[1].apply(fn[0], fn[2]);
                } else {
                  fn();
                }

              }

              for (var i = 0; i < _framers.length; i++) {
                var fFn = _framers[i];
                fFn();
              }

              for (var n in _oneTimers) {
                if (_oneTimers.hasOwnProperty(n)) {
                  var v = _oneTimers[n];
                  v[0](v[1]);
                  delete _oneTimers[n];
                }
              }

              for (var n in _everies) {
                if (_everies.hasOwnProperty(n)) {
                  var v = _everies[n];
                  if (v.nextTime < ms) {
                    if (v.remove) {
                      if (v.nextTime > 0) {
                        v.fn();
                        delete _everies[n];
                      } else {
                        v.nextTime = ms + v.step;
                      }
                    } else {
                      v.fn();
                      v.nextTime = ms + v.step;
                    }
                  }
                  if (v.until) {
                    if (v.until < ms) {
                      delete _everies[n];
                    }
                  }
                }
              }

              frame(_callQueQue);
              lastMs = ms;
            };
            _callQueQue();
            _initDone = true;
          }
        });
        _myTrait_.once = function(key, fn, value) {
          // _oneTimers

          _oneTimers[key] = [fn, value];
        }
        _myTrait_.onFrame = function(fn) {

          _framers.push(fn);
        }
        _myTrait_.polyfill = function(t) {
          // --- let's not ---
        }
        _myTrait_.removeFrameFn = function(fn) {

          var i = _framers.indexOf(fn);
          if (i >= 0) {
            if (fn._onRemove) {
              fn._onRemove();
            }
            _framers.splice(i, 1);
            return true;
          } else {
            return false;
          }
        }
      }(this));
    }
    var later = function(a, b, c, d, e, f, g, h) {
      if (this instanceof later) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != later._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new later(a, b, c, d, e, f, g, h);
    };
    later._classInfo = {
      name: 'later'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("later", later)
    later.prototype = new later_prototype();
    if (typeof(window) != 'undefined') window['later'] = later;
    if (typeof(window) != 'undefined') window['later_prototype'] = later_prototype;
    var ocTransform_prototype = function() {;
      (function(_myTrait_) {
        var _initDone;
        var rv;
        _myTrait_.arcTo = function(t) {
          var args = Array.prototype.slice.call(arguments);

          this._point.tx0 = this._point.tx1;
          this._point.ty0 = this._point.ty1;

          this._point.y = args.pop();
          this._point.x = args.pop();

          var p = this.transformPoint(this._point.x, this._point.y);
          this._point.tx1 = p.x;
          this._point.ty1 = p.y;
        }
        _myTrait_.bezierCurveTo = function(t) {
          var args = Array.prototype.slice.call(arguments);

          this._point.tx0 = this._point.tx1;
          this._point.ty0 = this._point.ty1;

          this._point.y = args.pop();
          this._point.x = args.pop();

          var p = this.transformPoint(this._point.x, this._point.y);
          this._point.tx1 = p.x;
          this._point.ty1 = p.y;
        }
        _myTrait_.copyFrom = function(m) {

          if (m.m) m = m.m;

          var myM = this.m;
          var didChange = false;

          for (var i = 0; i < 6; i++)
            if (myM[i] != m[i]) didChange = true;

          myM[0] = m[0];
          myM[1] = m[1];
          myM[2] = m[2];
          myM[3] = m[3];
          myM[4] = m[4];
          myM[5] = m[5];
          return didChange;

        }
        _myTrait_.fillStyle = function(v) {
          this.setStyle("fillStyle", v);
        }
        _myTrait_.font = function(v) {

          var parts = v.split(" ");

          this.setStyle("font-size", parts[0]);
          this.setStyle("font-family", parts[1]);
        }
        _myTrait_.getStyle = function(n) {
          var s = this._fillState[this._fillState.length - 1];
          if (s) {
            return s[n];
          }
        }
        _myTrait_.getSvgTransform = function(t) {
          var m = this.m;
          return "matrix(" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + "," + m[4] + "," + m[5] + ")";
        }
        _myTrait_.globalAlpha = function(v, foo) {

          this.setStyle("globalAlpha", v);
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function() {

          if (!_initDone) {
            rv = {
              x: 0,
              y: 0
            };
          }
          this.reset();


          this._point = {
            x: 0,
            y: 0,
            tx0: 0,
            ty0: 0,
            tx1: 0,
            ty1: 0
          };



        });
        _myTrait_.invert = function() {

          var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
          var m0 = this.m[3] * d;
          var m1 = -this.m[1] * d;
          var m2 = -this.m[2] * d;
          var m3 = this.m[0] * d;
          var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
          var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
          this.m[0] = m0;
          this.m[1] = m1;
          this.m[2] = m2;
          this.m[3] = m3;
          this.m[4] = m4;
          this.m[5] = m5;

        }
        _myTrait_.lineTo = function(x, y) {
          var args = Array.prototype.slice.call(arguments);

          this._point.tx0 = this._point.tx1;
          this._point.ty0 = this._point.ty1;

          this._point.y = args.pop();
          this._point.x = args.pop();

          var p = this.transformPoint(this._point.x, this._point.y);
          this._point.tx1 = p.x;
          this._point.ty1 = p.y;
        }
        _myTrait_.lineWidth = function(v) {
          this.setStyle("lineWidth", v);
        }
        _myTrait_.moveTo = function(x, y) {
          var args = Array.prototype.slice.call(arguments);

          this._point.tx0 = this._point.tx1;
          this._point.ty0 = this._point.ty1;

          this._point.y = args.pop();
          this._point.x = args.pop();

          var p = this.transformPoint(this._point.x, this._point.y);
          this._point.tx1 = p.x;
          this._point.ty1 = p.y;
        }
        _myTrait_.multiply = function(matrix) {

          var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
          var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];

          var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
          var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];

          var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
          var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

          this.m[0] = m11;
          this.m[1] = m12;
          this.m[2] = m21;
          this.m[3] = m22;
          this.m[4] = dx;
          this.m[5] = dy;

        }
        _myTrait_.quadraticCurveTo = function(t) {
          var args = Array.prototype.slice.call(arguments);

          this._point.tx0 = this._point.tx1;
          this._point.ty0 = this._point.ty1;

          this._point.y = args.pop();
          this._point.x = args.pop();

          var p = this.transformPoint(this._point.x, this._point.y);
          this._point.tx1 = p.x;
          this._point.ty1 = p.y;


        }
        _myTrait_.reset = function() {
          if (!this.m) {
            this.m = [1, 0, 0, 1, 0, 0];
            this._point = {
              x: 0,
              y: 0,
              tx0: 0,
              ty0: 0,
              tx1: 0,
              ty1: 0
            };
          } else {
            var m = this.m;
            m[0] = 1;
            m[1] = 0;
            m[2] = 0;
            m[3] = 1;
            m[4] = 0;
            m[5] = 0;
            this._point.x = 0;
            this._point.y = 0;
            this._point.tx1 = 0;
            this._point.ty1 = 0;
            this._point.tx0 = 0;
            this._point.ty0 = 0;
          }

          this._fillState = [{
            "globalAlpha": 1,
            "fillStyle": "none",
            "strokeStyle": "black",
            "font-size": 10,
            "lineWidth": 1,
            "font-family": "Arial"
          }];

        }
        _myTrait_.restore = function() {

          //console.log("Restoring, old matrix was ");
          //console.log(this.m);
          this.m = this._oldies.pop();

          this._fillState.pop();

        }
        _myTrait_.rotate = function(rad) {


          //console.log("trans.rotate "+rad);
          var c = Math.cos(rad);
          var s = Math.sin(rad);
          var m11 = this.m[0] * c + this.m[2] * s;
          var m12 = this.m[1] * c + this.m[3] * s;
          var m21 = this.m[0] * -s + this.m[2] * c;
          var m22 = this.m[1] * -s + this.m[3] * c;
          this.m[0] = m11;
          this.m[1] = m12;
          this.m[2] = m21;
          this.m[3] = m22;

        }
        _myTrait_.rotateAround = function(x, y, angle) {

          //console.log("trans.rotateAround "+x+","+y+","+angle);
          this.translate(x, y);
          this.rotate(angle * Math.PI / 180); // rotate 90 degrees
          this.translate(-x, -y);

        }
        _myTrait_.save = function() {

          // Q: how to clone an array
          // http://stackoverflow.com/questions/7486085/copying-array-by-value-in-javascript
          var old = this.m.slice(0);
          //console.log("Save");
          //console.log(old);
          //console.log(this.m);
          if (!this._oldies) this._oldies = [];
          this._oldies.push(old);

          var oldState = this._fillState[this._fillState.length - 1],
            newState = {};

          for (var n in oldState) {
            if (oldState.hasOwnProperty(n))
              newState[n] = oldState[n];
          }

          this._fillState.push(newState);

        }
        _myTrait_.scale = function(sx, sy) {

          if (isNaN(sx)) return;
          if (isNaN(sy)) return;
          //console.log("trans.scale "+sx+","+sy);
          this.m[0] *= sx;
          this.m[1] *= sx;
          this.m[2] *= sy;
          this.m[3] *= sy;

        }
        _myTrait_.setStyle = function(n, v) {

          var s = this._fillState[this._fillState.length - 1];
          if (s) {
            s[n] = v;
          }
        }
        _myTrait_.strokeStyle = function(v) {
          this.setStyle("strokeStyle", v);
        }
        _myTrait_.transformDelta = function(dx, dy) {


          rv.x = dx * this.m[0] + dy * this.m[2];
          rv.y = dx * this.m[1] + dy * this.m[3];
          return rv;

        }
        _myTrait_.transformPoint = function(px, py) {


          var x = px;
          var y = py;
          rv.x = x * this.m[0] + y * this.m[2] + this.m[4];
          rv.y = x * this.m[1] + y * this.m[3] + this.m[5];
          return rv;

        }
        _myTrait_.translate = function(x, y) {


          //console.log("trans.rotate "+x+","+y);
          this.m[4] += this.m[0] * x + this.m[2] * y;
          this.m[5] += this.m[1] * x + this.m[3] * y;

        }
        _myTrait_.translateAbsolute = function(x, y) {
          this.m[4] = this.m[0] * x + this.m[2] * y;
          this.m[5] = this.m[1] * x + this.m[3] * y;
        }
        _myTrait_.updateContext = function(ctx) {

          var m = this.m;
          ctx.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);

        }
        _myTrait_.xScaleFactor = function() {

          var a = this.m[0],
            b = this.m[2];
          return Math.sqrt(a * a + b * b);

        }
      }(this));
    }
    var ocTransform = function(a, b, c, d, e, f, g, h) {
      if (this instanceof ocTransform) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != ocTransform._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new ocTransform(a, b, c, d, e, f, g, h);
    };
    ocTransform._classInfo = {
      name: 'ocTransform'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("ocTransform", ocTransform)
    ocTransform.prototype = new ocTransform_prototype();
    var canvasContext_prototype = function() {
      var ocColorIndex_prototype = function() {;
        (function(_myTrait_) {
          var colors;
          _myTrait_.colorMix = function(c1, c2, t) {

            var from = this.toRGB(c1),
              to = this.toRGB(c2);

            var res = this.yuvConversion2(from, to, function(y1, y2) {
              return {
                y: (1 - t) * y1.y + t * y2.y,
                u: (1 - t) * y1.u + t * y2.u,
                v: (1 - t) * y1.v + t * y2.v
              }
            });

            return res;
          }
          _myTrait_.colorToHex = function(color) {
            if (color.substr(0, 1) === '#') {
              return color;
            }
            var digits = /(.*?)rgb\((\d+), (\d+), (\d+)\)/.exec(color);

            var red = parseInt(digits[2]);
            var green = parseInt(digits[3]);
            var blue = parseInt(digits[4]);

            var rgb = blue | (green << 8) | (red << 16);
            return digits[1] + '#' + rgb.toString(16);
          }
          _myTrait_.colourNameToHex = function(colour) {

            if (typeof colors[colour.toLowerCase()] != 'undefined')
              return colors[colour.toLowerCase()];

            return false;
          }
          _myTrait_.componentToHex = function(c) {
            c = parseInt(c);
            var hex = c.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
          }
          _myTrait_.hexToRgb = function(hex) {
            if (hex[0] == "#") hex = hex.substr(1);
            if (hex.length == 3) {
              var temp = hex;
              hex = '';
              temp = /^([a-f0-9])([a-f0-9])([a-f0-9])$/i.exec(temp).slice(1);
              for (var i = 0; i < 3; i++) hex += temp[i] + temp[i];
            }
            if (!hex) return null;
            if (hex == null) return;
            var triplets = /^([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i.exec(hex).slice(1);

            return {
              r: parseInt(triplets[0], 16),
              g: parseInt(triplets[1], 16),
              b: parseInt(triplets[2], 16)
            }
          }
          _myTrait_.hexToYuv = function(hexVal) {
            var me = this;
            return me.rgbToYuv(me.toRGB(hexVal));
          }
          _myTrait_.hsvToRgb = function(c) {
            var r, g, b;
            var i;
            var f, p, q, t;

            // Make sure our arguments stay in-range
            var h = Math.max(0, Math.min(360, c.h));
            var s = Math.max(0, Math.min(100, c.s));
            var v = Math.max(0, Math.min(100, c.v));

            // We accept saturation and value arguments from 0 to 100 because that's
            // how Photoshop represents those values. Internally, however, the
            // saturation and value are calculated from a range of 0 to 1. We make
            // That conversion here.
            s /= 100;
            v /= 100;

            if (s == 0) {
              // Achromatic (grey)
              r = g = b = v;
              return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
              };
            }

            h /= 60; // sector 0 to 5
            i = Math.floor(h);
            f = h - i; // factorial part of h
            p = v * (1 - s);
            q = v * (1 - s * f);
            t = v * (1 - s * (1 - f));

            switch (i) {
              case 0:
                r = v;
                g = t;
                b = p;
                break;

              case 1:
                r = q;
                g = v;
                b = p;
                break;

              case 2:
                r = p;
                g = v;
                b = t;
                break;

              case 3:
                r = p;
                g = q;
                b = v;
                break;

              case 4:
                r = t;
                g = p;
                b = v;
                break;

              default: // case 5:
                r = v;
                g = p;
                b = q;
            }

            return {
              r: Math.round(r * 255),
              g: Math.round(g * 255),
              b: Math.round(b * 255)
            };
          }
          if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
            _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
          if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
          _myTrait_.__traitInit.push(function(t) {
            colors = {
              "none": "#ffffff",
              "aliceblue": "#f0f8ff",
              "antiquewhite": "#faebd7",
              "aqua": "#00ffff",
              "aquamarine": "#7fffd4",
              "azure": "#f0ffff",
              "beige": "#f5f5dc",
              "bisque": "#ffe4c4",
              "black": "#000000",
              "blanchedalmond": "#ffebcd",
              "blue": "#0000ff",
              "blueviolet": "#8a2be2",
              "brown": "#a52a2a",
              "burlywood": "#deb887",
              "cadetblue": "#5f9ea0",
              "chartreuse": "#7fff00",
              "chocolate": "#d2691e",
              "coral": "#ff7f50",
              "cornflowerblue": "#6495ed",
              "cornsilk": "#fff8dc",
              "crimson": "#dc143c",
              "cyan": "#00ffff",
              "darkblue": "#00008b",
              "darkcyan": "#008b8b",
              "darkgoldenrod": "#b8860b",
              "darkgray": "#a9a9a9",
              "darkgreen": "#006400",
              "darkkhaki": "#bdb76b",
              "darkmagenta": "#8b008b",
              "darkolivegreen": "#556b2f",
              "darkorange": "#ff8c00",
              "darkorchid": "#9932cc",
              "darkred": "#8b0000",
              "darksalmon": "#e9967a",
              "darkseagreen": "#8fbc8f",
              "darkslateblue": "#483d8b",
              "darkslategray": "#2f4f4f",
              "darkturquoise": "#00ced1",
              "darkviolet": "#9400d3",
              "deeppink": "#ff1493",
              "deepskyblue": "#00bfff",
              "dimgray": "#696969",
              "dodgerblue": "#1e90ff",
              "firebrick": "#b22222",
              "floralwhite": "#fffaf0",
              "forestgreen": "#228b22",
              "fuchsia": "#ff00ff",
              "gainsboro": "#dcdcdc",
              "ghostwhite": "#f8f8ff",
              "gold": "#ffd700",
              "goldenrod": "#daa520",
              "gray": "#808080",
              "green": "#008000",
              "greenyellow": "#adff2f",
              "honeydew": "#f0fff0",
              "hotpink": "#ff69b4",
              "indianred": "#cd5c5c",
              "indigo ": "#4b0082",
              "ivory": "#fffff0",
              "khaki": "#f0e68c",
              "lavender": "#e6e6fa",
              "lavenderblush": "#fff0f5",
              "lawngreen": "#7cfc00",
              "lemonchiffon": "#fffacd",
              "lightblue": "#add8e6",
              "lightcoral": "#f08080",
              "lightcyan": "#e0ffff",
              "lightgoldenrodyellow": "#fafad2",
              "lightgrey": "#d3d3d3",
              "lightgreen": "#90ee90",
              "lightpink": "#ffb6c1",
              "lightsalmon": "#ffa07a",
              "lightseagreen": "#20b2aa",
              "lightskyblue": "#87cefa",
              "lightslategray": "#778899",
              "lightsteelblue": "#b0c4de",
              "lightyellow": "#ffffe0",
              "lime": "#00ff00",
              "limegreen": "#32cd32",
              "linen": "#faf0e6",
              "magenta": "#ff00ff",
              "maroon": "#800000",
              "mediumaquamarine": "#66cdaa",
              "mediumblue": "#0000cd",
              "mediumorchid": "#ba55d3",
              "mediumpurple": "#9370d8",
              "mediumseagreen": "#3cb371",
              "mediumslateblue": "#7b68ee",
              "mediumspringgreen": "#00fa9a",
              "mediumturquoise": "#48d1cc",
              "mediumvioletred": "#c71585",
              "midnightblue": "#191970",
              "mintcream": "#f5fffa",
              "mistyrose": "#ffe4e1",
              "moccasin": "#ffe4b5",
              "navajowhite": "#ffdead",
              "navy": "#000080",
              "oldlace": "#fdf5e6",
              "olive": "#808000",
              "olivedrab": "#6b8e23",
              "orange": "#ffa500",
              "orangered": "#ff4500",
              "orchid": "#da70d6",
              "palegoldenrod": "#eee8aa",
              "palegreen": "#98fb98",
              "paleturquoise": "#afeeee",
              "palevioletred": "#d87093",
              "papayawhip": "#ffefd5",
              "peachpuff": "#ffdab9",
              "peru": "#cd853f",
              "pink": "#ffc0cb",
              "plum": "#dda0dd",
              "powderblue": "#b0e0e6",
              "purple": "#800080",
              "red": "#ff0000",
              "rosybrown": "#bc8f8f",
              "royalblue": "#4169e1",
              "saddlebrown": "#8b4513",
              "salmon": "#fa8072",
              "sandybrown": "#f4a460",
              "seagreen": "#2e8b57",
              "seashell": "#fff5ee",
              "sienna": "#a0522d",
              "silver": "#c0c0c0",
              "skyblue": "#87ceeb",
              "slateblue": "#6a5acd",
              "slategray": "#708090",
              "snow": "#fffafa",
              "springgreen": "#00ff7f",
              "steelblue": "#4682b4",
              "tan": "#d2b48c",
              "teal": "#008080",
              "thistle": "#d8bfd8",
              "tomato": "#ff6347",
              "turquoise": "#40e0d0",
              "violet": "#ee82ee",
              "wheat": "#f5deb3",
              "white": "#ffffff",
              "whitesmoke": "#f5f5f5",
              "yellow": "#ffff00",
              "yellowgreen": "#9acd32"
            };
          });
          _myTrait_.rgbToHex = function(p) {
            var me = this;
            return "#" + me.componentToHex(p.r) + me.componentToHex(p.g) + me.componentToHex(p.b);
          }
          _myTrait_.rgbToHsv = function(c) {
            var rr, gg, bb,
              r = c.r / 255,
              g = c.g / 255,
              b = c.b / 255,
              h, s,
              v = Math.max(r, g, b),
              diff = v - Math.min(r, g, b),
              diffc = function(c) {
                return (v - c) / 6 / diff + 1 / 2;
              };

            if (diff == 0) {
              h = s = 0;
            } else {
              s = diff / v;
              rr = diffc(r);
              gg = diffc(g);
              bb = diffc(b);

              if (r === v) {
                h = bb - gg;
              } else if (g === v) {
                h = (1 / 3) + rr - bb;
              } else if (b === v) {
                h = (2 / 3) + gg - rr;
              }
              if (h < 0) {
                h += 1;
              } else if (h > 1) {
                h -= 1;
              }
            }
            return {
              h: Math.round(h * 360),
              s: Math.round(s * 100),
              v: Math.round(v * 100)
            };
          }
          _myTrait_.rgbToYuv = function(c) {
            var R = c.r / 255;
            var G = c.g / 255;
            var B = c.b / 255;
            return {
              y: 0.299 * R + 0.587 * G + 0.114 * B,
              u: -0.14713 * R - 0.28885 * G + 0.436 * B,
              v: 0.615 * R - 0.51499 * G - 0.10001 * B
            }
          }
          _myTrait_.toRGB = function(c) {
            if (typeof(c) == "object") return c;
            var me = this;

            var hex = me.colourNameToHex(c);
            if (!hex) {
              hex = me.colorToHex(c);
            }
            return me.hexToRgb(hex);
          }
          _myTrait_.toRSpace = function(v) {
            return Math.max(0, Math.min(255, Math.round(v)));
          }
          _myTrait_.yuvConversion = function(c, fn) {
            var me = this;
            var yuv = me.rgbToYuv(me.toRGB(c));
            yuv = fn(yuv);
            var rgb = me.yuvToRgb(yuv);
            return me.rgbToHex(rgb);
          }
          _myTrait_.yuvConversion2 = function(c1, c2, fn) {
            var me = this;
            var yuv = me.rgbToYuv(me.toRGB(c1));
            var yuv2 = me.rgbToYuv(me.toRGB(c2));
            yuv = fn(yuv, yuv2);
            var rgb = me.yuvToRgb(yuv);
            return me.rgbToHex(rgb);
          }
          _myTrait_.yuvPixelConversion = function(c, fn) {
            var yuv = me.rgbToYuv(c);
            yuv = fn(yuv);
            var rgb = me.yuvToRgb(yuv);
            c.r = rgb.r;
            c.g = rgb.g;
            c.b = rgb.b;
            return c;
          }
          _myTrait_.yuvToRgb = function(c) {
            var Y = c.y;
            var U = c.u;
            var V = c.v;

            return {
              r: this.toRSpace(255 * (Y + 0 * U + 1.13983 * V)),
              g: this.toRSpace(255 * (Y - 0.39465 * U - 0.58060 * V)),
              b: this.toRSpace(255 * (Y + 2.03211 * U))
            }
          }
        }(this));;
        (function(_myTrait_) {
          var _initDone;
          var rv;
          _myTrait_.add = function(color, obj) {

            var rgb = this.toRGB(color);
            var cName = rgb.r + ":" + rgb.g + ":" + rgb.b;

            this._colorIndex[cName] = obj;

            return true;
          }
          _myTrait_.find = function(color) {

            var rgb = this.toRGB(color);
            var cName = rgb.r + ":" + rgb.g + ":" + rgb.b;

            return this._colorIndex[cName];
          }
          _myTrait_.getIndex = function(t) {
            return this._colorIndex;
          }
          if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
            _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
          if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
          _myTrait_.__traitInit.push(function(t) {
            this._colorIndex = {};
          });
        }(this));
      }
      var ocColorIndex = function(a, b, c, d, e, f, g, h) {
        if (this instanceof ocColorIndex) {
          var args = [a, b, c, d, e, f, g, h];
          if (this.__factoryClass) {
            var m = this;
            var res;
            this.__factoryClass.forEach(function(initF) {
              res = initF.apply(m, args);
            });
            if (Object.prototype.toString.call(res) == '[object Function]') {
              if (res._classInfo.name != ocColorIndex._classInfo.name) return new res(a, b, c, d, e, f, g, h);
            } else {
              if (res) return res;
            }
          }
          if (this.__traitInit) {
            var m = this;
            this.__traitInit.forEach(function(initF) {
              initF.apply(m, args);
            })
          } else {
            if (typeof this.init == 'function')
              this.init.apply(this, args);
          }
        } else return new ocColorIndex(a, b, c, d, e, f, g, h);
      };
      ocColorIndex._classInfo = {
        name: 'ocColorIndex'
      };
      if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("ocColorIndex", ocColorIndex)
      ocColorIndex.prototype = new ocColorIndex_prototype();
      var ocPaintHead_prototype = function() {;
        (function(_myTrait_) {
          var _initDone;
          var rv;
          _myTrait_.directionVector = function(t) {
            var rad = Math.PI * this._angle / 180;
            var dv = {
              i: Math.cos(rad),
              j: Math.sin(rad)
            }
            return dv;
          }
          if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
            _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
          if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
          _myTrait_.__traitInit.push(function(ctx, w, h) {

            this._ctx = ctx;

            this._w = w || 100;
            this._h = h || 100;

            // usually, start from bottom...
            this._x = 0.5;
            this._y = 1;
            this._angle = 90;
          });
          _myTrait_.line = function(direction, length, bending) {

            this.turn(direction);

            var step1 = this.stepVector(length / 2, bending),
              step2 = this.stepVector(length, 0);

            // this._ctx.moveTo(this._x,this._y);  
            this._ctx.quadraticCurveTo(step1.x, step1.y,
              step2.x, step2.y);

            this._x = step2.x;
            this._y = step2.y;

            return this;
          }
          _myTrait_.startFrom = function(x, y) {
            this._x = x;
            this._y = y;

            this._ctx.moveTo(this._x, this._y);

            return this;
          }
          _myTrait_.stepVector = function(len, angleDiff) {
            if (!angleDiff) angleDiff = 0;
            var rad = Math.PI * (this._angle + angleDiff) / 180;
            var step = {
              x: this._x + Math.cos(rad) * len,
              y: this._y + Math.sin(rad) * len
            };
            console.log(step);
            return step;
          }
          _myTrait_.turn = function(angle) {

            if (!angle) return this;

            if (angle == "left") {
              this._angle = 180;
              return this;
            }
            if (angle == "right") {
              this._angle = 0;
              return this;
            }
            if (angle == "up") {
              this._angle = 90;
              return this;
            }
            if (angle == "down") {
              this._angle = -90;
              return this;
            }

            this._angle += angle;

            return this;
          }
        }(this));
      }
      var ocPaintHead = function(a, b, c, d, e, f, g, h) {
        if (this instanceof ocPaintHead) {
          var args = [a, b, c, d, e, f, g, h];
          if (this.__factoryClass) {
            var m = this;
            var res;
            this.__factoryClass.forEach(function(initF) {
              res = initF.apply(m, args);
            });
            if (Object.prototype.toString.call(res) == '[object Function]') {
              if (res._classInfo.name != ocPaintHead._classInfo.name) return new res(a, b, c, d, e, f, g, h);
            } else {
              if (res) return res;
            }
          }
          if (this.__traitInit) {
            var m = this;
            this.__traitInit.forEach(function(initF) {
              initF.apply(m, args);
            })
          } else {
            if (typeof this.init == 'function')
              this.init.apply(this, args);
          }
        } else return new ocPaintHead(a, b, c, d, e, f, g, h);
      };
      ocPaintHead._classInfo = {
        name: 'ocPaintHead'
      };
      if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("ocPaintHead", ocPaintHead)
      ocPaintHead.prototype = new ocPaintHead_prototype();
      var ocPathLib_prototype = function() {;
        (function(_myTrait_) {
          var _initDone;
          var rv;
          _myTrait_.arrow = function(options) {
            var props = 0.5;
            this.symmetricPath({
              start: {
                x: options.start.x,
                y: options.start.y,
                bend: -0.1
              },
              points: [{
                xstep: 0.15,
                ystep: 0.15 * props,
                bend: -0.1
              }, {
                xstep: 0.12,
                ystep: 0.03 * props,
                bend: 0
              }, {
                xstep: 1,
                ystep: 0.08 * props,
                bend: -0.2
              }],
              end: {
                x: options.end.x,
                y: options.end.y
              }
            });
          }
          _myTrait_.dynArrow = function(data) {
            var props = 0.5;

            // var data = _data(options);

            var buildData = function() {
              return {
                start: {
                  x: data.start.x(),
                  y: data.start.y()
                },
                points: [{
                  xstep: 0.15,
                  ystep: 0.15 * props,
                  bend: -0.1
                }, {
                  xstep: 0.12,
                  ystep: 0.03 * props,
                  bend: 0
                }, {
                  xstep: 1,
                  ystep: 0.08 * props,
                  bend: -0.2
                }],
                end: {
                  x: data.end.x(),
                  y: data.end.y()
                }
              };
            };

            var c = canvasContext();
            var shape = c.shapes(),
              pathData = _data({
                svgPath: ""
              });

            // group with path
            var g = _e("g"),
              fillColor = "yellow";

            if (data.fill) fillColor = data.fill;
            var path = g.path("", {
              d: pathData.svgPath,
              fill: fillColor
            });

            var updatePath = function() {
              // creates commands...
              // console.log("****** UPDATE PATH *******");
              c.clear();
              var dd = buildData();
              // console.log(dd);
              shape.symmetricPath(dd);
              var svgPath = c.svgPathString();
              // console.log("svg path string ", svgPath);
              pathData.svgPath(svgPath);
            }

            updatePath();

            data.onValue("childChange", function() {
              updatePath();
            });

            return g;

            // canvasContext();

            /*
           
           this.symmetricPath({
               start : {
                   x : options.start.x,
                   y : options.start.y,
                   bend : -0.1
               }, 
               points : [
                   { xstep : 0.15, ystep : 0.15*props, bend : -0.1 },
                   { xstep : 0.12, ystep : 0.03*props, bend : 0 },
                   { xstep : 1, ystep : 0.08*props, bend : -0.2 }
               ],
               end : {
                   x:  options.end.x,
                   y : options.end.y
               }
           });
           */
          }
          _myTrait_.dynPath = function(data) {
            var c = canvasContext();
            var shape = c.shapes(),
              pathData = _data({
                svgPath: ""
              });

            var fillStyle = "purple";
            if (data.fillStyle) {
              fillStyle = data.fillStyle();
            }

            // group with path
            var g = _e("g");
            var path = g.path("", {
              d: pathData.svgPath,
              fill: fillStyle
            })
            var me = this;

            var updatePath = function() {
              // creates commands...
              // console.log("****** UPDATE PATH *******");
              c.clear();

              shape.pathDyn(data);
              //console.log("Commands ", c._commands);
              var svgPath = c.svgPathString();
              //console.log("svg path string ", svgPath);
              pathData.svgPath(svgPath);
            }

            updatePath();

            data.onValue("childChange", function() {
              updatePath();
            });

            return g;
          }
          _myTrait_.dynShape = function(data) {

            var c = canvasContext();
            var shape = c.shapes(),
              pathData = _data({
                svgPath: ""
              });

            var fillStyle = "purple";
            if (data.fillStyle) {
              fillStyle = data.fillStyle();
            }

            // group with path
            var g = _e("g");
            var path = g.path("", {
              d: pathData.svgPath,
              fill: fillStyle
            })
            var me = this;

            var updatePath = function() {
              // creates commands...
              // console.log("****** UPDATE PATH *******");
              c.clear();

              shape.symmetricPathDyn(data);
              //console.log("Commands ", c._commands);
              var svgPath = c.svgPathString();
              //console.log("svg path string ", svgPath);
              pathData.svgPath(svgPath);
            }

            updatePath();

            data.onValue("childChange", function() {
              updatePath();
            });

            return g;

            // canvasContext();

            /*
           
           this.symmetricPath({
               start : {
                   x : options.start.x,
                   y : options.start.y,
                   bend : -0.1
               }, 
               points : [
                   { xstep : 0.15, ystep : 0.15*props, bend : -0.1 },
                   { xstep : 0.12, ystep : 0.03*props, bend : 0 },
                   { xstep : 1, ystep : 0.08*props, bend : -0.2 }
               ],
               end : {
                   x:  options.end.x,
                   y : options.end.y
               }
           });
           */
          }
          if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
            _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
          if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
          _myTrait_.__traitInit.push(function(ctx, w, h) {

            this._ctx = ctx;

          });
          _myTrait_.line = function(direction, length, bending) {

            this.turn(direction);

            var step1 = this.stepVector(length / 2, bending),
              step2 = this.stepVector(length, 0);

            // this._ctx.moveTo(this._x,this._y);  
            this._ctx.quadraticCurveTo(step1.x, step1.y,
              step2.x, step2.y);

            this._x = step2.x;
            this._y = step2.y;

            return this;
          }
          _myTrait_.lineBetween = function(p1, p2) {
            var dx = p2.x - p1.x,
              dy = p2.y - p1.y,
              len = Math.sqrt(dx * dx + dy * dy),
              tnx = dx / len,
              tny = dy / len;

            var nx = -dy / len,
              ny = dx / len;

            var bend = 0;
            if (p1.bend) {
              bend = p1.bend;
            }
            var half = len / 2,
              bendLen = len * bend;

            var bendx = p1.x + (tnx * half) + bendLen * nx,
              bendy = p1.y + (tny * half) + bendLen * ny;

            // console.log("Line to context ",this._ctx);

            this._ctx.quadraticCurveTo(bendx, bendy,
              p2.x, p2.y);

          }
          _myTrait_.pathDyn = function(options) {
            var ctx = this._ctx;

            // where the arrow starts from
            ctx.moveTo(options.start.x(), options.start.y());

            var dx = options.end.x() - options.start.x(),
              dy = options.end.y() - options.start.y(),
              len = Math.sqrt(dx * dx + dy * dy),
              tnx = dx,
              tny = dy,
              sx = options.start.x(),
              sy = options.start.y();

            var nx = -dy,
              ny = dx;

            var pointCnt = options.points.length() + 2;

            // console.log("symmetricPathDyn pointCnt : ", pointCnt);

            var list = new Array(pointCnt);
            list[0] = {
              x: options.start.x(),
              y: options.start.y()
            };
            if (options.start.bend) {
              list[0].bend = options.start.bend();
            }
            list[pointCnt - 1] = list[0];

            // three points
            for (var i = 0; i < options.points.length(); i++) {
              var op = options.points.item(i);
              var p = {
                x: sx + op.xstep() * tnx + op.ystep() * nx,
                y: sy + op.xstep() * tny + op.ystep() * ny
              }
              if (op.bend) p.bend = op.bend();
              list[i + 1] = p;
            }

            // console.log("The list was ", list);

            for (var i = 0; i < list.length - 1; i++) {
              this.lineBetween(list[0 + i], list[1 + i]);
            }


          }
          _myTrait_.startFrom = function(x, y) {
            this._x = x;
            this._y = y;

            this._ctx.moveTo(this._x, this._y);

            return this;
          }
          _myTrait_.stepVector = function(len, angleDiff) {
            if (!angleDiff) angleDiff = 0;
            var rad = Math.PI * (this._angle + angleDiff) / 180;
            var step = {
              x: this._x + Math.cos(rad) * len,
              y: this._y + Math.sin(rad) * len
            };
            console.log(step);
            return step;
          }
          _myTrait_.svgArrow = function(options) {
            var path = canvasContext(this._ctx);

            path.save();
            path.beginPath();
            path.fillStyle(options.fillStyle || "#449944");
            path.lineWidth(options.lineWidth || 1);

            var shapeLib = path.shapes();
            shapeLib.arrow({
              start: {
                x: options.start.x || 30,
                y: options.start.y || 30
              },
              end: {
                x: options.end.x || 160,
                y: options.end.y || 190
              }
            });
            path.fill();
            path.stroke();
            path.restore();

            //var gg = ocGroup({});
            //var testOut = gg.svgRender();

            var res = path.renderSvg(testOut || _e().g());
            return res;
          }
          _myTrait_.symmetricPath = function(options) {
            var ctx = this._ctx;

            // where the arrow starts from
            ctx.moveTo(options.start.x, options.start.y);

            var dx = options.end.x - options.start.x,
              dy = options.end.y - options.start.y,
              len = Math.sqrt(dx * dx + dy * dy),
              tnx = dx,
              tny = dy,
              sx = options.start.x,
              sy = options.start.y;



            var nx = -dy,
              ny = dx;

            //console.log("dx,dy",dx,dy);
            //console.log("nx,ny", nx,ny);    


            var pointCnt = options.points.length + 1;

            var list = new Array(pointCnt * 2);
            list[0] = options.start;
            list[pointCnt * 2 - 1] = options.start;

            // three points
            for (var i = 0; i < options.points.length; i++) {
              var p = options.points[i];
              p.x = sx + p.xstep * tnx + p.ystep * nx;
              p.y = sy + p.xstep * tny + p.ystep * ny;
              list[i + 1] = p;
              var rp = {};
              rp.x = sx + p.xstep * tnx - p.ystep * nx;
              rp.y = sy + p.xstep * tny - p.ystep * ny;
              rp.bend = list[i].bend;
              list[2 * pointCnt - 2 - i] = rp;
              // list[2*pointCnt-3-i].bend = p.bend;
            }

            // console.log("Having list ", list);

            // Now the generic path has points to traverse

            for (var i = 0; i < list.length - 1; i++) {
              this.lineBetween(list[0 + i], list[1 + i]);
            }


          }
          _myTrait_.symmetricPathDyn = function(options) {
            var ctx = this._ctx;

            // where the arrow starts from
            ctx.moveTo(options.start.x(), options.start.y());

            var dx = options.end.x() - options.start.x(),
              dy = options.end.y() - options.start.y(),
              len = Math.sqrt(dx * dx + dy * dy),
              tnx = dx,
              tny = dy,
              sx = options.start.x(),
              sy = options.start.y();



            var nx = -dy,
              ny = dx;

            //console.log("dx,dy",dx,dy);
            //console.log("nx,ny", nx,ny);    


            var pointCnt = options.points.length() + 1;

            // console.log("symmetricPathDyn pointCnt : ", pointCnt);

            var list = new Array(pointCnt * 2);
            list[0] = {
              x: options.start.x(),
              y: options.start.y()
            };
            if (options.start.bend) {
              list[0].bend = options.start.bend();
            }
            list[pointCnt * 2 - 1] = list[0];

            // three points
            for (var i = 0; i < options.points.length(); i++) {
              var op = options.points.item(i);
              var p = {
                x: sx + op.xstep() * tnx + op.ystep() * nx,
                y: sy + op.xstep() * tny + op.ystep() * ny
              }
              if (op.bend) p.bend = op.bend();
              list[i + 1] = p;
              var rp = {
                x: sx + op.xstep() * tnx - op.ystep() * nx,
                y: sy + op.xstep() * tny - op.ystep() * ny
              }
              rp.bend = list[i].bend;
              list[2 * pointCnt - 2 - i] = rp;
            }

            // console.log("The list was ", list);

            for (var i = 0; i < list.length - 1; i++) {
              this.lineBetween(list[0 + i], list[1 + i]);
            }


          }
          _myTrait_.turn = function(angle) {

            if (!angle) return this;

            if (angle == "left") {
              this._angle = 180;
              return this;
            }
            if (angle == "right") {
              this._angle = 0;
              return this;
            }
            if (angle == "up") {
              this._angle = 90;
              return this;
            }
            if (angle == "down") {
              this._angle = -90;
              return this;
            }

            this._angle += angle;

            return this;
          }
        }(this));
      }
      var ocPathLib = function(a, b, c, d, e, f, g, h) {
        if (this instanceof ocPathLib) {
          var args = [a, b, c, d, e, f, g, h];
          if (this.__factoryClass) {
            var m = this;
            var res;
            this.__factoryClass.forEach(function(initF) {
              res = initF.apply(m, args);
            });
            if (Object.prototype.toString.call(res) == '[object Function]') {
              if (res._classInfo.name != ocPathLib._classInfo.name) return new res(a, b, c, d, e, f, g, h);
            } else {
              if (res) return res;
            }
          }
          if (this.__traitInit) {
            var m = this;
            this.__traitInit.forEach(function(initF) {
              initF.apply(m, args);
            })
          } else {
            if (typeof this.init == 'function')
              this.init.apply(this, args);
          }
        } else return new ocPathLib(a, b, c, d, e, f, g, h);
      };
      ocPathLib._classInfo = {
        name: 'ocPathLib'
      };
      if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("ocPathLib", ocPathLib)
      ocPathLib.prototype = new ocPathLib_prototype();
      var ocTransform_prototype = function() {;
        (function(_myTrait_) {
          var _initDone;
          var rv;
          _myTrait_.arcTo = function(t) {
            var args = Array.prototype.slice.call(arguments);

            this._point.tx0 = this._point.tx1;
            this._point.ty0 = this._point.ty1;

            this._point.y = args.pop();
            this._point.x = args.pop();

            var p = this.transformPoint(this._point.x, this._point.y);
            this._point.tx1 = p.x;
            this._point.ty1 = p.y;
          }
          _myTrait_.bezierCurveTo = function(t) {
            var args = Array.prototype.slice.call(arguments);

            this._point.tx0 = this._point.tx1;
            this._point.ty0 = this._point.ty1;

            this._point.y = args.pop();
            this._point.x = args.pop();

            var p = this.transformPoint(this._point.x, this._point.y);
            this._point.tx1 = p.x;
            this._point.ty1 = p.y;
          }
          _myTrait_.copyFrom = function(m) {

            if (m.m) m = m.m;

            var myM = this.m;
            var didChange = false;

            for (var i = 0; i < 6; i++)
              if (myM[i] != m[i]) didChange = true;

            myM[0] = m[0];
            myM[1] = m[1];
            myM[2] = m[2];
            myM[3] = m[3];
            myM[4] = m[4];
            myM[5] = m[5];
            return didChange;

          }
          _myTrait_.fillStyle = function(v) {
            this.setStyle("fillStyle", v);
          }
          _myTrait_.font = function(v) {

            var parts = v.split(" ");

            this.setStyle("font-size", parts[0]);
            this.setStyle("font-family", parts[1]);
          }
          _myTrait_.getStyle = function(n) {
            var s = this._fillState[this._fillState.length - 1];
            if (s) {
              return s[n];
            }
          }
          _myTrait_.getSvgTransform = function(t) {
            var m = this.m;
            return "matrix(" + m[0] + "," + m[1] + "," + m[2] + "," + m[3] + "," + m[4] + "," + m[5] + ")";
          }
          _myTrait_.globalAlpha = function(v, foo) {

            this.setStyle("globalAlpha", v);
          }
          if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
            _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
          if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
          _myTrait_.__traitInit.push(function() {

            if (!_initDone) {
              rv = {
                x: 0,
                y: 0
              };
            }
            this.reset();


            this._point = {
              x: 0,
              y: 0,
              tx0: 0,
              ty0: 0,
              tx1: 0,
              ty1: 0
            };



          });
          _myTrait_.invert = function() {

            var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
            var m0 = this.m[3] * d;
            var m1 = -this.m[1] * d;
            var m2 = -this.m[2] * d;
            var m3 = this.m[0] * d;
            var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
            var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
            this.m[0] = m0;
            this.m[1] = m1;
            this.m[2] = m2;
            this.m[3] = m3;
            this.m[4] = m4;
            this.m[5] = m5;

          }
          _myTrait_.lineTo = function(x, y) {
            var args = Array.prototype.slice.call(arguments);

            this._point.tx0 = this._point.tx1;
            this._point.ty0 = this._point.ty1;

            this._point.y = args.pop();
            this._point.x = args.pop();

            var p = this.transformPoint(this._point.x, this._point.y);
            this._point.tx1 = p.x;
            this._point.ty1 = p.y;
          }
          _myTrait_.lineWidth = function(v) {
            this.setStyle("lineWidth", v);
          }
          _myTrait_.moveTo = function(x, y) {
            var args = Array.prototype.slice.call(arguments);

            this._point.tx0 = this._point.tx1;
            this._point.ty0 = this._point.ty1;

            this._point.y = args.pop();
            this._point.x = args.pop();

            var p = this.transformPoint(this._point.x, this._point.y);
            this._point.tx1 = p.x;
            this._point.ty1 = p.y;
          }
          _myTrait_.multiply = function(matrix) {

            var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
            var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];

            var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
            var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];

            var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
            var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m21;
            this.m[3] = m22;
            this.m[4] = dx;
            this.m[5] = dy;

          }
          _myTrait_.quadraticCurveTo = function(t) {
            var args = Array.prototype.slice.call(arguments);

            this._point.tx0 = this._point.tx1;
            this._point.ty0 = this._point.ty1;

            this._point.y = args.pop();
            this._point.x = args.pop();

            var p = this.transformPoint(this._point.x, this._point.y);
            this._point.tx1 = p.x;
            this._point.ty1 = p.y;


          }
          _myTrait_.reset = function() {
            if (!this.m) {
              this.m = [1, 0, 0, 1, 0, 0];
              this._point = {
                x: 0,
                y: 0,
                tx0: 0,
                ty0: 0,
                tx1: 0,
                ty1: 0
              };
            } else {
              var m = this.m;
              m[0] = 1;
              m[1] = 0;
              m[2] = 0;
              m[3] = 1;
              m[4] = 0;
              m[5] = 0;
              this._point.x = 0;
              this._point.y = 0;
              this._point.tx1 = 0;
              this._point.ty1 = 0;
              this._point.tx0 = 0;
              this._point.ty0 = 0;
            }

            this._fillState = [{
              "globalAlpha": 1,
              "fillStyle": "none",
              "strokeStyle": "black",
              "font-size": 10,
              "lineWidth": 1,
              "font-family": "Arial"
            }];

          }
          _myTrait_.restore = function() {

            //console.log("Restoring, old matrix was ");
            //console.log(this.m);
            this.m = this._oldies.pop();

            this._fillState.pop();

          }
          _myTrait_.rotate = function(rad) {


            //console.log("trans.rotate "+rad);
            var c = Math.cos(rad);
            var s = Math.sin(rad);
            var m11 = this.m[0] * c + this.m[2] * s;
            var m12 = this.m[1] * c + this.m[3] * s;
            var m21 = this.m[0] * -s + this.m[2] * c;
            var m22 = this.m[1] * -s + this.m[3] * c;
            this.m[0] = m11;
            this.m[1] = m12;
            this.m[2] = m21;
            this.m[3] = m22;

          }
          _myTrait_.rotateAround = function(x, y, angle) {

            //console.log("trans.rotateAround "+x+","+y+","+angle);
            this.translate(x, y);
            this.rotate(angle * Math.PI / 180); // rotate 90 degrees
            this.translate(-x, -y);

          }
          _myTrait_.save = function() {

            // Q: how to clone an array
            // http://stackoverflow.com/questions/7486085/copying-array-by-value-in-javascript
            var old = this.m.slice(0);
            //console.log("Save");
            //console.log(old);
            //console.log(this.m);
            if (!this._oldies) this._oldies = [];
            this._oldies.push(old);

            var oldState = this._fillState[this._fillState.length - 1],
              newState = {};

            for (var n in oldState) {
              if (oldState.hasOwnProperty(n))
                newState[n] = oldState[n];
            }

            this._fillState.push(newState);

          }
          _myTrait_.scale = function(sx, sy) {

            if (isNaN(sx)) return;
            if (isNaN(sy)) return;
            //console.log("trans.scale "+sx+","+sy);
            this.m[0] *= sx;
            this.m[1] *= sx;
            this.m[2] *= sy;
            this.m[3] *= sy;

          }
          _myTrait_.setStyle = function(n, v) {

            var s = this._fillState[this._fillState.length - 1];
            if (s) {
              s[n] = v;
            }
          }
          _myTrait_.strokeStyle = function(v) {
            this.setStyle("strokeStyle", v);
          }
          _myTrait_.transformDelta = function(dx, dy) {


            rv.x = dx * this.m[0] + dy * this.m[2];
            rv.y = dx * this.m[1] + dy * this.m[3];
            return rv;

          }
          _myTrait_.transformPoint = function(px, py) {


            var x = px;
            var y = py;
            rv.x = x * this.m[0] + y * this.m[2] + this.m[4];
            rv.y = x * this.m[1] + y * this.m[3] + this.m[5];
            return rv;

          }
          _myTrait_.translate = function(x, y) {


            //console.log("trans.rotate "+x+","+y);
            this.m[4] += this.m[0] * x + this.m[2] * y;
            this.m[5] += this.m[1] * x + this.m[3] * y;

          }
          _myTrait_.translateAbsolute = function(x, y) {
            this.m[4] = this.m[0] * x + this.m[2] * y;
            this.m[5] = this.m[1] * x + this.m[3] * y;
          }
          _myTrait_.updateContext = function(ctx) {

            var m = this.m;
            ctx.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);

          }
          _myTrait_.xScaleFactor = function() {

            var a = this.m[0],
              b = this.m[2];
            return Math.sqrt(a * a + b * b);

          }
        }(this));
      }
      var ocTransform = function(a, b, c, d, e, f, g, h) {
        if (this instanceof ocTransform) {
          var args = [a, b, c, d, e, f, g, h];
          if (this.__factoryClass) {
            var m = this;
            var res;
            this.__factoryClass.forEach(function(initF) {
              res = initF.apply(m, args);
            });
            if (Object.prototype.toString.call(res) == '[object Function]') {
              if (res._classInfo.name != ocTransform._classInfo.name) return new res(a, b, c, d, e, f, g, h);
            } else {
              if (res) return res;
            }
          }
          if (this.__traitInit) {
            var m = this;
            this.__traitInit.forEach(function(initF) {
              initF.apply(m, args);
            })
          } else {
            if (typeof this.init == 'function')
              this.init.apply(this, args);
          }
        } else return new ocTransform(a, b, c, d, e, f, g, h);
      };
      ocTransform._classInfo = {
        name: 'ocTransform'
      };
      if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("ocTransform", ocTransform)
      ocTransform.prototype = new ocTransform_prototype();;
      (function(_myTrait_) {
        var _initDone;
        var _imageCache;
        var _isLoading;
        var _urlCallBacks;
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(data) {

          if (!_initDone) {
            _imageCache = {};
            _isLoading = {};
            _urlCallBacks = {};
            _initDone = true;
          }


        });
        _myTrait_.promiseImage = function(url) {
          var p = _promise();

          if (_imageCache[url]) {
            p.resolve(_imageCache[url]);
            _isLoading[url] = false;
            return p;
          }

          if (!_urlCallBacks[url]) _urlCallBacks[url] = [];
          _urlCallBacks[url].push(p);
          if (_isLoading[url]) {
            return p;
          }
          _isLoading[url] = true;
          var _img = new Image();
          _img.addEventListener("load", function() {
            _imageCache[url] = _img;
            var p;
            while (p = _urlCallBacks[url].pop()) {
              p.resolve(_img);
            }
            _isLoading[url] = false;
          });
          _img.src = url;

          return p;

        }
      }(this));;
      (function(_myTrait_) {
        _myTrait_.add = function(childContext, insertObj) {

          if (insertObj) {
            if (!this.hasOwnProperty("_inserts")) {
              this._inserts = {};
            }
            if (!this._inserts[childContext])
              this._inserts[childContext] = [];
            insertObj.parent(this);
            this._inserts[childContext].push(insertObj);
            return;
          } else {
            this.add("children", childContext);
          }
          /*
           if(!this.hasOwnProperty("_children")) {
               this._children = [];
           }
           this._children.push(childContext);
           */
        }
        _myTrait_.addClipMask = function(obj) {
          if (!this.hasOwnProperty("_clipMasks")) {
            this._clipMasks = [];
          }
          this._clipMasks.push(obj);
        }
        _myTrait_.autoRender = function(t) {
          if (this._autoRender) return;
          var me = this;
          this._autoRender = true;
          later().every(1 / 60, function() {
            if (me.isDirty()) {
              me.reset();
              me.exec();
              me.isDirty(false);
            }
          });
        }
        _myTrait_.clear = function(t) {
          this._commands = [];
          this._inserts = {};
        }
        _myTrait_.createColorIndex = function(t) {

          return ocColorIndex();
        }
        _myTrait_.createHandle = function(options) {

          if (!this._colorIndex) {
            this._colorIndex = this.createColorIndex();
          }

          var index = this._colorIndex;

          // defining the color is there important...
          var createHandle = function(mainCtx, x, y, shape, color, myObj) {
            var ctx = mainCtx.create("handleCtx");
            ctx.save();
            ctx.beginPath();
            // ctx.translate(x,y);
            myObj._x = x,
            myObj._y = y;
            myObj.ctx = ctx;
            myObj.color = color;
            myObj.position = ctx.create("position");
            myObj.position.translate(x, y);
            ctx.insert("shape");
            ctx.add("shape", shape);
            ctx.fillStyle(color);
            ctx.fill();
            ctx.restore();
            ctx.stroke();
            index.add(color, myObj);
          }

          var handleObj = _e();

          createHandle(this,
            options.x || 0,
            options.y || 0,
            options.shape,
            options.color,
            options.obj);

          var me = this;

          handleObj._handleData = options;

          options.obj.handleObj = handleObj;

          handleObj.moveToPoint = function(p) {
            options.obj.position.replace("translate", p.x, p.y);
          }

          if (!this._dragSet && this._canvas) {

            var can = this._canvas;
            this._dragSet = true;
            var dO;
            can.draggable(function(o, dv) {
              dO = index.find(me.getPixel(dv.x, dv.y));
              if (dO) {
                var handleObj = dO.handleObj;
                dO.ctx.replace("fillStyle", "yellow");
                handleObj.trigger("startdrag", dv);
              }
            }, function(o, dv) {
              if (dO) {
                var handleObj = dO.handleObj;
                dO.position.replace("translate", dO._x + dv.dx, dO._y + dv.dy);
                dO.ctx.replace("fillStyle", "yellow");
                handleObj.trigger("drag", dv);
              }
            }, function(o, dv) {
              if (dO) {
                var handleObj = dO.handleObj;
                // dO.position.replace("translate", dO._x + dv.dx, dO._y + dv.dy );
                dO.ctx.replace("fillStyle", dO.color);
                dO._x = dO._x + dv.dx;
                dO._y = dO._y + dv.dy;
                handleObj.trigger("enddrag", dv);
              }
            });
          }

          return handleObj;
        }
        _myTrait_.exec = function(ctx, parentTrans) {
          if (!ctx) ctx = this._ctx;

          if (ctx._ctx) ctx = ctx._ctx;

          var me = this;
          this._commands.forEach(function(f) {
            var fn = f[0];
            var args = f[1];

            if (fn == "circle") {
              var cx = args[0],
                cy = args[1],
                radius = args[2];
              ctx.arc(cx, cy, radius, 0, 2 * Math.PI, false);
              return;
            }

            if (fn == "drawImage") {
              // ...
              var imgSrc = args[0];
              if (imgSrc === Object(imgSrc)) {
                // for canvas this should be quite ok....
                ctx[fn].apply(ctx, args);
              } else {
                // load the image...
                // console.log("Loading image", imgSrc)
                me.promiseImage(imgSrc)
                  .then(function(im) {
                    console.log("image loaded ok");
                    console.log(im);
                    console.log(typeof(im));
                    args[0] = im;
                    ctx[fn].apply(ctx, args);

                  });
              }


              return;
            }


            if (fn == "insert") {
              me.forInserts(args[0], function(ch) {
                ch.exec(ctx);
              });
              return;
            }

            if (fn == "clipMask") {
              me.forClipMasks(function(ch) {
                ch.exec(ctx);
              });
              return;
            }

            if (fn == "children") {
              me.forChildren(function(ch) {
                ch.exec(ctx);
              });
              return;
            }
            if (fn == "setProperty") {
              var pName = args[0],
                pValue = args[1];
              ctx[pName] = pValue;
              //         ctx.globalAlpha = args[0];
            } else {
              ctx[fn].apply(ctx, args);
            }
          });

        }
        _myTrait_.execFn = function(cbFn, parentTrans) {


          var trans = parentTrans || this._transform;
          if (!parentTrans) trans.reset();
          var me = this;

          this._commands.forEach(function(f) {
            var fn = f[0];
            var args = f[1];


            if (fn == "insert") {
              me.forInserts(args[0], function(ch) {
                ch.execFn(cbFn, trans);
              });
              return;
            }

            if (fn == "clipMask") {
              me.forClipMasks(function(ch) {
                ch.execFn(cbFn, trans);
              });
              return;
            }

            if (fn == "children") {
              me.forChildren(function(ch) {
                ch.execFn(cbFn, trans);
              });
              return;
            }

            if (fn == "setProperty") {
              var pName = args[0],
                pValue = args[1];
              cbFn(pName, args, trans);

              if (trans[pName]) {
                trans[pName].apply(trans, [pValue]);
              }
            } else {
              // Get the point start position

              if (trans[fn]) {
                trans[fn].apply(trans, args);
              }

              cbFn(fn, args, trans);

            }
          });


        }
        _myTrait_.forChildren = function(fn) {

          this.forInserts("children", fn);
        }
        _myTrait_.forClipMasks = function(fn) {
          this.forInserts("clipMask", fn);
        }
        _myTrait_.forInserts = function(name, fn) {
          if (this._inserts && this._inserts[name]) {
            this._inserts[name].forEach(fn);
          }
        }
        _myTrait_.getPixel = function(x, y) {

          if (!this._ctx) return null;

          data = this._ctx.getImageData(x, y, 1, 1).data;
          if (!data) return null;

          return {
            x: x,
            y: y,
            r: data[0],
            g: data[1],
            b: data[2],
            a: data[3]
          };

        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(ctx) {
          if (!this._commands) {
            this._commands = [];
          }
          this._undoBuffer = [];
          this._ctx = ctx;
          this._transform = new ocTransform();

          var me = this;

          var draw_cmds = [
            "rect", "fillRect", "strokeRect", "clearRect",
            "fill", "stroke", "beginPath", "moveTo", "closePath", "lineTo", "clip", "quadraticCurveTo",
            "bezierCurveTo", "arc", "arcTo",
            "scale", "rotate", "translate", "transform", "setTransform",
            "fillText", "strokeText",
            "createImageData", "putImageData",
            "drawImage",
            "circle",
            "save", "restore",
            "setTransform"
          ];

          var get_cmds = ["createLinearGradient", "createPattern", "createRadialGradient", "addColorStop",
            "isPointInPath", "measureText", "getImageData", "toDataURL"
          ];

          var r_props = ["width", "height", "data"];
          var rw_props = ["globalAlpha", "fillStyle", "strokeStyle", "shadowColor", "shadowBlur", "shadowOffsetX",
            "shadowOffsetY",
            "font", "textAlign", "textBaseline",
            "lineCap", "lineJoin", "lineWidth", "miterLimit"
          ];

          var time = (new Date()).getTime();

          later().onFrame(function() {
            time = (new Date()).getTime();
          });


          me["insert"] = function() {
            var args = Array.prototype.slice.call(arguments);
            me._commands.push([
              "insert",
              args,
              time
            ]);
            return canvasContext();
          }

          me["create"] = function() {
            var args = Array.prototype.slice.call(arguments);
            me._commands.push([
              "insert",
              args,
              time
            ]);
            var cc = canvasContext();
            me.add(args[0], cc);
            return cc;
          }

          me["clipMask"] = function() {
            me.insert("clipMask");
          }

          me["children"] = function() {
            me.insert("children");
          }


          draw_cmds.forEach(function(fname) {
            me[fname] = function() {
              me._undoBuffer = [];
              var args = Array.prototype.slice.call(arguments);
              me._commands.push([
                fname,
                args,
                time
              ]);
            }
          });

          get_cmds.forEach(function(fname) {
            me[fname] = function() {
              var args = Array.prototype.slice.call(arguments);
              return ctx[fname].apply(ctx, args);
            }
          });

          r_props.forEach(function(fname) {
            me[fname] = function() {
              return me._ctx[fname];
            }
          });

          rw_props.forEach(function(fname) {
            me[fname] = function(v) {
              if (typeof(v) != "undefined") {
                // me._ctx[fname] = v;
                me._commands.push([
                  "setProperty", [fname, v],
                  time
                ]);
                return me;
              }
              return me._ctx[fname];
            }
          });


          /*

save()	Saves the state of the current context
restore()	Returns previously saved path state and attributes
createEvent()	 
getContext()	 
toDataURL()	 

createImageData()	Creates a new, blank ImageData object
getImageData()	Returns an ImageData object that copies the pixel data for the specified rectangle on a canvas
putImageData()	Puts the image data (from a specified ImageData object) back onto the canvas

width	Returns the width of an ImageData object
height	Returns the height of an ImageData object
data	Returns an object that contains image data of a specified ImageData object

fillText()	Draws "filled" text on the canvas
strokeText()	Draws text on the canvas (no fill)
measureText()	Returns an object that contains the width of the specified text

font	Sets or returns the current font properties for text content
textAlign	Sets or returns the current alignment for text content
textBaseline	Sets or returns the current text baseline used when drawing text

scale()	Scales the current drawing bigger or smaller
rotate()	Rotates the current drawing
translate()	Remaps the (0,0) position on the canvas
transform()	Replaces the current transformation matrix for the drawing
setTransform()	Resets the current transform to the identity matrix. Then runs transform()

fill()	Fills the current drawing (path)
stroke()	Actually draws the path you have defined
beginPath()	Begins a path, or resets the current path
moveTo()	Moves the path to the specified point in the canvas, without creating a line
closePath()	Creates a path from the current point back to the starting point
lineTo()	Adds a new point and creates a line from that point to the last specified point in the canvas
clip()	Clips a region of any shape and size from the original canvas
quadraticCurveTo()	Creates a quadratic Bzier curve
bezierCurveTo()	Creates a cubic Bzier curve
arc()	Creates an arc/curve (used to create circles, or parts of circles)
arcTo()	Creates an arc/curve between two tangents
isPointInPath()	Returns true if the specified point is in the current path, otherwise false

fillStyle	Sets or returns the color, gradient, or pattern used to fill the drawing
strokeStyle	Sets or returns the color, gradient, or pattern used for strokes
shadowColor	Sets or returns the color to use for shadows
shadowBlur	Sets or returns the blur level for shadows
shadowOffsetX	Sets or returns the horizontal distance of the shadow from the shape
shadowOffsetY

createLinearGradient()	Creates a linear gradient (to use on canvas content)
createPattern()	Repeats a specified element in the specified direction
createRadialGradient()	Creates a radial/circular gradient (to use on canvas content)
addColorStop()

lineCap	Sets or returns the style of the end caps for a line
lineJoin	Sets or returns the type of corner created, when two lines meet
lineWidth	Sets or returns the current line width
miterLimit	Sets or returns the maximum miter length
rect()	Creates a rectangle
fillRect()	Draws a "filled" rectangle
strokeRect()	Draws a rectangle (no fill)
clearRect()	Clears the specified pixels within a given rectangle
*/
        });
        _myTrait_.isDirty = function(v) {
          if (typeof(v) != "undefined") {
            this._dirty = v;
            var p;
            if (p = this.parent()) p.isDirty(true);
            return this;
          }
          return this._dirty;
        }
        _myTrait_.paintHead = function(t) {

          return ocPaintHead(this);
        }
        _myTrait_.parent = function(t) {
          if (typeof(t) != "undefined") {
            this._parent = t;
            return this;
          }
          return this._parent;
        }
        _myTrait_.redo = function(t) {
          if (this._commands) {

            var c = this._undoBuffer.pop(),
              time;
            if (c) {
              time = c[2];
              while (c && c[2] == time) {
                this._commands.push(c);
                c = this._undoBuffer.pop();
              }
              if (c) {
                this._undoBuffer.push(c);
              }
            }
          }
        }
        _myTrait_.renderPath = function(pathStr, width, height) {

          var parser = svgPathParser();
          parser.parse(pathStr);
          parser.makePathAbsolute();
          parser.fitPathInto(width, height);

          parser.drawPath(this);

        }
        _myTrait_.renderSvg = function(svgDOM) {

          var pathBuffer = [],
            activePath = null,
            strokePath = null,
            bPathEnd = false,
            testOut,
            ctx = this,
            fillStyle = "none",
            strokeStyle = "black",
            createSettings = {
              tag: "",
              attrs: {

              }
            };
          if (!svgDOM) {
            testOut = _e().g();
          } else {
            testOut = svgDOM.g();
          }

          // to reset the current tag settings...
          var resetSettings = function() {
            createSettings.tag = "";
            createSettings.attrs = {

            };
          }



          ctx.execFn(function(cmd, args, trans) {
            if (cmd == "beginPath") {
              pathBuffer = [];
              bPathEnd = false;
              strokeStyle = "none";
              activePath = testOut.path("", {
                d: "",
                stroke: trans.getStyle("strokeStyle"),
                fill: trans.getStyle("fillStyle"),
                "fill-opacity": trans.getStyle("globalAlpha")
              });
            }


            if (cmd == "drawImage") {

              pathBuffer = [];
              /*
           <image xlink:href="firefox.jpg" x="0" y="0" height="50px" width="50px"/>            
                       */
              activePath = testOut.image("", {
                "xlink:href": args[0],
                x: args[1],
                y: args[2],
                width: args[3],
                height: args[4]
              });

            }


            if (cmd == "circle") {

              pathBuffer = [];

              activePath = testOut.circle("", {
                cx: args[0],
                cy: args[1],
                r: args[2],
                transform: trans.getSvgTransform(),
                stroke: trans.getStyle("strokeStyle"),
                fill: trans.getStyle("fillStyle")
              });

            }


            if (cmd == "rect") {

              pathBuffer = [];

              activePath = testOut.rect("", {
                x: args[0],
                y: args[1],
                width: args[2],
                height: args[3],
                transform: trans.getSvgTransform(),
                stroke: trans.getStyle("strokeStyle"),
                fill: trans.getStyle("fillStyle")
              });

            }

            if (cmd == "arc") {

              var p = trans.transformPoint(args[0], args[1]);
              var p0x = p.x,
                p0y = p.y;

              var pp = trans.transformDelta(args[2], args[2]);

              p0y -= pp.y;

              pathBuffer.push("M " + p0x + " " + p0y);
              pathBuffer.push("A " + pp.x + "," + pp.y + " 0 1,0 " + (p0x + 0.1) + " " + p0y + " ");

            }

            if (cmd == "fillText") {

              var txt = args[0];
              var p = trans.transformPoint(args[1], args[2]);
              var p0x = p.x,
                p0y = p.y;


              var pp = trans.transformDelta(parseInt(trans.getStyle("font-size")), parseInt(trans.getStyle("font-size")));

              var fontSize = pp.x,
                fontFamily = trans.getStyle("font-family");
              // <text x="0" y="15" fill="red">I love SVG!</text>
              activePath = testOut.svg_text("", {
                x: args[1],
                y: args[2]
              });
              activePath.text(txt);

              activePath.q.attr("font-size", parseInt(trans.getStyle("font-size")));
              activePath.q.attr("font-family", fontFamily);
              activePath.q.attr("fill", trans.getStyle("fillStyle"));
              activePath.q.attr("fill-opacity", trans.getStyle("globalAlpha"));

              activePath.q.attr("transform", trans.getSvgTransform());

              bPathEnd = false;
              pathBuffer = [];
              activePath = null;

            }


            if (cmd == "strokeText") {

              var txt = args[0];
              var p = trans.transformPoint(args[1], args[2]);
              var p0x = p.x,
                p0y = p.y;


              var pp = trans.transformDelta(parseInt(trans.getStyle("font-size")), parseInt(trans.getStyle("font-size")));

              var fontSize = pp.x,
                fontFamily = trans.getStyle("font-family");
              // <text x="0" y="15" fill="red">I love SVG!</text>
              activePath = testOut.svg_text("", {
                x: p0x,
                y: p0y
              });
              activePath.text(txt);

              activePath.q.attr("fill", "none");
              activePath.q.attr("font-size", fontSize);
              activePath.q.attr("font-family", fontFamily);
              activePath.q.attr("stroke", trans.getStyle("strokeStyle"));
              activePath.q.attr("stroke-opacity", trans.getStyle("globalAlpha"));

              bPathEnd = false;
              pathBuffer = [];
              activePath = null;

            }


            if (cmd == "quadraticCurveTo") {
              // ctx.bezierCurveTo(20,100,200,100,200,20);
              var sx = trans._point.tx0,
                sy = trans._point.ty0;

              var p = trans.transformPoint(args[0], args[1]);
              var p1x = p.x,
                p1y = p.y;
              var p = trans.transformPoint(args[2], args[3]);
              var p2x = p.x,
                p2y = p.y;

              if (pathBuffer.length == 0)
                pathBuffer.push("M " + sx + " " + sy);
              pathBuffer.push("Q " + p1x + " " + p1y + " " + p2x + " " + p2y + " ");

            }

            if (cmd == "bezierCurveTo") {
              // ctx.bezierCurveTo(20,100,200,100,200,20);
              var sx = trans._point.tx0,
                sy = trans._point.ty0;

              var p = trans.transformPoint(args[0], args[1]);
              var p1x = p.x,
                p1y = p.y;
              var p = trans.transformPoint(args[2], args[3]);
              var p2x = p.x,
                p2y = p.y;
              var p = trans.transformPoint(args[4], args[5]);
              var p3x = p.x,
                p3y = p.y;

              if (pathBuffer.length == 0)
                pathBuffer.push("M " + sx + " " + sy);
              pathBuffer.push("C " + p1x + " " + p1y + " " + p2x + " " + p2y + " " + p3x + " " + p3y + " ");

            }

            if (cmd == "moveTo") {
              var x = trans._point.tx1,
                y = trans._point.ty1,
                sx = trans._point.tx0,
                sy = trans._point.ty0;
              pathBuffer.push("M " + x + " " + y);
            }
            if (cmd == "lineTo") {
              var x = trans._point.tx1,
                y = trans._point.ty1,
                sx = trans._point.tx0,
                sy = trans._point.ty0;

              console.log("lineTo", sx, sy, x, y);
              if (pathBuffer.length == 0)
                pathBuffer.push("M " + sx + " " + sy);
              pathBuffer.push("L " + x + " " + y);
            }
            if (cmd == "stroke") {
              if (activePath) strokePath = activePath;
              activePath = null;
              strokeStyle = "black";
              // if(!bPathEnd) pathBuffer.push("z");
              var path = pathBuffer.join(" ");
              console.log("path", path);
              if (pathBuffer.length) strokePath.q.attr("d", path);
              console.log("new way");
              strokePath.attr({
                "stroke": trans.getStyle("strokeStyle"),
                "stroke-opacity": trans.getStyle("globalAlpha"),
                "stroke-width": trans.transformDelta(trans.getStyle("lineWidth") >> 0, trans.getStyle("lineWidth") >> 0).x || 1
              })

              bPathEnd = true;
            }
            if (cmd == "fill") {
              if (activePath) strokePath = activePath;
              activePath = null;
              if (!bPathEnd) pathBuffer.push("z");
              var path = pathBuffer.join(" ");
              console.log("path", path);
              if (pathBuffer.length) strokePath.q.attr("d", path);
              strokePath.q.attr("stroke", trans.getStyle("strokeStyle"));
              strokePath.q.attr("fill", trans.getStyle("fillStyle"));
              strokePath.q.attr("fill-opacity", trans.getStyle("globalAlpha"));
              bPathEnd = true;
              // activePath.q.attr("fill", args[1]);
            }
            // console.log(cmd, args, trans);
          });
          return testOut;
        }
        _myTrait_.replace = function(name) {

          var args = Array.prototype.slice.call(arguments);
          args.shift();
          var me = this;
          this._commands.forEach(function(f) {
            var fn = f[0];
            if (fn == name) {
              f[1] = args;
              me.isDirty(true);
            }
            if (fn == "setProperty") {
              if (f[1][0] == name) {
                f[1][1] = args[0];
                me.isDirty(true);
              }
            }
          });
        }
        _myTrait_.reset = function(t) {
          var ctx = this._ctx;

          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)
        }
        _myTrait_.serialize = function(t) {

          // Collecting all data...

          var o = {};
          o.commands = this._commands;
          o.inserts = {};

          var iList = this._inserts;
          if (iList) {
            for (var n in iList) {
              if (iList.hasOwnProperty(n)) {
                var list = [];
                iList[n].forEach(function(ch) {
                  list.push(ch.serialize());
                })
                o.inserts[n] = list;
              }
            }
          }
          return o;
        }
        _myTrait_.shadow = function(amount, color) {

          this.shadowBlur(amount);
          this.shadowOffsetX(0);
          this.shadowOffsetY(0);
          this.shadowColor(color || "#000000");
        }
        _myTrait_.shapes = function(t) {

          return ocPathLib(this);
        }
        _myTrait_.svgPathString = function(t) {

          var pathBuffer = [],
            activePath = null,
            strokePath = null,
            bPathEnd = false,
            ctx = this,
            fillStyle = "none",
            resultString = "",
            strokeStyle = "black",
            createSettings = {
              tag: "",
              attrs: {

              }
            };

          // to reset the current tag settings...
          var resetSettings = function() {
            createSettings.tag = "";
            createSettings.attrs = {

            };
          }

          ctx.execFn(function(cmd, args, trans) {
            if (cmd == "beginPath") {
              pathBuffer = [];
              bPathEnd = false;
              strokeStyle = "none";

            }

            if (cmd == "arc") {

              var p = trans.transformPoint(args[0], args[1]);
              var p0x = p.x,
                p0y = p.y;

              var pp = trans.transformDelta(args[2], args[2]);

              p0y -= pp.y;

              pathBuffer.push("M " + p0x + " " + p0y);
              pathBuffer.push("A " + pp.x + "," + pp.y + " 0 1,0 " + (p0x + 0.1) + " " + p0y + " ");

            }

            if (cmd == "quadraticCurveTo") {
              // ctx.bezierCurveTo(20,100,200,100,200,20);
              var sx = trans._point.tx0,
                sy = trans._point.ty0;

              var p = trans.transformPoint(args[0], args[1]);
              var p1x = p.x,
                p1y = p.y;
              var p = trans.transformPoint(args[2], args[3]);
              var p2x = p.x,
                p2y = p.y;

              if (pathBuffer.length == 0)
                pathBuffer.push("M " + sx + " " + sy);
              pathBuffer.push("Q " + p1x + " " + p1y + " " + p2x + " " + p2y + " ");

            }

            if (cmd == "bezierCurveTo") {
              // ctx.bezierCurveTo(20,100,200,100,200,20);
              var sx = trans._point.tx0,
                sy = trans._point.ty0;

              var p = trans.transformPoint(args[0], args[1]);
              var p1x = p.x,
                p1y = p.y;
              var p = trans.transformPoint(args[2], args[3]);
              var p2x = p.x,
                p2y = p.y;
              var p = trans.transformPoint(args[4], args[5]);
              var p3x = p.x,
                p3y = p.y;

              if (pathBuffer.length == 0)
                pathBuffer.push("M " + sx + " " + sy);
              pathBuffer.push("C " + p1x + " " + p1y + " " + p2x + " " + p2y + " " + p3x + " " + p3y + " ");

            }

            if (cmd == "moveTo") {
              var x = trans._point.tx1,
                y = trans._point.ty1,
                sx = trans._point.tx0,
                sy = trans._point.ty0;
              pathBuffer.push("M " + x + " " + y);
            }
            if (cmd == "lineTo") {
              var x = trans._point.tx1,
                y = trans._point.ty1,
                sx = trans._point.tx0,
                sy = trans._point.ty0;

              // console.log("lineTo", sx,sy, x,y);
              if (pathBuffer.length == 0)
                pathBuffer.push("M " + sx + " " + sy);
              pathBuffer.push("L " + x + " " + y);
            }

            if (cmd == "stroke") {
              if (pathBuffer.length > 0) {
                if (!resultString) {
                  resultString = pathBuffer.join(" ");
                }
              }
            }
            if (cmd == "fill") {
              if (pathBuffer.length > 0) {
                if (!resultString) {
                  resultString = pathBuffer.join(" ");
                }
              }
            }
            // console.log(cmd, args, trans);
          });

          if (pathBuffer.length > 0) {
            if (!resultString) {
              resultString = pathBuffer.join(" ");
            }
          }
          return resultString;
        }
        _myTrait_.undo = function(t) {
          if (this._commands) {
            var c = this._commands.pop(),
              time;
            if (c) {
              time = c[2];
              while (c && c[2] == time) {
                this._undoBuffer.push(c);
                c = this._commands.pop();
              }
              if (c) {
                this._commands.push(c);
              }
            }

            console.log(this._commands);
          }
        }
        _myTrait_.unserialize = function(data) {
          /*var o = {};
           o.commands = this._commands;
           o.inserts = {};
           
           var iList = this._inserts;
           if(iList) {
               for(var n in iList) {
                   if(iList.hasOwnProperty(n)) {
                       var list = [];
                       iList[n].forEach( function(ch) {
                           list.push(ch.serialize());
                       })
                       o.inserts[n] = list;
                   }
               }
           }
           return o;
           */

          var o = canvasContext();

          o._commands = data.commands;
          var iList = data.inserts;
          if (iList) {
            o._inserts = {};
            for (var n in iList) {
              if (iList.hasOwnProperty(n)) {
                var list = [];
                iList[n].forEach(function(data) {
                  list.push(canvasContext().unserialize(data));
                })
                o._inserts[n] = list;
              }
            }
          }
          return o;
        }
      }(this));
    }
    var canvasContext = function(a, b, c, d, e, f, g, h) {
      if (this instanceof canvasContext) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != canvasContext._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new canvasContext(a, b, c, d, e, f, g, h);
    };
    canvasContext._classInfo = {
      name: 'canvasContext'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("canvasContext", canvasContext)
    canvasContext.prototype = new canvasContext_prototype();
    if (typeof(window) != 'undefined') window['canvasContext'] = canvasContext;
    if (typeof(window) != 'undefined') window['canvasContext_prototype'] = canvasContext_prototype;
    var svgPathParser_prototype = function() {
      var jsVectors_prototype = function() {;
        (function(_myTrait_) {
          var projectionMatrix;
          var jVect;
          var iVect;
          var pBase;
          var tn1;
          var nv1;
          var barCoeffs;
          var deVector;
          _myTrait_.add = function(v1, v2) {

            v1.x = v1.x + v2.x;
            v1.y = v1.y + v2.y;

          }
          _myTrait_.angleBetween = function(v1, v2) {

            var n1 = this.normalize({
              x: v1.x,
              y: v1.y
            });
            var n2 = this.normalize({
              x: v2.x,
              y: v2.y
            });

            var cp = this.crossProd(n1, n2);
            var dp = this.dotProd(n1, n2);

            var a = Math.acos(dp);
            if (cp < 0) a = a * -1; // other side...
            return a;

          }
          _myTrait_.calc_cat = function(t, p0, p1, p2, p3) {

            var t2 = t * t;
            var t3 = t2 * t;
            return (0.5 * ((2 * p1) + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 + (-p0 + 3 * p1 - 3 * p2 + p3) * t3));

          }
          _myTrait_.crossProd = function(v1, v2) {

            // U x V = Ux*Vy-Uy*Vx
            return v1.x * v2.y - v1.y * v2.x;

          }
          _myTrait_.diff = function(p1, p2) {

            return {
              x: p2.x - p1.x,
              y: p2.y - p1.y
            };

          }
          _myTrait_.dist = function(p1, p2) {

            var dx = p1.x - p2.x;
            var dy = p1.y - p2.y;
            return Math.sqrt(dx * dx + dy * dy);

          }
          _myTrait_.dotProd = function(v1, v2) {

            return v1.x * v2.x + v1.y * v2.y;

          }
          _myTrait_.getBarCoeffs = function(p0, p1, p2) {

            var bb = barCoeffs;
            bb.A = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
            bb.sign = bb.A < 0 ? -1 : 1;
            bb.s1 = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y)) * bb.sign;
            bb.s2 = (p2.y - p0.y) * bb.sign;
            bb.s3 = (p0.x - p2.x) * bb.sign;
            bb.t1 = (p0.x * p1.y - p0.y * p1.x) * bb.sign;
            bb.t2 = (p0.y - p1.y) * bb.sign;
            bb.t3 = (p1.x - p0.x) * bb.sign;
            return bb;

          }
          if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
            _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
          if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
          _myTrait_.__traitInit.push(function(t) {

            if (!tn1) {

              tn1 = {
                x: 0,
                y: 0
              };
              nv1 = {
                x: 0,
                y: 0
              };

              projectionMatrix = [0, 0, 0, 0];

              jVect = {
                x: 0,
                y: 0
              };
              iVect = {
                x: 0,
                y: 0
              };
              pBase = {
                x: 0,
                y: 0
              };

              barCoeffs = {
                Area: 0,
                s1: 0,
                s2: 0,
                s3: 0,
                t1: 0,
                t2: 0,
                t3: 0,
                sign: 0
              };
              deVector = {
                x: 0,
                y: 0
              };

            }
          });
          _myTrait_.initProjection = function(p1, p2) {

            iVect.y = p2.y - p1.y;
            iVect.x = p2.x - p1.x;

            jVect.y = iVect.y;
            jVect.x = iVect.x;

            this.normalize(iVect);
            this.normalize(jVect);

            this.rotate(jVect, Math.PI / 2);

            pBase.x = p1.x;
            pBase.y = p1.y;


          }
          _myTrait_.length = function(p1) {

            var dx = p1.x;
            var dy = p1.y;
            return Math.sqrt(dx * dx + dy * dy);

          }
          _myTrait_.linesIntersect = function(p0, p1, v0, v1) {

            var x1 = p0.x,
              y1 = p0.y,
              x2 = p1.x,
              y2 = p1.y,
              x3 = v0.x,
              y3 = v0.y,
              x4 = v1.x,
              y4 = v1.y;

            var x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));
            var y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));
            if (isNaN(x) || isNaN(y)) {
              return false;
            } else {
              if (x1 >= x2) {
                if (!(x2 <= x && x <= x1)) {
                  return false;
                }
              } else {
                if (!(x1 <= x && x <= x2)) {
                  return false;
                }
              }
              if (y1 >= y2) {
                if (!(y2 <= y && y <= y1)) {
                  return false;
                }
              } else {
                if (!(y1 <= y && y <= y2)) {
                  return false;
                }
              }
              if (x3 >= x4) {
                if (!(x4 <= x && x <= x3)) {
                  return false;
                }
              } else {
                if (!(x3 <= x && x <= x4)) {
                  return false;
                }
              }
              if (y3 >= y4) {
                if (!(y4 <= y && y <= y3)) {
                  return false;
                }
              } else {
                if (!(y3 <= y && y <= y4)) {
                  return false;
                }
              }
            }
            return true;

          }
          _myTrait_.mirrorVector = function(v1, along, base) {

            // the direction tangent and normal are normalized and the vector is projected into it            
            tn1.x = along.x - base.x;
            tn1.y = along.y - base.y;
            nv1.x = -tn1.y;
            nv1.y = tn1.x;

            v1.x = v1.x - base.x;
            v1.y = v1.y - base.y;

            // if the 'j' or normal projection is positive, turn around
            if (this.dotProd(v1, nv1) > 0)
              this.rotate(nv1, Math.PI);

            this.normalize(tn1);
            this.normalize(nv1);

            // Create positive coordinates of the projection of the vector to the 'base' cordinates
            var nvProd = Math.abs(this.dotProd(v1, nv1));
            //             tnProd = Math.abs( this.dotProd(v1,tn1) );

            var tnProd = this.dotProd(v1, tn1);
            // then, project the length of the base vectors to get the new vector space
            v1.x = nv1.x * nvProd + tn1.x * tnProd,
            v1.y = nv1.y * nvProd + tn1.y * tnProd;

            v1.x += base.x;
            v1.y += base.y;

            return v1;

          }
          _myTrait_.normalize = function(v) {

            var len = Math.sqrt(v.x * v.x + v.y * v.y);

            if (len == 0) {
              throw "Error normalizing vector: the length of the vector was zero";
            }

            v.x = v.x / len;
            v.y = v.y / len;
            return v;

          }
          _myTrait_.opposeVector = function(v1, along) {


            // the direction tangent and normal are normalized and the vector is projected into it            
            tn1.x = along, x;
            tn1.y = along.y;
            nv1.x = -tn1.y;
            nv1.y = tn1.x;

            this.normalize(tn1);
            this.normalize(nv1);

            // Important: turn the tangent to opposing direction...
            this.rotate(tn1, Math.PI);

            // Create the projection of the vector to the 'base' cordinates
            var nvProd = Math.abs(jsMath.dotProd(v1, nv1)),
              tnProd = Math.abs(jsMath.dotProd(v1, tn1));

            // if the 'j' or normal projection is negative, turn around
            if (this.dotProd(v1, nv1) < 0)
              this.rotate(nv1, Math.PI);

            // then, project the length of the vector to get the new vector
            v1.x = nv1.x * nvProd + tn1.x * tnProd,
            v1.y = nv1.y * nvProd + tn1.y * tnProd;

            return v1;

          }
          _myTrait_.pointInTriangle = function(p, p0, p1, p2) {


            var A = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
            var sign = A < 0 ? -1 : 1;
            var s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
            var t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;

            return s > 0 && t > 0 && (s + t) < 2 * A * sign;


          }
          _myTrait_.pointInTriangleBc = function(p, bb) {

            var A = bb.A;
            var sign = bb.sign;
            var s = (bb.s1 + bb.s2 * p.x + bb.s3 * p.y);
            var t = (bb.t1 + bb.t2 * p.x + bb.t3 * p.y);

            return s > 0 && t > 0 && (s + t) < 2 * A * sign;


          }
          _myTrait_.project = function(vectorToProject) {


            var p = vectorToProject;

            pVector.x = p.x - pBase.x;
            pVector.y = p.y - pBase.y;

            prodResult.i = this.dotProd(pVector, iVect);
            prodResult.j = this.dotProd(pVector, jVect);

            return prodResult;

          }
          _myTrait_.rotate = function(v, angle) {


            var s = Math.sin(angle);
            var c = Math.cos(angle);

            var x = v.x,
              y = v.y;

            v.x = x * c + y * s;
            v.y = -x * s + y * c;

            return v;

          }
          _myTrait_.rotateAround = function(angle, v, around) {

            this.sub(v, around);
            this.rotate(v, angle);
            this.add(v, around);

          }
          _myTrait_.sub = function(v1, v2) {

            v1.x = v1.x - v2.x;
            v1.y = v1.y - v2.y;

          }
          _myTrait_.tangentNormal = function(v1, v2, v3) {


            var t1 = {};
            t1.x = v2.x - v1.x;
            t1.y = v2.y - v1.y;
            var t2 = {};
            t2.x = v3.x - v2.x;
            t2.y = v3.y - v2.y;

            var p = {
              x: t1.x + t2.x,
              y: t1.y + t2.y
            };
            return this.normalize(p);

          }
          _myTrait_.triangleArea = function(A, B, C) {


            var area = A.x * (B.y - C.y) +
              B.x * (C.y - A.y) +
              C.x * (A.y - B.y);

            return Math.abs(area / 2);

          }
          _myTrait_.triangleInTriangle = function(p0, p1, p2, q0, q1, q2) {


            var bb = this.getBarCoeffs(p0, p1, p2);

            if (this.pointInTriangleBc(q0, bb)) return true;
            if (this.pointInTriangleBc(q1, bb)) return true;
            if (this.pointInTriangleBc(q2, bb)) return true;

            var bb = this.getBarCoeffs(q0, q1, q2);

            if (this.pointInTriangleBc(p0, bb)) return true;
            if (this.pointInTriangleBc(p1, bb)) return true;
            if (this.pointInTriangleBc(p2, bb)) return true;


            if (this.linesIntersect(p0, p1, q0, q1)) return true;
            if (this.linesIntersect(p1, p2, q0, q1)) return true;
            if (this.linesIntersect(p2, p0, q0, q1)) return true;

            if (this.linesIntersect(p0, p1, q1, q2)) return true;
            if (this.linesIntersect(p1, p2, q1, q2)) return true;
            if (this.linesIntersect(p2, p0, q1, q2)) return true;

            if (this.linesIntersect(p0, p1, q2, q0)) return true;
            if (this.linesIntersect(p1, p2, q2, q0)) return true;
            if (this.linesIntersect(p2, p0, q2, q0)) return true;

            return false;

          }
          _myTrait_.unProject = function(projectedVector) {

            var p = projectedVector;
            deVector.x = p.i * iVect.x + p.j * jVect.x;
            deVector.y = p.i * iVect.y + p.j * jVect.y;

            deVector.x += pBase.x;
            deVector.y += pBase.y;
            return deVector;

          }
        }(this));
      }
      var jsVectors = function(a, b, c, d, e, f, g, h) {
        if (this instanceof jsVectors) {
          var args = [a, b, c, d, e, f, g, h];
          if (this.__factoryClass) {
            var m = this;
            var res;
            this.__factoryClass.forEach(function(initF) {
              res = initF.apply(m, args);
            });
            if (Object.prototype.toString.call(res) == '[object Function]') {
              if (res._classInfo.name != jsVectors._classInfo.name) return new res(a, b, c, d, e, f, g, h);
            } else {
              if (res) return res;
            }
          }
          if (this.__traitInit) {
            var m = this;
            this.__traitInit.forEach(function(initF) {
              initF.apply(m, args);
            })
          } else {
            if (typeof this.init == 'function')
              this.init.apply(this, args);
          }
        } else return new jsVectors(a, b, c, d, e, f, g, h);
      };
      jsVectors._classInfo = {
        name: 'jsVectors'
      };
      if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("jsVectors", jsVectors)
      jsVectors.prototype = new jsVectors_prototype();
      if (typeof(window) != 'undefined') window['jsVectors'] = jsVectors;
      if (typeof(window) != 'undefined') window['jsVectors_prototype'] = jsVectors_prototype;;
      (function(_myTrait_) {
        var _parsedData;
        _myTrait_.drawPath = function(ctx, w, h) {
          var _firstX, _firstY, x, y;
          ctx.beginPath();
          this._all.forEach(function(cmd) {

            if (cmd.name == "M") {

              x = cmd.points[0];
              y = cmd.points[1];
              ctx.moveTo(x, y);

            }

            if (cmd.name == "m") {

              x = x + cmd.points[0];
              y = y + cmd.points[1];
              ctx.moveTo(x, y);

            }

            if (cmd.name == "q") {
              for (var s = 0; s < cmd.points.length; s += 4) {
                var p = cmd.points;
                var x0 = x + p[s + 0],
                  y0 = y + p[s + 1];
                //x=x0; y=y0;
                var x1 = x + p[s + 2],
                  y1 = y + p[s + 3];
                x = x1;
                y = y1;
                ctx.quadraticCurveTo(x0, y0, x1, y1, x2, y2);
              }
            }

            // Not relative coordinates... the algo is much simpler here...
            if (cmd.name == "Q") {
              var p = cmd.points,
                len = cmd.points.length;
              for (var s = 0; s < len; s += 4) {
                ctx.quadraticCurveTo(p[s + 0], p[s + 1], p[s + 2], p[s + 3]);
              }
            }

            if (cmd.name == "c") {
              for (var s = 0; s < cmd.points.length; s += 6) {
                var p = cmd.points;
                var x0 = x + p[s + 0],
                  y0 = y + p[s + 1];
                //x=x0; y=y0;
                var x1 = x + p[s + 2],
                  y1 = y + p[s + 3];
                // x=x1; y=y1;
                var x2 = x + p[s + 4],
                  y2 = y + p[s + 5];
                x = x2;
                y = y2;
                ctx.bezierCurveTo(x0, y0, x1, y1, x2, y2);
              }
            }

            // Not relative coordinates... the algo is much simpler here...
            if (cmd.name == "C") {
              var p = cmd.points,
                len = cmd.points.length;
              for (var s = 0; s < len; s += 6) {
                ctx.bezierCurveTo(p[s + 0], p[s + 1], p[s + 2], p[s + 3], p[s + 4], p[s + 5]);
              }
            }
            if (cmd.name == "l") {
              for (var s = 0; s < cmd.points.length; s += 2) {
                var p = cmd.points;
                var x0 = x + p[s + 0],
                  y0 = y + p[s + 1];
                x = x0;
                y = y0;
                ctx.lineTo(x0, y0);
              }
            }

            if (cmd.name == "H") {
              for (var s = 0; s < cmd.points.length; s++) {
                var p = cmd.points;
                var x0 = p[s + 0];
                x = x0;
                ctx.lineTo(x0, y);
              }
            }

            if (cmd.name == "V") {
              for (var s = 0; s < cmd.points.length; s++) {
                var p = cmd.points;
                var y0 = p[s + 0];
                y = y0;
                ctx.lineTo(x, y0);
              }
            }


            if (cmd.name == "L") {
              for (var s = 0; s < cmd.points.length; s += 2) {
                var p = cmd.points;
                var x0 = p[s + 0],
                  y0 = p[s + 1];
                x = x0;
                y = y0;
                ctx.lineTo(x0, y0);
              }
            }

            if (cmd.name == "z") {
              ctx.closePath();
            }
          })


        }
        _myTrait_.findDimensions = function() {


          if (this._limits) return this._limits;

          var _firstX, _firstY;

          var _minX, _minY, _maxX, _maxY,
            x, y;

          var limits = function(x, y) {

            if (typeof(_minX) == "undefined") {
              _minX = x;
              _maxX = x;
              _minY = y;
              _maxY = y;
            }
            _minX = Math.min(_minX, x);
            _minY = Math.min(_minY, y);
            _maxX = Math.max(_maxX, x);
            _maxY = Math.max(_maxY, y);

          }

          this._all.forEach(function(cmd) {

            if (cmd.name == "M") {

              x = cmd.points[0];
              y = cmd.points[1];

              limits(x, y);

            }

            if (cmd.name == "m") {

              x = x + cmd.points[0];
              y = y + cmd.points[1];
              limits(x, y);

            }

            if (cmd.name == "c") {
              for (var s = 0; s < cmd.points.length; s += 6) {
                var p = cmd.points;
                var x0 = x + p[s + 0],
                  y0 = y + p[s + 1];
                //x=x0; y=y0;
                var x1 = x + p[s + 2],
                  y1 = y + p[s + 3];
                // x=x1; y=y1;
                var x2 = x + p[s + 4],
                  y2 = y + p[s + 5];

                limits(x0, y0);
                limits(x1, y1);
                limits(x2, y2);
                x = x2;
                y = y2;

              }
            }

            if (cmd.name == "C") {
              var p = cmd.points,
                len = cmd.points.length;
              for (var s = 0; s < len; s += 6) {
                limits(p[s + 0], p[s + 1]);
                limits(p[s + 2], p[s + 3]);
                limits(p[s + 4], p[s + 5]);
              }
            }
            if (cmd.name == "l") {
              for (var s = 0; s < cmd.points.length; s += 2) {
                var p = cmd.points;
                var x0 = x + p[s + 0],
                  y0 = y + p[s + 1];
                x = x0;
                y = y0;
                limits(x, y);
              }
            }

            if (cmd.name == "L") {
              for (var s = 0; s < cmd.points.length; s += 2) {
                var p = cmd.points;
                var x0 = p[s + 0],
                  y0 = p[s + 1];
                x = x0;
                y = y0;
                limits(x, y);
              }
            }
          });

          // NOTE: in these SVG photos created by the potrace the y-axis
          // is reversed, so the maxY is actually the minY 
          this._limits = [_minX, _minY, _maxX, _maxY];
          return this._limits;

        }
        _myTrait_.fitPathInto = function(w, h) {


          // return;
          var dim = this.findDimensions();

          // console.log(dim);

          var allIn = true;
          for (var i = 0; i < 4; i++) {
            if (dim[i] < 0 || dim[i] > w) allIn = false;
          }
          //       if(allIn) return;

          var drawW = Math.abs(dim[2] - dim[0]),
            drawH = Math.abs(dim[3] - dim[1]);

          var flipY = false;
          // the biggest Y is lie -100 and smalles -800 then we should
          // flip the coordinates...
          if (Math.abs(dim[3]) < Math.abs(dim[1])) {
            flipY = true;
          }

          var scale1 = w / drawW,
            scale2 = h / drawH,
            transX = -dim[0],
            transY = -dim[1];

          var scaleX = Math.min(scale1, scale2),
            scaleY = scaleX;


          if (flipY) {
            scaleY = -scaleY;
            transY = -dim[3]; // for example if -100 => +100
          }

          var tx = function(x) {
            return (x + transX) * scaleX;
          }
          var ty = function(y) {
            return (y + transY) * scaleY;
          }

          this._all.forEach(function(cmd) {

            if (cmd.name == "M") {

              cmd.points[0] = tx(cmd.points[0]);
              cmd.points[1] = ty(cmd.points[1]);
            }
            if (cmd.name == "m") {
              cmd.points[0] *= scaleX;
              cmd.points[1] *= scaleY;

            }

            if (cmd.name == "L") {
              for (var s = 0; s < cmd.points.length; s += 2) {
                var p = cmd.points;
                p[s + 0] = tx(p[s + 0]);
                p[s + 1] = ty(p[s + 1]);
              }
            }

            if (cmd.name == "c") {
              for (var s = 0; s < cmd.points.length; s += 6) {
                var p = cmd.points;
                p[s + 0] *= scaleX;
                p[s + 2] *= scaleX;
                p[s + 4] *= scaleX;
                p[s + 1] *= scaleY;
                p[s + 3] *= scaleY;
                p[s + 5] *= scaleY;
              }
            }

            // Not relative coordinates... the algo is much simpler here...
            if (cmd.name == "C") {
              var p = cmd.points,
                len = cmd.points.length;
              for (var s = 0; s < len; s += 6) {
                p[s + 0] = tx(p[s + 0]);
                p[s + 2] = tx(p[s + 2]);
                p[s + 4] = tx(p[s + 4]);
                p[s + 1] = ty(p[s + 1]);
                p[s + 3] = ty(p[s + 3]);
                p[s + 5] = ty(p[s + 5]);
              }
            }

            if (cmd.name == "Q") {
              var p = cmd.points,
                len = cmd.points.length;
              for (var s = 0; s < len; s += 4) {
                p[s + 0] = tx(p[s + 0]);
                p[s + 2] = tx(p[s + 2]);
                p[s + 1] = ty(p[s + 1]);
                p[s + 3] = ty(p[s + 3]);
              }
            }

            if (cmd.name == "l") {
              for (var s = 0; s < cmd.points.length; s += 2) {
                var p = cmd.points;
                p[s + 0] *= scaleX;
                p[s + 1] *= scaleY;
              }
            }


          });

          this._limits = null;


        }
        _myTrait_.forCmds = function(fn) {
          this._all.forEach(fn);
        }
        _myTrait_.fromBezierArray = function(list) {



          var x, y, i, plen = list.length;

          var target = this._all;

          this._all = [];

          for (var i = 0; i < plen; i++) {

            var bez = list[i];

            if (i == 0) {
              var c = {
                name: "M",
                points: [
                  bez.point_x(0), bez.point_y(0)
                ]
              };

              this._all.push(c);
            }
            var c = {
              name: "C",
              points: [
                bez.point_x(1), bez.point_y(1),
                bez.point_x(2), bez.point_y(2),
                bez.point_x(3), bez.point_y(3)
              ]
            };

            this._all.push(c);
          }

          this.saveToOriginals();

        }
        _myTrait_.getCommands = function(t) {
          return this._all;
        }
        _myTrait_.getPath = function(i) {

          return this._all[i];
        }
        _myTrait_.getSegmentCount = function(t) {

          var last = this._all.length;
          if (this._all[last - 1].name == "z") last--;

          return last;
        }
        _myTrait_.getSubPaths = function(t) {
          return this._subPaths;
        }
        if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
          _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
        if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
        _myTrait_.__traitInit.push(function(w, h, intoDom) {
          this._activeCmd = null;
          this._all = [];
          this._stringLeft = "";

          this._original = null;

          this._x = 0;
          this._y = 0;

          if (!_parsedData) {
            _parsedData = {};
          }
        });
        _myTrait_.initCmd = function(n) {
          this._activeCmd = {
            name: n,
            points: []
          };
          this._all.push(this._activeCmd);
          return this._activeCmd;

        }
        _myTrait_.inverse = function(t) {
          var all = this.originals();

          var point = {
            x: 0,
            y: 0
          };

          var x, y, i, plen = all.length;

          this._all.reverse();

          var target = this._all;
          var all = this._all;

          var newCmds = [];

          var getPrevPoints = function(currCmd, prevCmd) {
            var res = [];
            var n = (currCmd.points.length / 2),
              i = currCmd.points.length - 4;
            while (n > 0) {
              if (n == 1) {
                if (!prevCmd) return res;
                i = prevCmd.points.length - 2;
                res.push(prevCmd.points[i]);
                res.push(prevCmd.points[i + 1]);
              } else {
                res.push(currCmd.points[i]);
                res.push(currCmd.points[i + 1]);
                i -= 2;
              }
              n--;
            }
            return res;
          };

          if (all[0].name == "z") {
            all.shift();
            // plen--;
          }

          for (var i = 0; i < plen; i++) {

            var cmd = all[i],
              tCmd = all[i],
              nextCmd = all[i + 1],
              prevCmd;

            if (!cmd) break;
            if (i > 0) prevCmd = all[i - 1];

            if (i == 0) {
              var ii = cmd.points.length - 2;
              var cc = {
                name: "M",
                points: [
                  cmd.points[ii], cmd.points[ii + 1]
                ]
              };
              newCmds.push(cc);
            } else {
              var cc = {
                name: prevCmd.name,
                points: getPrevPoints(prevCmd, cmd)
              };
              newCmds.push(cc);
            }
          }

          var cc = {
            name: "z",
            points: []
          };
          newCmds.push(cc);

          // console.log(newCmds);

          this._all = newCmds;
        }
        _myTrait_.makePathAbsolute = function() {


          var _firstX, _firstY;
          var x, y,
            lastBx, lastBy,
            bNoBx = true;

          var firstSmoothPoint = function() {
            if (bNoBx) {
              lastBx = x;
              lastBy = y;
            }
            var dx = x - lastBx,
              dy = y - lastBy;
            return {
              x: x + dx,
              y: y + dy
            };
          }
          this._all.forEach(function(cmd) {

            if (cmd.name == "M") {
              x = cmd.points[0];
              y = cmd.points[1];
              bNoBx = true;
            }

            if (cmd.name == "L") {
              x = cmd.points[0];
              y = cmd.points[1];
              bNoBx = true;
            }

            if (cmd.name == "m") {

              x = x + cmd.points[0];
              y = y + cmd.points[1];

              cmd.points[0] = x;
              cmd.points[1] = y;
              cmd.name = "M";
              bNoBx = true;
            }

            if (cmd.name == "q") {
              for (var s = 0; s < cmd.points.length; s += 4) {
                var p = cmd.points;

                p[s + 0] = x + p[s + 0];
                p[s + 1] = y + p[s + 1];
                p[s + 2] = x + p[s + 2];
                p[s + 3] = y + p[s + 3];
                x = p[s + 2];
                y = p[s + 3];
                cmd.name = "Q";
              }
              bNoBx = true;
            }
            if (cmd.name == "C") {
              var p = cmd.points;
              lastBx = p[2];
              lastBy = p[3];

              x = p[4];
              y = p[5];
              bNoBx = false;
            }
            if (cmd.name == "c") {
              for (var s = 0; s < cmd.points.length; s += 6) {
                var p = cmd.points;

                p[s + 0] = x + p[s + 0];
                p[s + 1] = y + p[s + 1];
                p[s + 2] = x + p[s + 2];
                p[s + 3] = y + p[s + 3];
                p[s + 4] = x + p[s + 4];
                p[s + 5] = y + p[s + 5];
                x = p[s + 4];
                y = p[s + 5];
                lastBx = p[s + 2];
                lastBy = p[s + 3];
                cmd.name = "C";
              }
              bNoBx = false;
            }

            if (cmd.name == "S") {
              var p = cmd.points;
              var first = firstSmoothPoint();
              var newPoints = [];
              newPoints[0] = first.x;
              newPoints[1] = first.y;
              newPoints[2] = p[0];
              newPoints[3] = p[1];
              newPoints[4] = p[2];
              newPoints[5] = p[3];
              x = newPoints[4];
              y = newPoints[5];
              lastBx = newPoints[2];
              lastBy = newPoints[3];
              cmd.name = "C";
              cmd.points = newPoints;
              bNoBx = false;
            }
            if (cmd.name == "s") {
              var p = cmd.points;
              var first = firstSmoothPoint();
              var newPoints = [];
              newPoints[0] = first.x;
              newPoints[1] = first.y;
              newPoints[2] = x + p[0];
              newPoints[3] = y + p[1];
              newPoints[4] = x + p[2];
              newPoints[5] = y + p[3];
              x = newPoints[4];
              y = newPoints[5];
              lastBx = newPoints[2];
              lastBy = newPoints[3];
              cmd.name = "C";
              cmd.points = newPoints;
              bNoBx = false;
            }

            if (cmd.name == "h") {
              bNoBx = true;
              for (var s = 0; s < cmd.points.length; s++) {
                var p = cmd.points;
                var x0 = x + p[s + 0];
                x = x0;
                p[s + 0] = x0;
                cmd.points = [x0, y];
                cmd.name = "L";
                return;
              }
            }

            if (cmd.name == "H") {
              bNoBx = true;
              for (var s = 0; s < cmd.points.length; s++) {
                var p = cmd.points;
                var x0 = p[s + 0];
                x = x0;
                p[s + 0] = x0;
                cmd.points = [x0, y];
                cmd.name = "L";
                return;
              }
            }

            if (cmd.name == "V") {
              bNoBx = true;
              for (var s = 0; s < cmd.points.length; s++) {
                var p = cmd.points;
                //console.log("--- V ----");
                //console.log("Point cnt ", cmd.points.length);
                //console.log(p, "y : ",y, " delta :  ",p[s+0]);
                var y0 = p[s + 0];
                y = y0;
                //console.log("After add : ",y, "and y0 = ", y0);
                cmd.points = [x, y0];
                cmd.name = "L";
                //console.log(cmd);
                return;
              }
            }

            if (cmd.name == "v") {
              bNoBx = true;
              for (var s = 0; s < cmd.points.length; s++) {
                var p = cmd.points;
                var y0 = y + p[s + 0];
                y = y0;
                cmd.points = [x, y0];
                cmd.name = "L";
                return;
              }
            }



            if (cmd.name == "l") {
              bNoBx = true;
              for (var s = 0; s < cmd.points.length; s += 2) {
                var p = cmd.points;
                var x0 = x + p[s + 0],
                  y0 = y + p[s + 1];
                x = x0;
                y = y0;
                p[s + 0] = x0;
                p[s + 1] = y0;
                cmd.name = "L";
              }
            }
          })


        }
        _myTrait_.normalize = function() {

          this.makePathAbsolute();
          this.fitPathInto(800, 800);

        }
        _myTrait_.originals = function() {

          if (!this._original) {
            this._original = JSON.parse(JSON.stringify(this._all));
          }
          return this._original;

        }
        _myTrait_.parse = function(str) {
          /*var old;
           if(old = _parsedData[str]) {
               this._all = JSON.parse( old );
               return;
           }*/

          this._activeCmd = null;
          this._all = [];
          this._stringLeft = "";

          this._original = null;

          this._x = 0;
          this._y = 0;

          this._usedCommands = {};
          if (!str) str = "M25.979,12.896 L 5.979,12.896,5.979,19.562,25.979,19.562z";
          var c,
            leftString = str;
          var lastLen = 0;
          var maxCnt = 10000;


          this._subPaths = str.split("M");
          //console.log("Sub paths");
          //console.log(this._subPaths);

          this._subIndex = 0;

          while (leftString = this.popCommand(leftString)) {
            if (leftString.length == 0) break;
            if (leftString.length == lastLen) break;

            if (maxCnt-- < 0) break;

            lastLen = leftString.length;
          }

          // _parsedData[str] = JSON.stringify( this._all );

          // console.log("Used commands", this._usedCommands);
          return this._all;

        }
        _myTrait_.path = function() {

          return this._all;

        }
        _myTrait_.pathFunction = function(t) {
          /*
           this.initBezier();
           var ntCnt = this.getSegmentCount();
           var t1 = ntCnt * t;
           var t_index = Math.floor( t1 );
           var seg = this.getSegmentNro(t_index);
           var sub_t = t1 - t_index;
           
           // for example ntCnt = 10
           // t = 9,5
           var stepLen = 1 / ntCnt,        // 0,1
               nowStep = t_index / ntCnt,  // 0,9
               totStep = t,                // 0,95
               remStep = totStep - nowStep, // 0,05
               relStep = remStep / stepLen; // 0,05 / 0,1 = 0,5
           
           var bez = seg.bezier();
           // console.log("Rel step "+relStep);
           pathFnData.x = bez.x(relStep);
           pathFnData.y = bez.y(relStep);
           var nn = bez.tangent(relStep, true);
           
           pathFnData.normal.x = nn.x;
           pathFnData.normal.y = nn.y;
           
           fn(pathFnData);
           */
        }
        _myTrait_.popCommand = function(str) {


          //console.log("popCommand");
          //console.log(str);

          str = str.trim();

          var cmdStr = str.charAt(0),
            cmd = null;


          // console.log("Command : "+cmdStr);



          if (cmdStr == "M") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "m") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "Q") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "q") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "S") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "s") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "C") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "c") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "H") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "h") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "V") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "v") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "L") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "l") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "Z") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          if (cmdStr == "z") {
            cmd = this.initCmd(cmdStr);
            str = str.substring(1);
          }

          // Find the points....
          if (cmd) {

            this._usedCommands[cmdStr] = "true";
            str = str.trim();

            var ok = true;

            while (ok && str.length > 0) {

              var firstChar = str.charAt(0);
              if (firstChar == ",") {
                str = str.substring(1);
                str = str.trim();
              }
              var allowed = ["-", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "."];
              var collect = "",
                minusCnt = 0;

              while (allowed.indexOf(str.charAt(0)) >= 0) {
                if (str.charAt(0) == "-") {
                  minusCnt++;
                  if (minusCnt > 1) {
                    break;
                  }
                }
                collect = collect + str.charAt(0);
                str = str.substring(1);
                minusCnt = 1;
              }

              // we have a number
              if (collect.length > 0) {
                //console.log("Found number "+collect);
                cmd.points.push(parseFloat(collect));
              } else {
                // nothing more there...
                //console.log("Did not find number from "+str);
                break;
              }
              str = str.trim();
            }
          }

          if (!cmd) {
            console.error("No command found for");
            console.error(str);
          }

          this._activeCmd = cmd;
          this._stringLeft = str;

          return str;


        }
        _myTrait_.relativePosition = function(t) {

          // perhaps faster would be to manage the bezier array directly...
          var list = this.toBezierArray();
          var ntCnt = list.length;

          var t1 = ntCnt * t;
          var t_index = Math.floor(t1);

          if (t_index >= ntCnt) t_index = ntCnt - 1;
          if (t_index < 0) t_index = 0;

          var bez = list[t_index];
          var sub_t = t1 - t_index;

          // for example ntCnt = 10
          // t = 9,5
          var stepLen = 1 / ntCnt, // 0,1
            nowStep = t_index / ntCnt, // 0,9
            totStep = t, // 0,95
            remStep = totStep - nowStep, // 0,05
            relStep = remStep / stepLen; // 0,05 / 0,1 = 0,5

          var pathFnData = {
            x: 0,
            y: 0,
            normal: {
              x: 0,
              y: 0
            }
          };
          pathFnData.x = bez.x(relStep);
          pathFnData.y = bez.y(relStep);
          var nn = bez.tangent(relStep, true);
          pathFnData.normal.x = nn.x;
          pathFnData.normal.y = nn.y;

          return pathFnData;
        }
        _myTrait_.replacePartWith = function(index, pathStr, invert) {
          var createQuatPath2 = function(str, invert) {
            var parser = svgPathParser();
            parser.parse(str);
            parser.makePathAbsolute();
            var list = parser.toBezierArray();
            parser.fromBezierArray(list);
            if (invert) parser.inverse();
            var qPath = parser.toQuaternionPath();

            var createQuatPath = function(startPoint, refVector) {

              var iter = pathIterator(qPath);
              var ep = iter.endPoint();
              var str = "M 0 0 " + iter.toSvgPath();
              var sp = startPoint;
              /*
                   var refVector = {
                       x : -100,
                       y : 100
                   };*/

              if (refVector.x == 0 && refVector.y == 0) return "";

              var len = Math.sqrt(ep.x * ep.x + ep.y * ep.y),
                refLen = Math.sqrt(refVector.x * refVector.x + refVector.y * refVector.y),
                scale = refLen / len;
              if (len == 0) return str;
              var math = jsVectors();
              var angle = math.angleBetween(ep, refVector);
              // var angle = math.angleBetween(  refVector, ep );
              var str = iter.toSvgPath(sp, quaternion().rotate(angle), function(p) {
                p.d = p.d * scale;
                return p;
              });
              return str;
            }
            return createQuatPath;
          }

          var ppp = this.getPath(index);
          ppp.replaceFunction = createQuatPath2(pathStr, invert);

        }
        _myTrait_.saveToOriginals = function() {

          this._original = JSON.parse(JSON.stringify(this._all));

        }
        _myTrait_.scaleFactor = function(w, h) {

          var dim = this.findDimensions();

          var drawW = Math.abs(dim[2] - dim[0]),
            drawH = Math.abs(dim[3] - dim[1]);

          var scale1 = w / drawW,
            scale2 = h / drawH;
          var x, y;

          var scale = Math.min(scale1, scale2);

          return scale;

        }
        _myTrait_.svgString = function(t) {
          var _firstX, _firstY, x, y,
            str = "";

          //console.log("ALL ");
          //console.log(this._all);
          this._all.forEach(function(cmd) {

            if (cmd.name == "M") {

              x = cmd.points[0];
              y = cmd.points[1];
              str += "M" + x + "," + y + " ";

            }

            if (cmd.name == "m") {

              x = x + cmd.points[0];
              y = y + cmd.points[1];
              str += "M" + x + "," + y + " ";
            }

            if (cmd.name == "q") {

              str += "Q";
              for (var s = 0; s < cmd.points.length; s += 4) {
                var p = cmd.points;
                var x0 = x + p[s + 0],
                  y0 = y + p[s + 1];
                //x=x0; y=y0;
                var x1 = x + p[s + 2],
                  y1 = y + p[s + 3];
                x = x1;
                y = y1;
                str += x0 + "," + y0 + " " + x1 + "," + y1 + " ";
              }
            }

            // Not relative coordinates... the algo is much simpler here...
            if (cmd.name == "Q") {
              var p = cmd.points,
                len = cmd.points.length;
              str += "Q";
              for (var s = 0; s < len; s += 4) {
                var x0 = p[s + 0],
                  y0 = p[s + 1];
                var x1 = p[s + 2],
                  y1 = p[s + 3];
                x = x1;
                y = y1;
                str += x0 + "," + y0 + " " + x1 + "," + y1 + " ";
              }
            }

            if (cmd.name == "c") {
              str += "C";
              for (var s = 0; s < cmd.points.length; s += 6) {
                var p = cmd.points;
                var x0 = x + p[s + 0],
                  y0 = y + p[s + 1];
                //x=x0; y=y0;
                var x1 = x + p[s + 2],
                  y1 = y + p[s + 3];
                // x=x1; y=y1;
                var x2 = x + p[s + 4],
                  y2 = y + p[s + 5];
                x = x2;
                y = y2;
                str += x0 + "," + y0 + " " + x1 + "," + y1 + " " + x2 + "," + y2 + " ";
              }
            }

            // Not relative coordinates... the algo is much simpler here...
            if (cmd.name == "C") {

              var p = cmd.points,
                len = cmd.points.length;

              if (cmd.replaceFunction) {
                var sp = {
                  x: x,
                  y: y
                };
                for (var s = 0; s < len; s += 6) {
                  // str+=p[s+0]+","+p[s+1]+" "+p[s+2]+","+p[s+3]+" "+p[s+4]+","+p[s+5]+" ";
                  x = p[s + 4];
                  y = p[s + 5];
                }
                var ref = {
                  x: x - sp.x,
                  y: y - sp.y
                }
                var strR = cmd.replaceFunction(sp, ref);
                console.log("The inserted path ", strR);
                str += " " + strR + " ";
              } else {
                str += "C";
                for (var s = 0; s < len; s += 6) {
                  str += p[s + 0] + "," + p[s + 1] + " " + p[s + 2] + "," + p[s + 3] + " " + p[s + 4] + "," + p[s + 5] + " ";
                  x = p[s + 4];
                  y = p[s + 5];
                }
              }
            }
            if (cmd.name == "l") {
              str += "L";
              for (var s = 0; s < cmd.points.length; s += 2) {
                var p = cmd.points;
                var x0 = x + p[s + 0],
                  y0 = y + p[s + 1];
                x = x0;
                y = y0;
                str += x0 + "," + y0 + " ";
              }
            }

            if (cmd.name == "H") {
              str += "L";
              for (var s = 0; s < cmd.points.length; s++) {
                var p = cmd.points;
                var x0 = p[s + 0];
                x = x0;
                // ctx.lineTo( x0, y );
                str += x0 + "," + y + " ";
              }
            }

            if (cmd.name == "V") {
              str += "L";
              for (var s = 0; s < cmd.points.length; s++) {
                var p = cmd.points;
                var y0 = p[s + 0];
                y = y0;
                // ctx.lineTo( x, y0 );
                str += x + "," + y0 + " ";
              }
            }


            if (cmd.name == "L") {

              if (cmd.replaceFunction) {
                var sp = {
                  x: x,
                  y: y
                };
                for (var s = 0; s < cmd.points.length; s += 2) {
                  var p = cmd.points;
                  var x0 = p[s + 0],
                    y0 = p[s + 1];
                  x = x0;
                  y = y0;
                }
                var ref = {
                  x: x - sp.x,
                  y: y - sp.y
                }
                var strR = cmd.replaceFunction(sp, ref);
                console.log("The inserted path ", strR);
                str += " " + strR + " ";
              } else {
                str += "L";
                for (var s = 0; s < cmd.points.length; s += 2) {
                  var p = cmd.points;
                  var x0 = p[s + 0],
                    y0 = p[s + 1];
                  x = x0;
                  y = y0;
                  // ctx.lineTo( x0,y0 );
                  str += x0 + "," + y0 + " ";
                }
              }
            }

            if (cmd.name == "z") {
              str += "z";
            }
          });
          return str;


        }
        _myTrait_.toBezierArray = function(t) {
          var _firstX, _firstY, x, y,
            str = "",
            res = [];
          this._all.forEach(function(cmd) {

            if (cmd.name == "M") {

              x = cmd.points[0];
              y = cmd.points[1];

            }

            // Not relative coordinates... the algo is much simpler here...
            if (cmd.name == "Q") {
              var p = cmd.points,
                len = cmd.points.length;
              for (var s = 0; s < len; s += 4) {
                var x0 = p[s + 0],
                  y0 = p[s + 1];
                var x1 = p[s + 2],
                  y1 = p[s + 3];

                var bc = new jsBezierCurve();
                bc.fromQuadCurve({
                  x: x,
                  y: y
                }, {
                  x: x0,
                  y: y0
                }, {
                  x: x1,
                  y: y1
                });
                res.push(bc);
                x = x1;
                y = y1;
              }
            }

            // Not relative coordinates... the algo is much simpler here...
            if (cmd.name == "C") {
              var p = cmd.points,
                len = cmd.points.length;
              for (var s = 0; s < len; s += 6) {

                var x0 = p[s + 0],
                  y0 = p[s + 1];
                var x1 = p[s + 2],
                  y1 = p[s + 3];
                var x2 = p[s + 4],
                  y2 = p[s + 5];
                var bc = new jsBezierCurve();
                bc.fromPoints({
                  x: x,
                  y: y
                }, {
                  x: x0,
                  y: y0
                }, {
                  x: x1,
                  y: y1
                }, {
                  x: x2,
                  y: y2
                });
                res.push(bc);
                x = x2;
                y = y2;
              }
            }


            if (cmd.name == "L") {
              str += "L";
              for (var s = 0; s < cmd.points.length; s += 2) {
                var p = cmd.points;
                var x0 = p[s + 0],
                  y0 = p[s + 1];
                var bc = new jsBezierCurve();
                bc.fromLine({
                  x: x,
                  y: y
                }, {
                  x: x0,
                  y: y0
                });
                res.push(bc);

                x = x0;
                y = y0;
              }
            }

          });
          return res;


        }
        _myTrait_.toQuaternionPath = function(t) {

          var isFirstPoint = true;
          var pv = {
            x: 0,
            y: 0
          };
          var dv = {
            x: 100,
            y: 0
          };
          var lastDv = {
            x: 100,
            y: 0
          };

          var matLib = jsVectors();

          var cmdList = [];

          // {"name":"L","points":[374.29469458855607,171.03419547847162]}
          this.forCmds(function(c) {
            //  main.div().text(JSON.stringify(c));
            var v = {};
            var cmd = {
              cmd: c.name,
              path: []
            };

            var pickQuat = function(x, y) {

              dv.x = x - pv.x;
              dv.y = y - pv.y;
              var dist = Math.sqrt(dv.x * dv.x + dv.y * dv.y);
              if (dist == 0) {
                dv.x += 0.2;
                dv.y += 0.2;
                x += 0.02;
                y += 0.02;
                dist = Math.sqrt(dv.x * dv.x + dv.y * dv.y);
              }
              var r = matLib.angleBetween(lastDv, dv);


              var q = quaternion();
              q.setFromAxisRotation({
                x: 0,
                y: 0,
                z: 1
              }, r);

              if (!isFirstPoint) cmd.path.push({
                q: q,
                d: dist
              });
              isFirstPoint = false;
              pv.x = x;
              pv.y = y;
              lastDv.x = dv.x;
              lastDv.y = dv.y;

            }

            if (c.name == "M") {
              pickQuat(c.points[0], c.points[1]);
            }
            if (c.name == "L") {
              pickQuat(c.points[0], c.points[1]);
            }
            if (c.name == "Q") {
              pickQuat(c.points[0], c.points[1]);
              pickQuat(c.points[2], c.points[3]);
            }
            if (c.name == "C") {
              pickQuat(c.points[0], c.points[1]);
              pickQuat(c.points[2], c.points[3]);
              pickQuat(c.points[4], c.points[5]);
            }
            if (cmd.path.length) cmdList.push(cmd);
          });

          return cmdList;
        }
        _myTrait_.transformPoints = function(fn) {


          // creates a backup of the "all" and then uses the "all" as target
          var all = this.originals();

          var point = {
            x: 0,
            y: 0
          };

          var x, y, i, plen = all.length;

          var target = this._all;


          for (var i = 0; i < plen; i++) {

            var cmd = all[i],
              tCmd = this._all[i];

            if (!cmd) return;


            if (cmd.name == "M") {
              point.x = cmd.points[0];
              point.y = cmd.points[1];
              fn(point);
              tCmd.points[0] = point.x;
              tCmd.points[1] = point.y;

            }

            if (cmd.name == "Q") {
              var p = cmd.points,
                tp = tCmd.points,
                len = cmd.points.length;
              for (var s = 0; s < len; s += 4) {

                point.x = p[s + 0], point.y = p[s + 1];
                fn(point);
                tp[s + 0] = point.x, tp[s + 1] = point.y;

                point.x = p[s + 2], point.y = p[s + 3];
                fn(point);
                tp[s + 2] = point.x, tp[s + 3] = point.y;

              }
            }


            if (cmd.name == "C") {
              var p = cmd.points,
                tp = tCmd.points,
                len = cmd.points.length;
              for (var s = 0; s < len; s += 6) {

                point.x = p[s + 0], point.y = p[s + 1];
                fn(point);
                tp[s + 0] = point.x, tp[s + 1] = point.y;

                point.x = p[s + 2], point.y = p[s + 3];
                fn(point);
                tp[s + 2] = point.x, tp[s + 3] = point.y;

                point.x = p[s + 4], point.y = p[s + 5];
                fn(point);
                tp[s + 4] = point.x, tp[s + 5] = point.y;
              }
            }
            if (cmd.name == "L") {
              for (var s = 0; s < cmd.points.length; s += 2) {
                var p = cmd.points,
                  tp = tCmd.points;
                point.x = p[s + 0], point.y = p[s + 1];
                fn(point);
                tp[s + 0] = point.x, tp[s + 1] = point.y;
              }
            }

          }




        }
      }(this));
    }
    var svgPathParser = function(a, b, c, d, e, f, g, h) {
      if (this instanceof svgPathParser) {
        var args = [a, b, c, d, e, f, g, h];
        if (this.__factoryClass) {
          var m = this;
          var res;
          this.__factoryClass.forEach(function(initF) {
            res = initF.apply(m, args);
          });
          if (Object.prototype.toString.call(res) == '[object Function]') {
            if (res._classInfo.name != svgPathParser._classInfo.name) return new res(a, b, c, d, e, f, g, h);
          } else {
            if (res) return res;
          }
        }
        if (this.__traitInit) {
          var m = this;
          this.__traitInit.forEach(function(initF) {
            initF.apply(m, args);
          })
        } else {
          if (typeof this.init == 'function')
            this.init.apply(this, args);
        }
      } else return new svgPathParser(a, b, c, d, e, f, g, h);
    };
    svgPathParser._classInfo = {
      name: 'svgPathParser'
    };
    if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("svgPathParser", svgPathParser)
    svgPathParser.prototype = new svgPathParser_prototype();
    if (typeof(window) != 'undefined') window['svgPathParser'] = svgPathParser;
    if (typeof(window) != 'undefined') window['svgPathParser_prototype'] = svgPathParser_prototype;;
    (function(_myTrait_) {
      _myTrait_.add = function(items) {
        if (!(items instanceof Array)) {
          items = Array.prototype.slice.call(arguments, 0);
        }
        var me = this;
        items.forEach(function(e) {

          // Now, if this is a function... special case...

          if (Object.prototype.toString.call(e) == '[object Function]') {

            // function value...
            // console.log("_e got a function value");
            var val = e();
            var oo = e(null, true);

            if (typeof(val) == "string") {
              oo.me.on(oo.name, function(o, v) {
                me._dom.innerHTML = v;
              });
              me._dom.innerHTML = val;
            } else {
              if (typeof(val._dom) != "undefined") {
                var e = val;
                if (e._parent) {
                  e._parent.removeChild(e);
                }

                if (!me._children) {
                  me._children = [];
                }
                var ii = me._children.length;
                e._index = ii;
                me._children.push(e);
                e._parent = me;
                e._svg = me._svg;
                me._dom.appendChild(e._dom);

                e.trigger("parent", me);
                me.trigger("child", e);

                oo.me.on(oo.name, function(o, v) {
                  if (v != me) {
                    me.replaceWith(v);
                  }
                });


              }
            }

            return me;
          }



          if (typeof(e) == "string") {
            me._dom.innerHTML = e;
            return me;
          }

          if (typeof(e) == "undefined") return;

          if (typeof(e._dom) != "undefined") {

            if (e._parent) {
              e._parent.removeChild(e);
            }

            if (!me._children) {
              me._children = [];
            }
            var ii = me._children.length;
            e._index = ii;
            me._children.push(e);
            e._parent = me;
            e._svg = me._svg;
            me._dom.appendChild(e._dom);

            e.trigger("parent", me);
            me.trigger("child", e);
          }
        });

        return this;
      }
      _myTrait_.addItem = function(items) {

        if (!(items instanceof Array)) {
          items = Array.prototype.slice.call(arguments, 0);
        }
        var me = this;
        items.forEach(function(e) {
          if (typeof(e) == "string") {
            me._dom.innerHTML = e;
            return me;
          }

          if (typeof(e) == "undefined") return;

          if (typeof(e._dom) != "undefined") {

            if (e._parent) {
              e._parent.removeChild(e);
            }

            if (!me._children) {
              me._children = [];
            }
            var ii = me._children.length;
            e._index = ii;
            me._children.push(e);
            e._parent = me;
            e._svg = me._svg;
            me._dom.appendChild(e._dom);

            e.trigger("parent", me);
            me.trigger("child", e);
          }
        });

        return this;
      }
      _myTrait_.clear = function(t) {
        this._children = [];
        while (this._dom.firstChild) {
          this._dom.removeChild(this._dom.firstChild);
        }
        return this;
      }
      _myTrait_.collectFromDOM = function(elem) {
        // collecting the nodes from DOM -tree...

        var e = _e(elem);
        var len = elem.childNodes.length;

        var alen = elem.attributes.length;
        for (var i = 0; i < alen; i++) {
          var a = elem.attributes[i];
          e.q.attr(a.name, a.value);
        }

        var str = elem.className;
        if (str) {
          str = str + " ";
          console.log(str);
          var classes = str.split(" ");
          var clen = classes.length;
          for (var i = 0; i < clen; i++) {
            var a = classes[i];
            if (a) {
              e.addClass(a);
            }
          }
        }

        if (elem.innerText || elem.textContent) {
          e.text(elem.innerText || elem.textContent);
        }

        for (var i = 0; i < len; i++) {
          var sub = elem.childNodes[i];
          e.add(this.collectFromDOM(sub));
        }

        return e;


      }
      _myTrait_.insertAfter = function(newItem) {

        // referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);

        if (!this._parent) return;
        if (!this._parent._children) return;

        if (newItem == this) {
          console.log("The items were the same!!!");
          return;
        }
        console.log("--- insert after ----");

        // var newItem = _e(a,b,c,d,e,f);
        var myIndex = this._index;
        var chList = this._parent._children;
        if (newItem._parent && (newItem._parent != this._parent)) {
          newItem._parent.removeChild(newItem);
          var myIndex = chList.indexOf(this);
          chList.splice(myIndex + 1, 0, newItem);
          this._parent.reIndex();
        } else {

          if (!newItem._parent) {
            newItem._parent = this._parent;
            chList.splice(myIndex + 1, 0, newItem);
          } else {
            var oldIndex = chList.indexOf(newItem);
            chList.splice(oldIndex, 1);
            var myIndex = chList.indexOf(this);
            console.log("--- insert placing into ", myIndex + 1, " ----");
            chList.splice(myIndex + 1, 0, newItem);
          }
          this._parent.reIndex();
        }

        var pDOM = newItem._dom;
        var mDOM = this._dom;
        mDOM.parentNode.insertBefore(pDOM, mDOM.nextSibling);
      }
      _myTrait_.insertAt = function(i, obj) {

        console.log("Insert at, children len ", this._children.length, " and i = ", i);

        if (i < this._children.length) {
          var ch = this.child(i);
          ch.insertBefore(obj);
        } else {
          // console.log("Calling add()");
          this.add(obj);
        }

        // while(oo && )
      }
      _myTrait_.insertBefore = function(newItem) {

        if (!this._parent) return;
        if (!this._parent._children) return;

        if (newItem == this) {
          console.log("The items were the same!!!");
          return;
        }

        // var newItem = _e(a,b,c,d,e,f);
        var myIndex = this._index;
        var chList = this._parent._children;

        console.log("Parent Child list length ", chList.length);

        if (newItem._parent && (newItem._parent != this._parent)) {
          newItem._parent.removeChild(newItem);
          newItem._parent = this._parent;
          var myIndex = chList.indexOf(this);
          chList.splice(myIndex, 0, newItem);
          this._parent.reIndex();
        } else {
          if (!newItem._parent) {
            newItem._parent = this._parent;
            chList.splice(myIndex, 0, newItem);
          } else {
            var oldIndex = chList.indexOf(newItem);
            if (oldIndex >= 0) chList.splice(oldIndex, 1);
            var myIndex = chList.indexOf(this);
            chList.splice(myIndex, 0, newItem);
            console.log("Splicing at index ", myIndex);
          }
          this._parent.reIndex();
        }

        console.log("Parent Child list length after ", chList.length);

        var pDOM = newItem._dom;
        var mDOM = this._dom;
        mDOM.parentNode.insertBefore(pDOM, mDOM);

        return this;
        /*       
                  if(!this._parent) return;
           if(!this._parent._children) return;
           
           // var newItem = _e(a,b,c,d,e,f);
           var myIndex = this._index;
           
           newItem._parent = this._parent;
           
           this._parent._children.push(newItem);
           
           var chList = this._parent._children;
           chList.splice(myIndex, 0, chList.splice(this._parent._children.length-1, 1)[0]);
           
           var i=0;
           chList.forEach(function(ch) {
              ch._index = i++;
           });
           
           var pDOM = newItem._dom;
           var mDOM = this._dom;
                  mDOM.parentNode.insertBefore(pDOM, mDOM );  
           */
      }
      _myTrait_.moveDown = function(t) {
        if (typeof(this._index) != "undefined" && this._parent) {
          var myIndex = this._index,
            nextIndex;
          if (!this._parent) return;
          if (!this._parent._children) return;
          if (myIndex >= (this._parent._children.length - 1)) return;

          if (this._parent._children) {

            var next = this._parent._children[myIndex + 1];

            next._index--;
            this._index++;
            var chList = this._parent._children;

            chList.splice(myIndex + 1, 0, chList.splice(myIndex, 1)[0]);

            var pDOM = next._dom;
            var mDOM = this._dom;
            mDOM.parentNode.insertBefore(mDOM, pDOM.nextSibling);


          }
        }
      }
      _myTrait_.moveUp = function(t) {
        if (this._index && this._parent) {

          var myIndex = this._index,
            nextIndex;
          if (!myIndex) return;
          if (myIndex <= 0) return;
          if (this._parent._children) {

            var prev = this._parent._children[myIndex - 1];
            prev._index++;
            this._index--;
            var chList = this._parent._children;

            chList.splice(myIndex - 1, 0, chList.splice(myIndex, 1)[0]);

            var pDOM = prev._dom;
            var mDOM = this._dom;
            pDOM.parentNode.insertBefore(mDOM, pDOM);

          }
        }
      }
      _myTrait_.parent = function(t) {
        return this._parent;
      }
      _myTrait_.prepend = function(items) {
        if (!(items instanceof Array)) {
          items = Array.prototype.slice.call(arguments, 0);
        }
        var me = this;
        items.forEach(function(e) {
          if (typeof(e) == "string") {
            me._dom.innerHTML = e;
            return me;
          }

          if (typeof(e) == "undefined") return;

          if (typeof(e._dom) != "undefined") {

            if (e._parent) {
              e._parent.removeChild(e);
            }

            if (!me._children) {
              me._children = [];
            }

            e._index = 0;
            me._children.unshift(e);
            e._parent = me;
            me._dom.insertBefore(e._dom, me._dom.firstChild);

            var len = me._children.length;
            for (var i = 0; i < len; i++) me._children[i]._index = i;

            e.trigger("parent", me);
            me.trigger("child", e);
          }
        });

        return this;
      }
      _myTrait_.reIndex = function(t) {
        var chList = this._children;
        var i = 0;
        chList.forEach(function(ch) {
          ch._index = i++;
        });
      }
      _myTrait_.remove = function(t) {

        this.removeChildEvents();

        if (this._parent) {
          this._parent.removeChild(this);
        } else {
          var p = this._dom.parentElement;
          if (p) p.removeChild(this._dom);
        }
        this._children = [];
        this.removeAllHandlers();
      }
      _myTrait_.removeChild = function(o) {
        if (this._children) {

          var me = this;
          /*
               console.log("Parents children are");
               for(var a=0; a<me._children.length; a++) {
                   var ch = me._children[a];
                   //console.log(a);
                   console.log(ch._dom);
               }    
               */

          var i = this._children.indexOf(o);
          if (i >= 0) {
            // console.log("Did find the child to remove");
            this._children.splice(i, 1);
            this._dom.removeChild(o._dom);

          } else {
            //console.log("Did not find the child to remove");
          }
          this.reIndex();
        }
      }
      _myTrait_.removeChildEvents = function(t) {
        this.forChildren(function(ch) {
          ch.removeAllHandlers();
          ch.removeChildEvents();
        });
      }
      _myTrait_.removeIndexedChild = function(o) {
        if (this._children) {
          var i = this._children.indexOf(o);
          if (i >= 0) {
            this._children.splice(i, 1);
          }
        }
      }
      _myTrait_.replaceWith = function(elem) {
        // var a = A.parentNode.replaceChild(document.createElement("span"), A);

        var p = this.parent();
        if (p) {
          var pi = p._children.indexOf(this);
          p._dom.replaceChild(elem._dom, this._dom);
          p._children.splice(pi, 1, elem);
          elem._parent = p;
          elem._svg = this._svg;
          // copy the event handlers of not????
          // this.remove();
        }

      }
    }(this));;
    (function(_myTrait_) {
      var _mousePoint;
      _myTrait_.draggable = function(startFn, middleFn, endFn) {
        var _eg = this.__singleton();
        _eg.draggable(this);

        if (startFn) this.on("startdrag", startFn);
        if (middleFn) this.on("drag", middleFn);
        if (endFn) this.on("enddrag", endFn);

      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {
        this._touchItems = [];
      });
      _myTrait_.mousePos = function(t) {
        if (!_mousePoint) {
          _mousePoint = {};
        }
        var off = this.offset(),
          _eg = this.__singleton(),
          m = _eg.mouse();


        _mousePoint.sx = m.x;
        _mousePoint.sy = m.y;
        _mousePoint.x = m.x - off.left;
        _mousePoint.y = m.y - off.top;
        return _mousePoint;
      }
      _myTrait_.pauseEvents = function(e) {
        e = e || window.event;

        if (e.stopPropagation) e.stopPropagation();
        if (e.preventDefault) e.preventDefault();
        e.cancelBubble = true;
        e.returnValue = false;

        return false;
      }
      _myTrait_.touch = function(i) {
        return this._touchItems[i];

      }
      _myTrait_.touchclick = function(t) {
        this.touchevents();
        var o = this;
        this.on("touchstart", function(o, dv) {
          o.trigger("click");
        });
      }
      _myTrait_.touchevents = function(t) {

        // NOTE
        // http://blogs.msdn.com/b/davrous/archive/2013/02/20/handling-touch-in-your-html5-apps-thanks-to-the-pointer-events-of-ie10-and-windows-8.aspx
        // http://msdn.microsoft.com/en-us/library/ie/hh673557(v=vs.85).aspx
        // https://coderwall.com/p/egbgdw
        // http://jessefreeman.com/articles/from-webkit-to-windows-8-touch-events/

        var elem = this._dom;

        // No hope...
        if (!elem.addEventListener) return;

        var o = this;
        this._touchItems = [];

        var touchStart = function(e) {
          // NOTE: Removed the windows lines below when looking for touch events
          // if (window.navigator.msPointerEnabled && !e.isPrimary) return;
          o._touchItems = [];

          // NOTE: Removed the windows lines below when looking for touch events
          /*
                                 if(window.navigator.msPointerEnabled && e.pageX) {
                                    var item = {};
                                   
                                   item.startX = e.pageX;
                                   item.startY = e.pageY;
                                   o.trigger("touchstart");
                                   o._touchItems.push(item);
                                   if(e.preventDefault) e.preventDefault();
                                   return;
                               }*/
          // o.debug("touchStart");
          var allTouches = e.touches;
          if (e.targetTouches) allTouches = e.targetTouches;
          o._touchCount = allTouches.length;
          for (var i = 0; i < allTouches.length; i++) {
            var item = {};

            item.startX = allTouches[0].pageX;
            item.startY = allTouches[0].pageY;
            o._touchItems[i] = item;
          }

          o.trigger("touchstart");
          if (e.preventDefault) e.preventDefault();

          if (e.stopPropagation) e.stopPropagation();

          e.returnValue = false;


        };

        var touchMove = function(e) {
          // NOTE: Removed the windows lines below when looking at touch events
          /*
                               if (window.navigator.msPointerEnabled && !e.isPrimary) return;
                               if(window.navigator.msPointerEnabled && e.pageX) {
                                   //if(!o._touchItems) o._touchItems = [];
                                   //if(!o._touchItems[0]) o._touchItems[0] = {};
                                   var item = o._touchItems[0];
                                   item.dx = e.pageX - item.startX;
                                   item.dy = e.pageY - item.startY;
                                   o.trigger("touchmove");
                                   if(e.preventDefault) e.preventDefault();
                                   return;
                               }*/

          // var off = o.q.offset();
          var allTouches = e.touches;
          if (e.targetTouches) allTouches = e.targetTouches; // [0].pageX;)
          o._touchCount = allTouches.length;
          for (var i = 0; i < allTouches.length; i++) {
            var item = o._touchItems[i];

            item.dx = e.touches[i].pageX - item.startX;
            item.dy = e.touches[i].pageY - item.startY;
            //item.x = e.touches[i].pageX - off.left;
            //item.y = e.touches[i].pageY - off.top;
          }

          o.trigger("touchmove");


          if (e.preventDefault) e.preventDefault();
        };

        var touchEnd = function(e) {
          // o.q.css("transform", "rotate(20deg)");
          o.trigger("touchend");
          if (e.preventDefault) e.preventDefault();
          e.returnValue = false;
        };

        /*elem.addEventListener("touchcancel", function(e) {
                                 o.trigger("touchcancel");
                                 e.preventDefault();
                                 }, false);*/


        var msHandler = function(event) {
          // o.trigger("mstouch",event);
          switch (event.type) {
            case "touchstart":
            case "MSPointerDown":
              touchStart(event);
              break;
            case "touchmove":
            case "MSPointerMove":
              touchMove(event);
              break;
            case "touchend":
            case "MSPointerUp":
              touchEnd(event);
              break;
          }
          // if(event.preventDefault) event.preventDefault();
          event.returnValue = false;
          //                     event.preventDefault();
        }

        // NOTE: Removed the windows lines below when looking at touch events
        /*
           if (window.navigator.msPointerEnabled) {
             elem.addEventListener("MSPointerDown", msHandler, false);
             elem.addEventListener("MSPointerMove", msHandler, false);
             elem.addEventListener("MSPointerUp", msHandler, false);
           } 
           */

        elem.addEventListener("touchstart", touchStart, false);

        elem.addEventListener("touchmove", touchMove, false);

        elem.addEventListener("touchend", touchEnd, false);
        /*
           elem.addEventListener("touchcancel", function(e) {
                                 o.trigger("touchcancel");
                                 e.preventDefault();
                                 },                
           */

        return;

        var currentOrientation = 0;
        var lastOrient = currentOrientation;
        o.orientation = function() {
          return currentOrientation;
        }

        var resizeEvent = 'onorientationchange' in window ? 'orientationchange' : 'resize';
        document.body.addEventListener(resizeEvent, function() {

          currentOrientation = window.orientation;



          switch (currentOrientation) {
            case 0:
              o.trigger("portrait");
              break;

            case -90:
              o.trigger("landscape");
              // displayStr += "Landscape (right, screen turned clockwise)";
              break;

            case 90:
              o.trigger("landscape");
              // displayStr += "Landscape (left, screen turned counterclockwise)";
              break;

            case 180:
              o.trigger("portrait");
              break;

          }

          lastOrient = window.orientation;


        });

        return;
      }
    }(this));;
    (function(_myTrait_) {
      _myTrait_.absolute = function(t) {
        this.q.css("position", "absolute");
        this.x(0).y(0).z(this.baseZ());
        return this;



      }
      _myTrait_.baseZ = function(v) {
        if (typeof(v) != "undefined") {
          this._baseZ = v;
          return this;
        }
        if (typeof(this._baseZ) == "undefined") this._baseZ = 0;
        return this._baseZ;
      }
      _myTrait_.box = function(t) {
        var box = {
          left: 0,
          top: 0,
          width: 800,
          height: 800
        };

        var elem = this._dom;
        try {
          // BlackBerry 5, iOS 3 (original iPhone)
          if (typeof elem.getBoundingClientRect !== "undefined") {
            box = elem.getBoundingClientRect();
          }
        } catch (e) {
          // for IE having this bg
          box = {
            left: 0,
            top: 0,
            width: 800,
            height: 800
          };
        }
        return box;
      }
      _myTrait_.getTransform = function(t) {
        if (!this._tMatrix) {
          this._tMatrix = ocTransform();
        }
        return this._tMatrix;
      }
      _myTrait_.height = function(v) {
        if (typeof(v) == "undefined") return this._h;

        if (this.isFunction(v)) {
          var oo = v(false, true),
            me = this;
          oo.me.on(oo.name, function(o, v) {
            me.height(v);
          });
          this.height(v());
          return this;
        }

        if (v == "auto") {
          this._dom.style.height = v;
          this._h = v;
          return this;
        }
        if (v.slice) {
          if (v.slice(-1) == "%") {
            this._dom.style.height = v;
            return this;
          }
          if (v.slice(-2) == "em") {
            this._dom.style.height = v;
            return this;
          }
        }

        var p = this.pxParam(v);
        if (typeof(p) != "undefined") {
          this._dom.style.height = p;
        }
        return this;
      }
      _myTrait_.hoverLayer = function(preventAll, zIndex) {
        // creates a layer which does not let through any events...

        var o = _e().absolute();
        var _eg = this.__singleton();



        // the max z-index for this layer...
        o._dom.zIndex = zIndex || 100000;
        /*
           if(startFn) this.on("startdrag", startFn);
           if(middleFn) this.on("drag", middleFn);
           if(endFn) this.on("enddrag", endFn);
           
           */

        if (preventAll) {
          o.addClass("Hoverlayer");
          o.draggable(function(o, dv) {
            console.log("hover, start drag");
          }, function(o, dv) {
            console.log("dragging ");
          }, function(o, dv) {
            console.log("end drag");
          });

          o.bindSysEvent("mouseenter", function() {
            o.trigger("mouseenter");
          }, true);

          o.bindSysEvent("mouseleave", function() {
            o.trigger("mouseleave");
          }, true);

          o.bindSysEvent("click", function() {
            o.trigger("click");
          }, true);

          o.bindSysEvent("mousedown", function() {
            o.trigger("mousedown");
            _eg.dragMouseDown(o);
          }, true);

          o.bindSysEvent("mouseup", function() {
            o.trigger("mouseup");
            _eg.dragMouseUp();
          }, true);
        }

        var off = this.offset();

        o.width(off.width);
        o.height(off.height);

        var rel = _e().relative();
        this.insertBefore(rel);
        rel.add(o);

        return o;



      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {

      });
      _myTrait_.offset = function(t) {
        var doc = document.documentElement;
        var scrollLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
        var scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);

        var box = this.box();
        return {
          top: box.top + scrollTop, // + document.body.scrollTop, //  - docElem.clientTop,
          left: box.left + scrollLeft, // + document.body.scrollLeft // - docElem.clientLeft
          width: box.width,
          height: box.height
        };
      }
      _myTrait_.pxParam = function(v) {
        if (typeof(v) == "string") {
          return parseInt(v) + "px";
        } else {
          var i = parseInt(v);
          if (!isNaN(i)) {
            return i + "px";
          }
        }
      }
      _myTrait_.relative = function(t) {
        this.q.css("position", "relative");
        this.x(0).y(0).z(this.baseZ());
        return this;

      }
      _myTrait_.width = function(v) {
        if (typeof(v) == "undefined") return this._w;


        //console.log("Width = > ", v);
        if (this.isFunction(v)) {
          //console.log("Function ",v());
          var oo = v(false, true),
            me = this;
          //console.log(oo);
          //console.log(oo.me.on);
          oo.me.on(oo.name, function(o, v) {
            me.width(v);
          });

          this.width(v());
          return this;
        }

        if (v == "auto") {
          this._dom.style.width = v;
          this._w = v;
          return this;
        }

        if (v.slice) {
          if (v.slice(-1) == "%") {
            this._dom.style.width = v;
            return this;
          }
          if (v.slice(-2) == "em") {
            this._dom.style.width = v;
            return this;
          }
        }

        var p = this.pxParam(v);
        if (typeof(p) != "undefined") {
          this._dom.style.width = p;
        }
        return this;
      }
      _myTrait_.x = function(v) {
        if (typeof(v) != "undefined") {
          if (this._svgElem) {
            var t = this.getTransform();

            if (!this._y) this._y = 0;
            if (!this._x) this._x = 0;
            var dx = v - this._x;
            this._x = v;
            if (dx != 0) {
              t.translate(dx, 0);
              this.q.attr("transform", t.getSvgTransform());
              this.trigger("x");
            }
            return this;
          }
          this.q.css("left", v + "px");
          this._x = v;
          this.trigger("x");
          return this;
        }
        if (typeof(this._x) == "undefined") this._x = 0;
        return this._x;
      }
      _myTrait_.y = function(v) {
        if (typeof(v) != "undefined") {
          if (this._svgElem) {
            var t = this.getTransform();

            if (!this._y) this._y = 0;
            if (!this._x) this._x = 0;
            var dy = v - this._y;
            this._y = v;
            if (dy != 0) {
              t.translate(0, dy);
              this.q.attr("transform", t.getSvgTransform());
              this.trigger("y");
            }
            return this;
          }
          this.q.css("top", v + "px");
          this._y = v;
          this.trigger("y");
          return this;
        }
        if (typeof(this._y) == "undefined") this._y = 0;
        return this._y;
      }
      _myTrait_.z = function(v) {
        var base = this._baseZ || 0;
        if (typeof(v) != "undefined") {
          this.q.css("zIndex", v + base);
          this._z = v;
          this.trigger("z");
          return this;
        }
        if (typeof(this._z) == "undefined") this._z = 0;
        return this._z;
      }
    }(this));;
    (function(_myTrait_) {
      _myTrait_.applyTransforms = function(tx) {
        var d = this._dom;
        d.style["transform"] = tx;
        d.style["-webkit-transform"] = tx;
        d.style["-moz-transform"] = tx;
        d.style["-ms-transform"] = tx;
        this.trigger("transform");
        return this;
      }
      _myTrait_.hide = function(t) {
        this._dom.style.display = "none";
        this.trigger("hide");


      }
      _myTrait_.show = function(t) {
        this._dom.style.display = "";
        this.trigger("show");

      }
      _myTrait_.style = function(v) {
        if (typeof(v) != "undefined") {
          // should we have named styles... perhaps... TODO
        }
        if (!this._localStyle) {
          var createStyleGuid = "localstyle" + (new Date()).getTime() + "_" + guid();
          this._localStyle = css().css("width", "auto");
          this._localStyle.writeRule(createStyleGuid);
          this.addClass(createStyleGuid);
        }
        return this._localStyle;
      }
      _myTrait_.styleString = function(value) {

        if (this.isFunction(value)) {
          var n = value();
          var oo = value(null, true),
            me = this,
            styleElem = me._dom.style,
            postpone = later(),
            key = this.guid(),
            setValue = function(v) {
              me.styleString(v);
            }

          oo.me.on(oo.name, function(o, v) {
            postpone.once(key, setValue, v);
            // postpone.add(me.styleString, me, v);
            // styleElem.cssText = v;
          });
          this._dom.style.cssText = n;
          return this;

        }

        this._dom.style.cssText = value;

        return this;
      }
      _myTrait_.transform = function(name, value) {
        if (!this._transforms) this._transforms = [];
        if (typeof(value) == "undefined") {

          if (this._transforms.indexOf(name) >= 0) {
            var vi = this._transforms.indexOf(name);
            var val = this._transforms[vi + 1];
            var v = val.substr(1, val.length - 2);
            return v;
          }
          return;
        }
        if (this._transforms.indexOf(name) == -1) {
          this._transforms.push(name);
          this._transforms.push("(" + value + ")");
          this._transforms.push(" ");
        } else {
          var vi = this._transforms.indexOf(name);
          this._transforms[vi + 1] = "(" + value + ")";
        }

        var tx = this._transforms.join("");
        this.applyTransforms(tx);
        return this;
      }
      _myTrait_.transformOrigin = function(tx) {
        var d = this._dom;
        d.style["transform-origin"] = tx;
        d.style["-webkit-transform-origin"] = tx;
        d.style["-moz-transform-origin"] = tx;
        d.style["-ms-transform-origin"] = tx;
        this.trigger("transform-origin");
        return this;
      }
      _myTrait_.transformString = function(t) {
        if (!this._transforms) return "";
        return this._transforms.join("");
      }
    }(this));;
    (function(_myTrait_) {
      _myTrait_.addRow = function(items) {
        var row = new _e("tr");
        this.addItem(row);

        row.addClass("row" + this._children.length);

        if (!(Object.prototype.toString.call(items) === '[object Array]')) {
          items = Array.prototype.slice.call(arguments, 0);
        }


        var colIndex = 0,
          me = this;
        items.forEach(function(ii) {
          var cell = new _e("td");
          cell._dom.setAttribute("valign", "top");
          if (me.isObject(ii)) {
            cell.addItem(ii);
          } else {
            cell.text(ii);
          }
          row.addItem(cell);
          cell.addClass("col" + colIndex);
          colIndex++;
        });
        return this;
      }
    }(this));;
    (function(_myTrait_) {
      _myTrait_.child = function(i) {
        if (this._children[i]) {
          return this._children[i];
        }
      }
      _myTrait_.domAttrIterator = function(elem, fn) {

        if (!elem) return;
        if (!elem.attributes) return;

        for (var i = 0; i < elem.attributes.length; i++) {
          var attrib = elem.attributes[i];
          if (attrib.specified) {
            fn(attrib.name, attrib.value);
          }
        }
      }
      _myTrait_.domIterator = function(elem, fn, nameSpace) {

        if (!elem) return;

        var noRecurse = {
          "textarea": true
        };


        var childNodes = elem.childNodes;
        if (childNodes) {
          var len = childNodes.length;
          for (var i = 0; i < len; i++) {
            var child = childNodes[i];
            if (child.tagName == "svg") nameSpace = "svg";
            if (child) {
              var bStop = fn(child, nameSpace);
              if (bStop) {
                // console.log("**** SHOULD NOT ITERATE CHILDREN *****");
              } else {
                var bFullElem = child instanceof HTMLElement;
                if (bFullElem) {
                  var tN = child.tagName.toLowerCase();
                  if (!noRecurse[tN])
                    this.domIterator(child, fn, nameSpace);
                }
              }

            }
          }
        }

      }
      _myTrait_.forChildren = function(fn) {
        if (this._children) {
          this._children.forEach(function(c) {
            fn(c);
            // c.forChildren(fn);
          });
        }
      }
      _myTrait_.forEach = function(fn) {
        if (this._children)
          this._children.forEach(function(c) {
            fn(c);
            // c.forChildren(fn);
          });
      }
      _myTrait_.searchTree = function(fn, list) {
        if (!list) list = [];
        var v;
        if (v = fn(this)) list.push(v)
        if (this._children)
          this._children.forEach(function(c) {
            // if(fn(c)) list.push(c);
            c.searchTree(fn, list);
          });
        return list;
      }
    }(this));;
    (function(_myTrait_) {
      _myTrait_.addClass = function(c) {
        // safari problem
        if (this._svg) return this;

        if (!this._classes) {
          this._classes = [];
        }

        if (this.isFunction(c)) {
          var n = c();
          var oo = c(null, true),
            oldClass = n,
            me = this;
          oo.me.on(oo.name, function(o, v) {
            me.removeClass(oldClass);
            me.addClass(v);
            oldClass = v;
          });
          this._classes.push(n);
          this._dom.className = this._classes.join(" ");
          return this;
        }

        this._classes.push(c);
        this._dom.className = this._classes.join(" ");
        return this;
      }
      _myTrait_.hasClass = function(c) {
        if (!this._classes) return false;
        if (this._classes.indexOf(c) >= 0) return true;
        return false;
      }
      _myTrait_.removeClass = function(c) {
        if (!this._classes) return this;
        var i;
        while ((i = this._classes.indexOf(c)) >= 0) {
          if (i >= 0) {
            this._classes.splice(i, 1);
            this._dom.className = this._classes.join(" ");
          }
        }

        return this;
      }
    }(this));;
    (function(_myTrait_) {
      var _routes;
      _myTrait_.bacon = function(eventName, eventTransformer) {

        return Bacon.fromEvent(this._dom, eventName, eventTransformer); // (this._dom, eventName [, eventTransformer]) 

      }
      _myTrait_.bindSysEvent = function(en, fn, stop) {
        en = en.toLowerCase();
        if (!this._sys) this._sys = {};
        if (this._sys[en]) return false;

        this._sys[en] = true;

        var me = this;

        if (this._dom.attachEvent) {
          if (!stop) {
            this._dom.attachEvent("on" + en, fn);
          } else {
            this._dom.attachEvent("on" + en, function(e) {
              e = e || window.event;
              me._event = e;
              fn();
              if (stop) {
                e = window.event;
                if (e) e.cancelBubble = true;
              }
            });
          }

        } else {
          if (!stop) {
            this._dom.addEventListener(en, fn);
          } else {
            this._dom.addEventListener(en, function(e) {
              e = e || window.event;
              me._event = e;
              if (stop) {
                if (e && e.stopPropagation) {
                  e.stopPropagation();
                } else {
                  e = window.event;
                  e.cancelBubble = true;
                }
              }
              fn();
            });
          }
        }
        return true;
      }
      _myTrait_.delegate = function(myDelecate) {

        if (!this._delegates) this._delegates = [];
        this._delegates.push(myDelecate);

      }
      _myTrait_.emitValue = function(scope, data) {
        if (this._controller) {
          if (this._controller[scope]) {
            this._controller[scope](data);
            return;
          }
        }

        if (this._valueFn && this._valueFn[scope]) {
          this._valueFn[scope](data);
        } else {
          if (this._parent) this._parent.emitValue(scope, data);
        }
      }
      _myTrait_.eventBinder = function(dom, eventName, fn, stop) {
        var me = this;
        if (dom.attachEvent) {
          dom.attachEvent("on" + eventName, function(e) {
            e = e || window.event;
            me._event = e;
            fn();
            if (stop) {
              e = window.event;
              if (e) e.cancelBubble = true;
            }
          });
        } else {
          dom.addEventListener(eventName, function(e) {
            e = e || window.event;
            me._event = e;
            if (stop) {
              if (e && e.stopPropagation) {
                e.stopPropagation();
              } else {
                e = window.event;
                e.cancelBubble = true;
              }
            }
            fn();
          });
        }
      }
      _myTrait_.eventSourceObj = function(t) {

      }
      _myTrait_.isHovering = function(t) {
        if (!this._hoverable) {
          this._hovering = false;
          var o = this;

          this.on("mouseenter", function() {
            // console.log("Entered...");
            o._hovering = true;
          });
          this.on("mouseleave", function() {
            o._hovering = false;
          });
          this._hoverable = true;
        }
        return this._hovering;
      }
      _myTrait_.namedListener = function(name, fn) {

        if (typeof(fn) != "undefined") {

          if (!this._namedListeners)
            this._namedListeners = {};
          this._namedListeners[name] = fn;
          fn._listenerName = name;
          return this;
        }
        if (!this._namedListeners) return;
        return this._namedListeners[name];
      }
      _myTrait_.on = function(en, ef) {
        if (!this._ev) this._ev = {};
        if (!this._ev[en]) this._ev[en] = [];

        this._ev[en].push(ef);
        var me = this;

        ef._unbindEvent = function() {
          me.removeListener(en, ef);
        }


        // To stop the prop...
        if (en == "click") this.bindSysEvent("click", function() {
          me.trigger("click");
        }, true);

        if (en == "dblclick") this.bindSysEvent("dblclick", function() {
          me.trigger("dblclick");
        }, true);

        if (en == "mousedown") this.bindSysEvent("mousedown", function() {
          // console.log("---- mousedown");
          me.trigger("mousedown");
        });

        if (en == "mouseup") this.bindSysEvent("mouseup", function() {
          // console.log("---- mousedown");
          me.trigger("mouseup");
        });

        if (en == "checked") {

          this.bindSysEvent("change", function() {
            if (me._type == "checkbox") {
              if (me._dom.checked) {
                me._checked = true;
              } else {
                me._checked = false;
              }
              me.trigger("checked");
            } else {
              me._value = me._dom.value;
            }
            me.trigger("value");
          });

        }

        if (en == "value") {
          this.bindSysEvent("change", function() {


            if (me._type == "checkbox") {
              if (me._dom.checked) {
                me._checked = true;
              } else {
                me._checked = false;
              }
              me.trigger("checked");
            } else {
              me._value = me._dom.value;
            }
            me.trigger("value");
          });

          if (this._type == "input" || this._type == "textarea") {
            var lastValue = "";
            this.bindSysEvent("keyup", function() {
              var bch = false;
              if (lastValue != me._dom.value) bch = true;
              me._value = me._dom.value;
              if (bch) me.trigger("value");
              lastValue = me._dom.value;
            });


          }
        }

        if (en == "focus") {
          this.bindSysEvent("focus", function() {
            me._value = me._dom.value;
            me.trigger("focus");
          });
        }

        if (en == "play") {
          this.bindSysEvent("play", function() {
            me.trigger("play");
          });
        }

        if (en == "mousemove") {
          this.bindSysEvent("mousemove", function() {
            me.trigger("mousemove");
          });
        }

        if (en == "blur") {
          this.bindSysEvent("blur", function() {
            me._value = me._dom.value;
            me.trigger("blur");
          });
        }

        if (en == "mouseenter") {
          if (this._dom.attachEvent) {
            this.bindSysEvent("mouseenter", function(e) {
              e = e || window.event;
              if (me._hover) return;
              me._event = e;
              me._hover = true;
              me.trigger("mouseenter");
            });
            this.bindSysEvent("mouseleave", function(e) {
              e = e || window.event;
              if (!me._hover) return;
              me._event = e;
              me._hover = false;
              me.trigger("mouseleave");
            });
          } else {

            this.bindSysEvent("mouseover", function(e) {
              e = e || window.event;
              if (me._hover) return;
              me._hover = true;
              me._event = e;
              if (me._parent) {
                if (!me._parent._hover) {
                  me._parent.trigger("mouseenter");
                }
                // me._parent._childHover = true;
              }
              // console.log("Mouse over xxx");
              me.trigger("mouseenter");
            });
            this.bindSysEvent("mouseout", function(e) {
              if (!me._hover) return;

              var childHover = false;
              me.forChildren(function(c) {
                if (c._hover) childHover = true;
              });

              if (childHover) return;

              me._hover = false;

              me.trigger("mouseleave");
            });

          }


        }

        return this;
      }
      _myTrait_.onValue = function(scope, fn) {
        if (!this._valueFn) {
          this._valueFn = {};
        }
        this._valueFn[scope] = fn;
      }
      _myTrait_.removeAllHandlers = function(t) {

        if (this._ev) {
          // console.log("Removing handlers....");
          for (var n in this._ev) {
            if (this._ev.hasOwnProperty(n)) {
              var list = this._ev[n],
                me = this;
              //console.log("Removing list....", list);
              list.forEach(function(fn) {
                if (me._namedListeners) {
                  var ln = fn._listenerName;
                  if (me._namedListeners[ln]) {
                    delete me._namedListeners[ln];
                  }
                }
                if (fn._unbindEvent) {
                  //console.log("Calling unbind event... for ", fn);
                  fn._unbindEvent();
                }
              });
            }
          }
          for (var n in this._namedListeners) {
            if (this._namedListeners.hasOwnProperty(n)) {
              var fn = this._namedListeners[n];
              if (fn._unbindEvent) {
                //console.log("Calling unbind event... for ", fn);
                fn._unbindEvent();
              }
              delete this._namedListeners[n];
            }
          }
        }
      }
      _myTrait_.removeListener = function(eventName, fn) {
        if (this._ev && this._ev[eventName]) {
          var i = this._ev[eventName].indexOf(fn);
          if (i >= 0) this._ev[eventName].splice(i, 1);

          if (this._ev[eventName].length == 0) {
            delete this._ev[eventName];
          }
        }
      }
      _myTrait_.router = function(eventName, fn) {

        var me = this;
        this._dom.addEventListener(eventName, function(event) {
          var elem = event.target;
          if (!elem) return;
          var routeId = elem.getAttribute("data-routeid");
          if (routeId) {
            var obj = _routes[routeId];
            if (obj) fn(obj);
          }
        });
      }
      _myTrait_.setRoute = function(obj, recursive) {

        var routeId = this.guid();
        this._dom.setAttribute("data-routeid", routeId);
        if (!_routes) _routes = {}
        if (recursive) {
          this.forChildren(function(ch) {
            ch.setRoute(obj, recursive);
          });
        }
        _routes[routeId] = obj;
      }
      _myTrait_.trigger = function(en, data, fn) {
        if (this._delegates) {
          this._delegates.forEach(function(d) {
            if (d && d.trigger) d.trigger(en, data, fn);
          });
          // return;
        }
        if (!this._ev) return;
        if (!this._ev[en]) return;
        var me = this;
        this._ev[en].forEach(function(cb) {
          cb(me, data, fn)
        });
        return this;
      }
      _myTrait_.uniqueListener = function(listenerName, fn) {
        var oldList = this.namedListener(listenerName);
        if (oldList) {
          if (oldList._unbindEvent) oldList._unbindEvent();
        }
        this.namedListener(listenerName, fn);
        return fn;

      }
    }(this));;
    (function(_myTrait_) {
      _myTrait_.bind = function(obj, varName) {
        var o = this;
        // The special case here...
        if (this.isFunction(obj[varName])) {


          var val = obj[varName](),
            o = this,
            fn = function(v) {
              obj[varName](v);
            },
            bSendingEvent = false,
            me = this;

          //
          //  var isNumber = !isNaN(val);

          var isNumber = false;

          var oo = obj;

          var valueInListener = this.uniqueListener("bind:valueIn", function(obj, newVal) {
            if (bSendingEvent) return;
            if (o._type == "checkbox") {
              o.checked(newVal);
            } else {
              o.val(newVal);
            }
            val = newVal;
          });
          var valueOutListener = this.uniqueListener("bind:valueOut", function(obj) {
            bSendingEvent = true;
            if (o._type == "checkbox") {
              fn(o.checked());
            } else {
              fn(isNumber ? parseFloat(o.val()) : o.val());
            }
            bSendingEvent = false;
          });

          //



          var invalidInputListener = this.uniqueListener("bind:invalidIn", function(obj, msg) {
            o.trigger("invalid", msg);
          });
          var validInputListener = this.uniqueListener("bind:validIn", function(obj, newVal) {
            o.trigger("valid", newVal);
          });

          obj.on(varName, valueInListener);
          this.on("value", valueOutListener);

          //oo.me.on(oo.name, valueInListener );
          //this.on("value", valueOutListener); 
          //oo.me.on("invalid-"+oo.name, invalidInputListener);    
          //oo.me.on("valid-"+oo.name, validInputListener);       


          var me = this;
          if (o._type == "checkbox") {
            o.checked(val);
          } else {
            o.val(val);
          }

          // and exit...
          return this;
        }

        var _ee_ = this.__singleton();
        _ee_.bind(obj, varName, this);
        var o = this;
        this.on("datachange", function() {
          if (o._type == "checkbox") {
            if (obj[varName]) {
              o.checked(true);
            } else {
              o.checked(false);
            }
          } else {

            if (typeof(obj[varName]) != "undefined") {
              o.val(obj[varName]);
            }

          }
        });
        this.on("value", function() {
          if (obj) {

            if (o._type == "checkbox") {

              if (o.checked()) {
                obj[varName] = true;
              } else {
                obj[varName] = false;
              }

            } else {
              obj[varName] = o.val();
            }

          }
          // Send the message to other listeners
          _ee_.send(obj, varName, "datachange", o);
        });

        if (obj) {
          if (o._type == "checkbox") {

            if (obj[varName]) {
              o.checked(true);
            } else {
              o.checked(false);
            }
          } else {

            if (obj[varName]) {
              o.val(obj[varName]);
            }

          }
        }
        return o;
      }
      _myTrait_.blur = function(t) {
        if (this._dom.blur) this._dom.blur();
      }
      _myTrait_.checked = function(v) {
        if (typeof(v) == "undefined") {

          // if(typeof( this._checked)=="undefined") {
          this._checked = this._dom.checked;
          // this.trigger("value");
          return this._checked;
        }

        var nowOn = this._dom.checked;
        this._dom.checked = v;

        if ((nowOn && !v) || (!nowOn && v)) {
          this.trigger("value");
        }

        return this;
      }
      _myTrait_.clearOptions = function(t) {
        if (this._dataList) {
          var node = this._dataList._dom;
          if (node.parentNode) node.parentNode.removeChild(node);
          this._options = {};
          this._dataList = null;
        }
      }
      _myTrait_.focus = function(t) {
        if (this._dom.focus) this._dom.focus();
      }
      _myTrait_.options = function(list) {
        // creates the input options for html5 usage...

        if (this._tag == "input") {
          if (this._dataList) {
            var node = this._dataList._dom;
            if (node.parentNode) node.parentNode.removeChild(node);
            this._options = {};
            this._dataList = null;
          }
          if (!this._dataList) {
            this._options = {};
            this._dataList = _e("datalist");
            this._dataListId = guid();
            this._dataList.q.attr("id", this._dataListId);
            // console.log("DATA", list);
            if (Object.prototype.toString.call(list) === '[object Array]') {
              var me = this;
              list.forEach(function(n) {
                var opt = _e("option");
                opt.q.attr("value", n);
                opt.text(n);
                me._options[n] = opt;
                me._dataList.add(opt);
              });
            } else {
              for (var n in list) {
                if (this._options[n]) continue;
                if (list.hasOwnProperty(n)) {
                  var opt = _e("option");
                  opt.q.attr("value", n);
                  opt.text(list[n]);
                  this._options[n] = opt;
                  this._dataList.add(opt);
                }
              }
            }

            this.q.attr("list", this._dataListId);
            if (document.body) {
              document.body.appendChild(this._dataList._dom);
            }
          } else {

          }
          /*
               <label>Your favorite fruit:
           <datalist id="fruits">
           <option value="Blackberry">Blackberry</option>
           <option value="Blackcurrant">Blackcurrant</option>
           <option value="Blueberry">Blueberry</option>
           <!--  -->
           </datalist>
           If other, please specify:
           <input type="text" name="fruit" list="fruits">
           </label>
               */
        }
        return this;
      }
      _myTrait_.val = function(v) {
        if (typeof(v) == "undefined") {
          if (this._type == "select" || this._type == "input" || this._type == "textarea") {
            this._value = this._dom.value;
          }
          return this._value;
        }

        /*
           if(this.isFunction(v)) {
               
               var myVal = v();
               this._dom.value = myVal;
               
               // re-bind the event listener to another if already is listening to a change...
               
               
               return this;
           }
           */


        if (typeof(this._dom.value) != "undefined" || this._type == "option") {
          this._dom.value = v;
        } else {
          this._dom.innerHTML = v;
        }
        this._value = v;
        this.trigger("value");
        return this;
      }
    }(this));;
    (function(_myTrait_) {
      _myTrait_.a = function(className, attrs) {
        var el = this.shortcutFor("a", className, attrs);
        return el;
      }
      _myTrait_.attr = function(v, v2) {

        if (this.isObject(v)) {
          for (var n in v) {
            if (v.hasOwnProperty(n)) {
              this.q.attr(n, v[n]);
            }
          }

        } else {
          this.q.attr(v, v2);
        }
        return this;
      }
      _myTrait_.b = function(className, attrs) {
        var el = this.shortcutFor("b", className, attrs);
        return el;
      }
      _myTrait_.button = function(className, attrs) {
        var el = this.shortcutFor("button", className, attrs);
        return el;
      }
      _myTrait_.canvas = function(className, attrs) {
        var el = this.shortcutFor("canvas", className, attrs);
        return el;
      }
      _myTrait_.checkbox = function(className, attrs) {
        var el = this.shortcutFor("checkbox", className, attrs);
        return el;
      }
      _myTrait_.context = function(t) {
        if (this._dom.getContext) {
          var ctx = this._dom.getContext("2d")
          var cc = canvasContext(this._dom.getContext("2d"));
          cc._canvas = this;
        } else {
          var cc = canvasContext();
        }
        return cc;
      }
      _myTrait_.div = function(className, attrs) {
        var el = this.shortcutFor("div", className, attrs);
        return el;
      }
      _myTrait_.form = function(className, attrs) {
        var el = this.shortcutFor("form", className, attrs);
        return el;
      }
      _myTrait_.h1 = function(className, attrs) {
        var el = this.shortcutFor("h1", className, attrs);
        return el;
      }
      _myTrait_.h2 = function(className, attrs) {
        var el = this.shortcutFor("h2", className, attrs);
        return el;
      }
      _myTrait_.h3 = function(className, attrs) {
        var el = this.shortcutFor("h3", className, attrs);
        return el;
      }
      _myTrait_.h4 = function(className, attrs) {
        var el = this.shortcutFor("h4", className, attrs);
        return el;
      }
      _myTrait_.img = function(className, attrs) {
        var el = this.shortcutFor("img", className, attrs);
        return el;
      }
      _myTrait_.input = function(className, attrs) {
        var el = this.shortcutFor("input", className, attrs);
        return el;
      }
      _myTrait_.label = function(className, attrs) {
        var el = this.shortcutFor("label", className, attrs);
        return el;
      }
      _myTrait_.li = function(className, attrs) {
        var el = this.shortcutFor("li", className, attrs);
        return el;
      }
      _myTrait_.ol = function(className, attrs) {
        var el = this.shortcutFor("ol", className, attrs);
        return el;
      }
      _myTrait_.p = function(className, attrs) {
        var el = this.shortcutFor("p", className, attrs);
        return el;
      }
      _myTrait_.pre = function(className, attrs) {
        var el = this.shortcutFor("pre", className, attrs);
        return el;
      }
      _myTrait_.shortcutFor = function(name, className, attrs) {
        var el = _e(name);

        if (this.isObject(className) && !this.isFunction(className)) {
          attrs = className;
        } else {
          if (className) el.addClass(className || "");
        }
        if (attrs) {
          for (var n in attrs) {
            if (attrs.hasOwnProperty(n)) {
              el.q.attr(n, attrs[n]);
            }
          }
        }
        this.add(el);
        return el;
      }
      _myTrait_.span = function(className, attrs) {
        var el = this.shortcutFor("span", className, attrs);
        return el;
      }
      _myTrait_.src = function(src) {
        if (this._tag == "img") {
          if (!this._hasLoadL) {
            var me = this;
            this.__singleton().addEventListener(this._dom, "load", function() {
              me.trigger("load");
            });
            this._hasLoadL = true;
          }
        }
        this.q.attr("src", src);

        return this;
      }
      _myTrait_.strong = function(className, attrs) {
        var el = this.shortcutFor("strong", className, attrs);
        return el;
      }
      _myTrait_.table = function(className, attrs) {
        var el = this.shortcutFor("table", className, attrs);
        return el;
      }
      _myTrait_.textarea = function(className, attrs) {
        var el = this.shortcutFor("textarea", className, attrs);
        return el;
      }
      _myTrait_.ul = function(className, attrs) {
        var el = this.shortcutFor("ul", className, attrs);
        return el;
      }
    }(this));;
    (function(_myTrait_) {
      _myTrait_._setDomText = function(elem, text) {
        if (typeof(elem.textContent) != "undefined") {
          elem.textContent = text;
        } else {
          var html = text;
          var div = document.createElement("div");
          div.innerHTML = html;
          var newText = div.innerText || "";
          elem.innerHTML = newText;
        }
      }
      _myTrait_.html = function(h) {
        if (this.isFunction(h)) {

          var val = h();
          var oo = h(null, true),
            me = this;
          oo.me.on(oo.name, me.uniqueListener("text:value", function(o, v) {
            me._dom.innerHTML = v;
          }));
          this._dom.innerHTML = val;
          return this;
        }

        if (typeof(h) == "undefined") return this._dom.innerHTML;
        this._dom.innerHTML = h;
        return this;
      }
      _myTrait_.text = function(t) {
        if (typeof(t) == "undefined") return this._html;

        if (this.isFunction(t)) {

          var val = t();
          var oo = t(null, true),
            me = this,
            soon = later(),
            bTSpan = false;

          if (me._tag == "tspan") bTSpan = true;

          if (this._svgElem || typeof(me._dom.textContent) != "undefined") {
            oo.me.on(oo.name, me.uniqueListener("text:value", function(o, v) {
              if (bTSpan) v = v.trim();
              // soon.add(me.text, me, v);
              if (bTSpan && (!v || v.length == 0)) {
                me._dom.textContent = '\u00A0';

              } else {
                me._dom.textContent = v;
              }
            }));
          } else {
            oo.me.on(oo.name, me.uniqueListener("text:value", function(o, v) {
              var html = v;
              var div = document.createElement("div");
              div.innerHTML = html;
              var newText = div.textContent || div.innerText || "";
              me._dom.innerHTML = newText;
            }));
          }

          if (this._svgElem || typeof(this._dom.textContent) != "undefined") {
            if (bTSpan) val = val.trim();
            if (bTSpan && (!val || val.length == 0)) {
              this._dom.textContent = "";
              me._dom.textContent = '\u00A0';
            } else {
              this._dom.textContent = val;
            }
          } else {

            var div = document.createElement("div");
            div.innerHTML = val;
            var newText = div.textContent || div.innerText || "";

            this._dom.innerHTML = newText;
          }
          return this;
        }

        if (this._svgElem || typeof(this._dom.textContent) != "undefined") {
          this._dom.textContent = t;
        } else {
          var html = t;
          var div = document.createElement("div");
          div.innerHTML = html;
          var newText = div.textContent || div.innerText || "";
          this._dom.innerHTML = newText;
        }

        this._html = t;
        return this;
      }
    }(this));;
    (function(_myTrait_) {
      var lastView;
      var bInited;
      var _settingView;
      var _eventState;
      var _windowSize;
      var _mediaListeners;
      var mql;
      _myTrait_.bottom = function(t) {
        return this.createLayoutElement("bottom");
      }
      _myTrait_.createLayoutElement = function(name) {
        if (!this.__layout) {
          this.__layout = {};
        }
        var el = this.__layout[name];
        if (!el) {
          el = _e("div");
          el.addClass("layout-" + name)
          if (name == "top") {
            this.prepend(el);
          } else {
            if (name == "bottom") {
              this.add(el);
            } else {
              var insertBef = null;

              //                             this.insertBefore = function(newItem) {                           
              if (name == "middle") {

                if (this.__layout["right"]) insertBef = this.__layout["right"];
                if (!insertBef && this.__layout["bottom"]) insertBef = this.__layout["bottom"];

                if (insertBef) {
                  insertBef.insertBefore(el);
                } else {
                  this.add(el);
                }
              }
              if (name == "left") {

                if (this.__layout["middle"]) insertBef = this.__layout["middle"];
                if (!insertBef && this.__layout["right"]) insertBef = this.__layout["right"];
                if (!insertBef && this.__layout["bottom"]) insertBef = this.__layout["bottom"];

                if (insertBef) {
                  insertBef.insertBefore(el);
                } else {
                  this.add(el);
                }
              }
              if (name == "right") {

                if (this.__layout["bottom"]) insertBef = this.__layout["bottom"];
                if (insertBef) {
                  insertBef.insertBefore(el);
                } else {
                  this.add(el);
                }
              }

            }
          }
          this.__layout[name] = el;
        }
        // this.addClass("layout");
        return el;
      }
      _myTrait_.detectMediaType = function(t) {
        // The media types could be defined, here is some...
        /*
           var test = {
               "mobile" : "(max-width:700px)"
           }
           
           if(window.matchMedia) {
              foreach(var n in test) {
                   mql = window.matchMedia(mediaQueryString);
                    
               }
           }
           */
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {
        // if(!myHistory) myHistory = {};

        if (!_eventState) {
          //     window.
          // hashchange
          // console.log("Initializing the history...");
          this.eventBinder(window, "hashchange", function() {
            if (("#" + _eventState.lastSetValue) == document.location.hash) return;
            if (_eventState.pushing) return;

            // console.log("moving backwards...", _eventState, document.location.hash);
            if (lastView) {
              // just do it...
              // lastView.popView();
            }
          });

          _eventState = {
            inited: true
          }
        }
      });
      _myTrait_.initScreenEvents = function(t) {
        // object.addEventListener("resize", myScript);
        // if(window.matchMedia) {
        _windowSize = {
          w: 0,
          h: 0
        };

        var _widthLimits = [700];

        var eventCnt = 0;

        _mediaListeners = [];
        if (window.matchMedia) {
          mql = window.matchMedia("(max-width:700px)");
          mql.addListener(function(q) {
            eventCnt++;
            if (q.matches) {
              _mediaListeners.forEach(function(fn) {
                fn({
                  w: window.innerWidth || document.documentElement.clientWidth,
                  h: window.innerHeight || document.documentElement.clientHeight,
                  limit: 700,
                  width_less: true,
                  eCnt: eventCnt
                });
              });
            } else {
              _mediaListeners.forEach(function(fn) {
                fn({
                  w: window.innerWidth || document.documentElement.clientWidth,
                  h: window.innerHeight || document.documentElement.clientHeight,
                  limit: 700,
                  width_more: true,
                  eCnt: eventCnt
                });
              });
            }
          });

        } else {
          // console.log("Bind resize");
          // eventBinder(dom, event, fun

          var isIE8 = !document.addEventListener ? true : false,
            bindTo = window;

          // if(isIE8) bindTo = document.body;

          this.eventBinder(bindTo, "resize", function() {
            // what is the screen size... 

            eventCnt++;

            var width = window.innerWidth || document.documentElement.clientWidth,
              doAlert = false,
              limit = 700;

            _widthLimits.forEach(function(w) {
              var ch = (w - width) * (w - _windowSize.w);
              if (ch < 0) {
                limit = w;
                doAlert = true;
              }
            });

            _windowSize.w = window.innerWidth || document.documentElement.clientWidth;
            _windowSize.h = window.innerHeight || document.documentElement.clientHeight;

            if (doAlert) {
              _mediaListeners.forEach(function(fn) {
                var data = {
                  limit: limit,
                  w: _windowSize.w,
                  h: _windowSize.h,
                  eCnt: eventCnt
                };
                if (_windowSize.w > limit) {
                  data.width_more = true;
                } else {
                  data.width_less = true;
                }
                fn(data);
              });
            }


          });
          /*
               object.addEventListener("resize", function() {
                   // _windowSize
               });
               */
        }
      }
      _myTrait_.left = function(t) {
        return this.createLayoutElement("left");
      }
      _myTrait_.middle = function(t) {
        return this.createLayoutElement("middle");
      }
      _myTrait_.navigation = function(navi) {
        this._navigation = navi;
        this._activeNavi = null;
        if (!this._viewStack) {
          this._viewStack = [];
        }
        var me = this,
          content = this;
        navi.items.forEach(function(item) {
          if (!item.navi) {
            item.navi = item.naviFn();
          }

          item.navi.on("highlight", function() {
            if (me._activeNavi) me._activeNavi.navi.removeClass(navi.activeNaviClass || "active-navi");
            me._activeNavi = item;
            me._activeNavi.navi.addClass(navi.activeNaviClass || "active-navi");
          });

          item.navi.on("prepareNavi", function() {
            item.navi.trigger("highlight");
            if (!item.content) {
              item.content = item.contentFn();
            }
            if (!item.content._naviItem) {
              item.content._naviItem = item;
            }
          });

          item.prepareNavigation = function() {
            if (item == me._activeNavi) return false;
            if (navi.onNavigation) {
              var allow = navi.onNavigation(item);
              if (!allow) return false;
            }
            item.navi.trigger("prepareNavi");
            return true;
          }

          item.navi.on("navigate", function() {
            if (item == me._activeNavi) return;

            if (!item.prepareNavigation()) return;

            content.pushView(item.content);
          });

          item.navi.on("click", function() {
            item.navi.trigger("navigate");
          });
          item.navi.addClass(navi.naviClass || "navi-item");
        });

        this.onValue("popView", function() {
          console.log("Got the popview");
          content.popView();
        });

        this.onValue("pushView", function(viewName) {

          // This is tricky...
          var bDid = false;
          if (viewName == Object(viewName)) {

            if (viewName._naviItem) {
              viewName._naviItem.trigger("navigate");
              return;
            }

            me._navigation.items.forEach(function(item) {
              if (bDid) return;
              if (item.content == viewName) {
                item.navi.trigger("navigate");
                bDid = true;
              }
            });
            if (!bDid) {
              content.pushView(viewName);
            }

            return;
          }
          me._navigation.items.forEach(function(item) {
            if (bDid) return;
            if (item.tag == viewName) {
              item.navi.trigger("navigate");
              bDid = true;
            }
          });
          if (!bDid) {
            if (content.parent()) {
              content.parent().emitValue("pushView", viewName);
            }
          }

        });



        /*
           content.onValue("navigateTo", function(viewName) {
           
           if(viewName == Object(viewName)) {
           content.pushView( view ); 
           return;
           }
           
           if(viewTags[viewName]) {
           content.pushView( view ); 
           } else {
           if(content.parent()) {
           content.parent().emitValue("navigateTo", viewName);
           }
           }
           });               
           */
      }
      _myTrait_.onMediaChange = function(fn) {

        _mediaListeners.push(fn);
      }
      _myTrait_.popView = function(toView) {


        if (!this._views) {
          this._views = [];
          return this;
        }

        var cont = this;


        if (this._views.length == 0) {
          if (toView) {
            this.pushView(toView);
            return;
          }
        }

        lastView = this;


        if (toView) {

          var showP = true;
          var me = this;
          cont.forChildren(function(ch) {
            $(ch._dom).fadeOut(200, function() {
              ch.remove();
              if (showP) {
                $(toView._dom).fadeIn(200, function() {
                  $(toView._dom).show();
                });
                cont.add(toView);
                showP = false;
                toView.scrollTo();
              }
            });
          });
          return;
        }


        var view = this._views.pop();



        // Do the pop-up using
        if (view.oldChildren && view.oldChildren._children && view.oldChildren._children.length == 1 && view.oldChildren._children[0]._naviItem) {

          // prepare the navigation for content switch...
          var item = view.oldChildren._children[0]._naviItem;

          if (!item.prepareNavigation()) return;


          var showP = true;
          var me = this;
          cont.forChildren(function(ch) {
            $(ch._dom).fadeOut(200, function() {
              if (showP) {
                $(item.content._dom).fadeIn(200, function() {
                  $(item.content._dom).show();
                });
                cont.add(item.content);
                showP = false;
                item.content.scrollTo();
              }
              ch.remove();
            });
          });
          return;

        }

        var showP = true;
        var me = this;
        cont.forChildren(function(ch) {
          $(ch._dom).fadeOut(200, function() {
            if (showP) {
              // console.log("Old view child count ", view.oldChildren._children.length);
              var addThese = [];
              view.oldChildren.forChildren(function(ch) {
                // console.log(ch);
                $(ch._dom).fadeIn(200, function() {
                  $(ch._dom).show();
                });
                addThese.push(ch);
              });
              addThese.forEach(function(c) {
                cont.add(c);
              });
              if (addThese[0]) addThese[0].scrollTo();
              if (view.oldTitle && me.setTitle) me.setTitle(view.oldTitle);
              showP = false;
            }
            ch.remove();
          });
        });



      }
      _myTrait_.pushView = function(newView, params) {
        if (!this._views) {
          this._views = [];
        }

        var cont = this;
        if (cont._children && cont._children[0] == newView) {
          return;
        }


        if (!params) params = null;

        var oldChildren = _e("div");

        var viewData = {
          parentView: null,
          oldTitle: this.__currentTitle,
          oldChildren: oldChildren,
          params: params
        };

        var showP = true,
          hadChildren = false,
          me = this;

        this.onValue("pushView", function(v) {
          me.pushView(v);
        });

        this.onValue("popView", function(toView) {
          me.popView(toView);
        });

        lastView = this;
        // primitive and simple
        _eventState.lastSetValue = (new Date()).getTime();
        _eventState.pushing = true;
        document.location.hash = _eventState.lastSetValue;

        // console.log("PUSH, view child count ", cont._children.length);
        cont.forChildren(function(ch) {
          // console.log("Adding a div");
          hadChildren = true;
          $(ch._dom).fadeOut(200, function() {
            if (showP) {
              cont.add(newView);
              $(newView._dom).fadeIn(200);
              showP = false;
            }
            oldChildren.add(ch);
            newView.scrollTo();
          });
        });
        this._views.push(viewData);
        if (!hadChildren) {
          cont.add(newView);
          $(newView._dom).fadeIn(200);
          showP = false;
          newView.scrollTo();
        }

        _eventState.pushing = false;

        return this;
      }
      _myTrait_.right = function(t) {
        return this.createLayoutElement("right");
      }
      _myTrait_.scrollTo = function(noThing) {
        if (window) {
          var box = this.offset();
          var currLeft = window.pageXOffset;

          var toY = box.top;
          if (toY < window.innerHeight / 2) return;
          if (box.top < window.innerHeight) {
            toY = toY / 2;
          } else {
            toY = toY - window.innerHeight * 0.2
          }

          window.scrollTo(currLeft || 0, parseInt(toY));
          // console.log(box);
          // alert((currLeft || 0)+","+ parseInt(box.top))
        }
      }
      _myTrait_.top = function(t) {
        return this.createLayoutElement("top");
      }
    }(this));;
    (function(_myTrait_) {
      var _modelTemplates;
      var _viewContent;
      var _viewTemplates;
      var _namedModels;
      var _namedViews;
      var _dataLink;
      var _customDirectives;
      _myTrait_._addCustomDir = function(name, fn) {

        if (!_customDirectives) _customDirectives = {}
        _customDirectives[name] = fn;

      }
      _myTrait_._addModelTemplate = function(elem, tplObj) {

        var id = this.guid();
        if (!_modelTemplates) _modelTemplates = {};
        _modelTemplates[id] = tplObj;
        if (elem && elem.setAttribute) elem.setAttribute("data-tpl", id);
      }
      _myTrait_._callCustom = function(name, dom, options) {
        if (_customDirectives[name]) {
          _customDirectives[name](dom, options);
        }
      }
      _myTrait_._clearWorkers = function(view) {

        view.workers.forEach(function(ww) {
          _dataLink._removeWorker(ww);
        })

        view.childViews.forEach(this._clearWorkers);
      }
      _myTrait_._createViewDef = function(dataId, parentView) {


        var viewDef = {
          dataid: dataId,
          baseTpl: null,
          parentView: parentView,
          workers: [],
          childViews: []
        }

        if (parentView && parentView.childViews) {
          parentView.childViews.push(viewDef);
        }

        _dataLink._addModelView(dataId, viewDef);


        return viewDef;
      }
      _myTrait_._eventActionFor = function(event, attributeName, rootData) {
        var elem = event.target;
        if (!elem) return;
        var action = elem.getAttribute(attributeName);
        var me = this;
        if (action) {
          var max = 10,
            dom = elem,
            objid;
          // console.log("Looking action ", action);
          while (dom && !(objid = dom.getAttribute("data-id")) && (max--)) {
            dom = dom.parentNode;
          }
          if (dom && objid) {

            var params = action.split("("),
              action = params.shift();
            var argStr = params.pop(),
              plist = null;
            if (argStr) {
              var prms = argStr.split(")"),
                plist = prms.shift().split(",");
            }
            // console.log("Found the action");
            var oo = rootData.findFromCache(objid);
            if (me.isFunction(oo[action])) {
              console.log("fires ", action, plist);
              if (me.isArray(plist)) {
                oo[action].apply(oo, plist);
              } else {
                oo[action](); // just a test for the sake of easiness...
              }
            }
          }
        }
      }
      _myTrait_._findModelTemplate = function(elem) {

        if (elem && elem.getAttribute) {
          var id = elem.getAttribute("data-tpl");
          if (_modelTemplates) return _modelTemplates[id];
        }
      }
      _myTrait_._getNamedViews = function(t) {

        return _namedViews;
      }
      _myTrait_._getViewsOfModel = function(dataId) {

        // this is needed for example when the view is destroyed...


        return _modelTemplates[dataId];
      }
      _myTrait_._saveViewTemplate = function(name, tplDef) {

        if (!_viewTemplates) {
          _viewTemplates = {};
        }

        _viewTemplates[name] = tplDef;
      }
      _myTrait_._searchNamedAreas = function(t) {


        /*
                   <!-- the left navigation -->
                   <div data-view="@leftnavi" data-model="@leftnavi">
                       The left navi will be here as soon as it is set....
                   </div>
           */

        // not perhaps the optimal way to do it...
        var list = rootElement.querySelectorAll("[data-view]");

        for (var i = 0; i < list.length; i++) {
          var e = list[i];
          if (e && e.getAttribute) {
            var a = e.getAttribute("data-view");
            if (a.charAt(0) == "@") {
              var n = a.substring(1);

              //             this._setNamedView( n,  ); // <- The view and it's compilation perhaps???

            }
          }
        }
      }
      _myTrait_._setNamedModel = function(name, model) {

        // The named nodel
        // <div data-model="@topnavi">
        // </div>

        // ********* dynamic view template to be used *********
        // <div data-view="@content">
        // </div>


        _namedModels[name] = model;

        return this;
      }
      _myTrait_._setNamedView = function(name, viewDef) {

        _namedViews[name] = viewDef;

        /*
           var rootElement = document;
           
           var list = rootElement.querySelectorAll("[data-view='@"+name+"']");
           
           for(var i=0; i<list.length;i++) {
               var e = list[i];
               // the elements that have set this named view...
               
               var model = e.getAttribute("data-model");
               
               if(model.charAt(0)=="@") {
                   var mName = model.substring(1);
                   var m = _namedModels[mName];
                   if(m) {
                       console.log("********************************************");
                       console.log("==> could render model ",m);
                       console.log("==> the view template ", templateStr);
                       
                   }
           
               }
               
           }
           */
      }
      _myTrait_.broadcastDOMChange = function(rootElement, changeDelta) {

        _dataLink.execCommand(changeDelta);
        return;


        var v = changeDelta,
          me = this;


        // console.log("BROADCAST", v);    

        var fieldName = v[1],
          value = v[2],
          guid = v[4];

        // remove item
        if (v[0] == 8) {
          var removedGuid = value;
          var m = rootElement.querySelectorAll("[data-id='" + removedGuid + "']");
          for (var i = 0; i < m.length; i++) {
            var elem = m[i];
            if (elem.parentNode) {
              elem.parentNode.removeChild(elem);
            }
          };
        }

        // parentElement.insertBefore(newElement, referenceElement);
        // move item
        if (v[0] == 12) {

          var itemGuid = v[1],
            position = v[2];
          var elementList = rootElement.querySelectorAll("[data-id='" + itemGuid + "']");
          //console.log("Move item ", itemGuid, position);
          //console.log("Items ", elementList.length);
          for (var i = 0; i < elementList.length; i++) {
            var elem = elementList[i],
              parentElement = elem.parentNode;
            if (!parentElement) continue;

            // removing the child first...
            parentElement.removeChild(elem);

            var refNode = parentElement.childNodes[position];
            if (!refNode) refNode = null;
            if (parentElement) {
              //console.log("Found elem ", parentElement, elem, refNode);
              parentElement.insertBefore(elem, refNode);
            } else {
              // console.log("did not find");
            }
          };
        }

        if (v[0] == 7) {

          // Adding new element
          // TODO: another way, switch these other way around... not logical to change order!!!!
          var itemGuid = v[2],
            position = v[1];

          var model = _data({});
          var obj = model.findFromCache(itemGuid);

          //console.log("Ready to add another model object");
          //console.log(obj, guid);

          // then, where to insert...??? parent elements...
          var elementList = rootElement.querySelectorAll("[data-id='" + guid + "']");
          //console.log("Items ", elementList.length);

          for (var i = 0; i < elementList.length; i++) {
            var parentElement = elementList[i];

            //console.log("Trying to insert new elem to ", parentElement);
            if (!parentElement) continue;

            var elem = me.createElemFromTpl(parentElement, obj);
            var listLen = parentElement.childNodes.length;

            var refNode = parentElement.childNodes[position];
            if (!refNode) refNode = null;
            if (parentElement) {
              console.log("Found elem ", parentElement, elem, refNode);
              parentElement.insertBefore(elem, refNode);
            } else {
              console.log("did not find");
            }
          };




          /*    
               var elementList = rootElement.querySelectorAll("[data-id='"+itemGuid+"']");
               console.log("Move item ", itemGuid, position);
               console.log("Items ", elementList.length);
               for(var i=0; i<elementList.length; i++) {
                   var elem = elementList[i],
                       parentElement = elem.parentNode;
                   if(!parentElement) continue;
           
                   var refNode = parentElement.childNodes[position];
                   if(!refNode) refNode=null;
                   if(parentElement) {
                      console.log("Found elem ", parentElement, elem, refNode);
                      parentElement.insertBefore(elem, refNode);
                   } else {
                       console.log("did not find");
                   }
               };    
               */
        }


        // set property...
        if (v[0] == 4) {
          _dataLink.execCommand(v);
          return;
        }
      }
      _myTrait_.compileTplRaw = function(dataItem, html, parentElem) {

        if (parentElem) {
          var dom = document.createElement(parentElem);
          dom.innerHTML = html;
        } else {
          var dom = document.createElement("DIV");
          dom.innerHTML = html;
        }

        var me = this;
        me.domIterator(dom, function(elem, nameSpace) {

          // do not process comment nodes
          if (elem.nodeType == 8) return true;

          if (nameSpace == "svg") {
            for (var i = 0; i < elem.childNodes.length; i++) {
              var ch = elem.childNodes[i];
              // console.log(ch.tagName);
            }
          } else {

            if (elem && elem.getAttribute) {

              var viewName = elem.getAttribute("data-view");
              if (viewName) {
                var par = elem.parentNode;
                var html = elem.innerHTML;
                console.log("*** FOUND VIEW TEMPLATE ***");
                var viewDef = {
                  name: viewName,
                  elem: elem,
                  baseTpl: html.trim(),
                  parentTag: par.tagName
                };
                console.log(viewDef);
                me._saveViewTemplate(viewName, viewDef);
              }

              var modelName = elem.getAttribute("data-model");
              if (modelName) {

                var cProp;
                var templateList = {},
                  useClass = false;

                if (cProp = elem.getAttribute("data-class-switch")) {
                  useClass = true;
                  // var propsList = elem.getAttribute("data-props");
                  for (var ii = 0; ii < elem.childNodes.length; ii++) {
                    var tempCandidate = elem.childNodes[ii];
                    if (tempCandidate.getAttribute) {
                      var cName = tempCandidate.getAttribute("data-class");
                      if (cName) {
                        templateList[cName] = tempCandidate.outerHTML;
                      }
                    }
                  }
                }

                // if there is a model -template for certain class...
                var html = elem.innerHTML;
                me._addModelTemplate(elem, {
                  baseTpl: html.trim(),
                  classTpl: templateList,
                  cProp: cProp
                });

                elem.innerHTML = "";
                if (dataItem.data[modelName]) {
                  // TODO: check for datatype here...
                  var subModel = dataItem.data[modelName];
                  elem.setAttribute("data-id", subModel.__id);
                  elem.setAttribute("data-sub-id", subModel.__id);
                  // console.log("**** found a new submodel "+modelName+ " ***** ");
                  if (subModel.forEach) {
                    html = html.trim();
                    subModel.forEach(function(m) {
                      if (cProp) {
                        if (m.data[cProp]) {
                          var subClass = m.data[cProp],
                            h = templateList[subClass];
                          if (h) {
                            h = h.trim();
                            var newDom = me.createNewTemplate(m, h, elem.tagName);
                            elem.appendChild(newDom);

                          }
                        }
                      } else {
                        var newDom = me.createNewTemplate(m, html, elem.tagName);
                        elem.appendChild(newDom);
                      }
                    });
                  }
                }
                return true;
              }

              // if data properties...
              var propsList = elem.getAttribute("data-props");
              if (propsList) {
                var list = propsList.split(",");
                // This is the template to use...
                var subHtml = elem.innerHTML;
                elem.innerHTML = "";
                subHtml = subHtml.trim().split("\n").join(" ");
                list.forEach(function(propName) {

                  if (dataItem.data[propName]) {
                    // console.log(subHtml, propName);
                    var newTpl = subHtml.replace("{{propValue}}", "{{" + propName + "}}");
                    newTpl = newTpl.replace("{{propName}}", propName);
                    // console.log("After change ", newTpl);
                    // console.log("**** found a new submodel "+modelName+ " ***** ");

                    var newDom = me.createNewTemplate(dataItem, newTpl, elem.tagName);
                    elem.appendChild(newDom);
                  }


                });


                return true;
              }

            }

            if (elem.tagName && elem.tagName.toLowerCase() == "textarea") {
              //console.log("Textarea!!!");
              var v = elem.value;
              //console.log("Value "+v);
              var list = me.findTemplateList(v);
              for (var i = 0; i < list.length; i++) {
                var item = list[i];
                if (item.length > 3 && (item.charAt(0) == "{") && (item.charAt(1) == "{")) {

                  var vName = item.substring(2, item.length - 2);
                  //console.log("**** FOUND a value bind for TEXTAREA ****", vName);
                  // elem.setAttribute("data-id", dataItem._guid);
                  elem.setAttribute("data-value-id", dataItem.__id + "::" + vName);
                  elem.value = dataItem.data[vName];
                } else {

                }
              }
            }


            if (elem.tagName && elem.tagName.toLowerCase() == "style") {
              //console.log("Textarea!!!");
              var v = elem.innerHTML;
              v = v.trim();
              //console.log("Value "+v);
              var list = me.findTemplateList(v);
              for (var i = 0; i < list.length; i++) {
                var item = list[i];
                if (item.length > 3 && (item.charAt(0) == "{") && (item.charAt(1) == "{")) {

                  var vName = item.substring(2, item.length - 2);
                  //console.log("**** FOUND a value bind for TEXTAREA ****", vName);
                  // elem.setAttribute("data-id", dataItem._guid);
                  elem.setAttribute("data-text-id", dataItem.__id + "::" + vName);
                  elem.textContent = dataItem.data[vName];
                } else {

                }
              }
            }

            if (elem.tagName && elem.tagName.toLowerCase() == "select") {

              var v = elem.value;
              var dn = elem.getAttribute("data-name");

              if (dn) {
                // elem.setAttribute("data-id", dataItem._guid);
                elem.setAttribute("data-value-id", dataItem.__id + "::" + dn);

              }

            }

            var bFullElem = elem instanceof HTMLElement;
            if (elem.textContent && (!bFullElem) && !(nameSpace == "svg")) {
              //console.log("Trying to re-organize "+elem.tagName);
              //console.log("Which is child of "+elem.parentNode.tagName);
              //console.log("Which is  type "+elem.nodeType);
              //console.log("Whichs has "+elem.innerHTML);
              //console.log("whole '"+elem.wholeText+"'");
              //console.log("data '"+elem.data+"'");
              //console.log("whites "+elem.isElementContentWhitespace);
              /*
                       var doNot = false;
                       var p = elem.parentNode;
                       for( var ii=0; ii<p.childNodes.length; ii++) {
                           var pcc = p.childNodes[ii];
                           if(pcc) {
                               if(pcc.nodeType!= elem.nodeType) doNot = true;
                           }
                       }
                       
                       var myTxt = elem.wholeText.trim();
                       
                       console.log("trimmed text '"+myTxt+"'");
                       
                       
                       if(!elem.data.trim()) doNot = true;
                       if(!elem.wholeText.trim()) doNot = true;
                       
                       doNot = true;
                       */
              if (1) {
                // console.log("*** splitting the text into spans ***");
                var text = elem.textContent;
                text.trim();
                var list = me.findTemplateList(text);
                var newParent = document.createElement("span");
                var p = elem.parentNode;

                // cant do this text thing for textareas...
                if (p.tagName == "textarea" || p.tagName.toLowerCase() == "style") {
                  // we can't do this...

                  //console.log("*** textarea ***");
                  //console.log( text );

                } else {
                  elem.parentNode.replaceChild(newParent, elem);
                  newParent.setAttribute("data-sid", dataItem.__id);
                  for (var i = 0; i < list.length; i++) {
                    var s = document.createElement("span");
                    s.setAttribute("data-sid", dataItem.__id);
                    var item = list[i];
                    if (item.length > 3 && (item.charAt(0) == "{") && (item.charAt(1) == "{")) {
                      var vName = item.substring(2, item.length - 2);
                      if (dataItem.data[vName]) {
                        me._setDomText(s, dataItem.data[vName]);
                        s.setAttribute("data-text-id", dataItem.__id + "::" + vName);
                      }
                      newParent.appendChild(s);
                    } else {
                      me._setDomText(s, item);
                      newParent.appendChild(s);
                    }
                  }
                  return true; // Stop right here...
                }
              }
            }
          }
          if (nameSpace == "svg") {
            me.domAttrIterator(elem, function(n, v) {
              if (n == "data-text") {
                // then this might be assigned to some value...   
                elem.setAttributeNS(null, "data-text-id", dataItem.__id);
                me._setDomText(elem, dataItem.data[v]);
              } else {
                var list = me.findTemplateList(v);
                for (var i = 0; i < list.length; i++) {
                  var item = list[i];
                  if (item.length > 3 && (item.charAt(0) == "{") && (item.charAt(1) == "{")) {
                    if (n == "value") {
                      var vName = item.substring(2, item.length - 2);
                      //console.log("**** FOUND a value bind ****", n, v);
                      // elem.setAttributeNS(null, "data-id", dataItem._guid);
                      elem.setAttributeNS(null, "data-value-id", dataItem.__id + "::" + vName);
                      if (dataItem.data[vName]) elem.value = dataItem.data[vName];
                    } else {
                      var vName = item.substring(2, item.length - 2);
                      //console.log("**** FOUND an attr bind ****", n, v);
                      elem.setAttributeNS(null, "data-attr-" + dataItem.__id + "-" + vName, n);
                      if (dataItem.data[vName]) elem.setAttribute(n, dataItem.data[vName]);
                      ///  elem.setAttribute("data-value-id", dataItem._guid+"::"+vName);                          
                    }
                  } else {

                  }
                }
              }
            }, nameSpace);
          } else {
            me.domAttrIterator(elem, function(n, v) {

              if (n == "data-select") {
                // then this might be assigned to some value...   
                elem.setAttribute("data-select-id", dataItem.__id);
                elem.setAttribute("data-select-value", v);
                later().add(function() {
                  me.domIterator(elem, function(e) {
                    if (e && e.setAttribute) {
                      e.setAttribute("data-select-id", dataItem.__id);
                      e.setAttribute("data-select-value", v);
                    }
                  });
                });
                return;
              }

              if (n == "data-text") {
                // then this might be assigned to some value...   
                elem.setAttribute("data-text-id", dataItem.__id);
                me._setDomText(elem, dataItem.data[v]);
              } else {
                var list = me.findTemplateList(v);
                for (var i = 0; i < list.length; i++) {
                  var item = list[i];
                  if (item.length > 3 && (item.charAt(0) == "{") && (item.charAt(1) == "{")) {
                    if (n == "value") {
                      var vName = item.substring(2, item.length - 2);
                      //console.log("**** FOUND a value bind ****", n, v);
                      // elem.setAttribute("data-id", dataItem._guid);
                      elem.setAttribute("data-value-id", dataItem.__id + "::" + vName);
                      if (dataItem[vName]) elem.value = dataItem.data[vName];
                    } else {
                      var vName = item.substring(2, item.length - 2);
                      //console.log("**** FOUND an attr bind ****", n, v);
                      elem.setAttribute("data-attr-" + dataItem.__id + "-" + vName, n);
                      if (dataItem[vName]) elem.setAttribute(n, dataItem.data[vName]);
                      ///  elem.setAttribute("data-value-id", dataItem._guid+"::"+vName);                          
                    }
                  } else {

                  }
                }
              }
            });
          }

        });

        var tplDom = dom.childNodes[0];
        if (tplDom) {
          if (tplDom.getAttribute) {
            //console.log("SETTING ", dataItem._guid, tplDom, html);
            //console.log(dataItem.toData());
            if (!tplDom.getAttribute("data-id")) tplDom.setAttribute("data-id", dataItem.__id);
          }
        }

        return tplDom;

      }
      _myTrait_.composeModelView = function(dom, dataItem, modelView, renderToView) {
        var m = dataItem,
          me = this,
          t = modelView.baseTpl,
          itemView;

        if (renderToView) {
          itemView = renderToView;
        } else {
          itemView = me._createViewDef(m.__id, modelView);
        }
        if (t.classSwitch) {
          var subC;
          if (subC = m.data[t.classSwitch]) {
            var sT = t.classTemplates[subC];
            if (sT) {
              var newDom = me.composeTemplate(m, sT, itemView);

              if (renderToView) {
                console.log("Using Render to View ...");
                renderToView.dom.parentNode.replaceChild(newDom, renderToView.dom);
              } else {
                dom.appendChild(newDom);
              }
              itemView.dom = newDom;

              // Worker to observe changes for the class-switch
              var w = _dataLink._createWorker(m.__id, t.classSwitch, _workers().fetch(5), dom, {
                view: itemView,
                template: t,
                m: m,
                dom: newDom
              });

              itemView.workers.push(w);
            }
          }
        } else {
          var subTpl = t.children[0];
          var newDom = me.composeTemplate(m, subTpl, modelView);
          dom.appendChild(newDom);
          itemView.dom = newDom;
        }
      }
      _myTrait_.composeTemplate = function(dataItem, tpl, currentView) {

        if (!currentView) {
          currentView = this._createViewDef(dataItem.__id);
          currentView.baseTpl = tpl;
        }



        if (tpl.type == 3) {
          var dom;

          if (tpl.txtParts && tpl.txtParts.bHas) {

            var dom = document.createDocumentFragment();

            var list = tpl.txtParts.list,
              toks = tpl.txtParts.tokens;
            for (var i = 0; i < list.length; i++) {
              var vName;
              if (vName = toks[i]) {
                var val = "";
                if (typeof(dataItem.data[vName]) != "undefined") {
                  val = dataItem.data[vName] || "";
                }
                var tn = document.createTextNode(val);
                dom.appendChild(tn);

                // TODO create worker for the item...
                var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(1), tn, null);
                currentView.workers.push(w);

              } else {
                dom.appendChild(document.createTextNode(list[i] || ""));
              }
            }

          } else {
            dom = document.createTextNode(tpl.text || "");
          }
        }
        if (tpl.type == 1) {
          var dom, bSvgRoot = false;

          if (tpl.tagName == "svg") {
            // bSvgRoot = true;
            dom = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            // xmlns="http://www.w3.org/2000/svg" xmlns:xlink= "http://www.w3.org/1999/xlink"
            dom.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            dom.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
          } else {

            if (tpl.ns == "svg") {

              var dom = document.createElementNS("http://www.w3.org/2000/svg", tpl.tagName);
            } else {
              var dom = document.createElement(tpl.tagName);
            }
          }
          // if there is a value bind to the node, create worker for it...
          var bHadValue = false;

          if (!currentView.dom) currentView.dom = dom;


          if (!bSvgRoot) {
            if (tpl.valueParts && tpl.valueParts.bHas) {

              var list = tpl.valueParts.list,
                toks = tpl.valueParts.tokens;
              for (var i = 0; i < list.length; i++) {
                var vName;
                if (vName = toks[i]) {
                  var val = "";
                  if (typeof(dataItem.data[vName]) != "undefined") {
                    val = dataItem.data[vName] || "";
                  }
                  dom.value = val;

                  // TODO create worker for the item...
                  var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(2), dom, null);
                  currentView.workers.push(w);

                  tpl._seta(dom, "data-value-id", dataItem.__id + "::" + vName);

                } else {
                  dom.appendChild(document.createTextNode(list[i] || ""));
                }
              }
              bHadValue = true;
            }
            // TODO: data-attributes, are there any binds to them??
            if (tpl.attributes) {
              tpl.attributes.forEach(function(a) {
                var name = a[0],
                  value = a[1],
                  binds = a[2];
                if (name == "value") {
                  if (bHadValue) return;
                }
                var bHadB = false;

                if (_customDirectives[name]) {
                  var myVars = {},
                    rawValue;
                  var customOpts = {
                    currentView: currentView,
                    model: dataItem,
                    binds: binds,
                    name: name,
                    vars: myVars,
                    value: rawValue
                  };

                  if (binds) {
                    var list = binds.list,
                      toks = binds.tokens;
                    for (var i = 0; i < list.length; i++) {
                      var vName;
                      if (vName = toks[i]) {
                        var val = "";
                        if (typeof(dataItem.data[vName]) != "undefined") {
                          val = dataItem.data[vName] || "";
                        }
                        myVars[vName] = val;
                        customOpts.vars = myVars;
                        customOpts.value = val;


                        // This worker should remove all the workers for this DOM element
                        var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(6), dom, customOpts);
                        currentView.workers.push(w);

                      }
                    }
                  }


                  _customDirectives[name](dom, customOpts);
                }

                if (tpl.dataAttrs[name]) {
                  // might check here the attributes
                  // data-view
                  // data-model
                  // data-select
                  // data-id etc.
                  if (name == "data-attr-fwd") {
                    var varList = value.split(",");

                    varList.forEach(function(vName) {
                      vName = vName.trim();
                      var val = "",
                        name = vName;
                      var parts = vName.split("=>");
                      if (parts.length > 1) {
                        name = parts[1].trim();
                        vName = parts[0].trim();
                      }
                      if (typeof(dataItem.data[vName]) != "undefined") {
                        val = dataItem.data[vName] || "";
                      }
                      // dom.setAttribute(name, val);
                      tpl._seta(dom, name, val);

                      // TODO create worker for the item...
                      if (tpl.ns == "svg") {
                        var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(4), dom, name);
                      } else {
                        var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(3), dom, name);
                      }
                      currentView.workers.push(w);
                      bHadB = true;
                    });
                  }
                }


                // dom.setAttribute(name, value);
                if (binds) {
                  var list = binds.list,
                    toks = binds.tokens;
                  for (var i = 0; i < list.length; i++) {
                    var vName;
                    if (vName = toks[i]) {
                      var val = "";
                      if (typeof(dataItem.data[vName]) != "undefined") {
                        val = dataItem.data[vName] || "";
                      }
                      // dom.setAttribute(name, val);
                      tpl._seta(dom, name, val);

                      // TODO create worker for the item...
                      if (tpl.ns == "svg") {
                        var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(4), dom, name);
                      } else {
                        var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(3), dom, name);
                      }
                      currentView.workers.push(w);
                      bHadB = true;
                    }
                  }
                }
                if (!bHadB) {
                  tpl._seta(dom, name, value);
                }


              })
            }
          }

          if (tpl.children) {
            var me = this;
            // data-model change here
            // data-view definitions
            // create a parent view etc....
            // model changes, views and so on should be taken into account here...
            tpl.children.forEach(function(t) {
              // Sub template..
              var modelName = t.dataAttrs["data-model"],
                viewName = t.dataAttrs["data-view"],
                cProp; // now undefined

              if (modelName) {


                if (t.ns == "svg") {
                  var childDom = document.createElementNS("http://www.w3.org/2000/svg", tpl.tagName);
                } else {
                  var childDom = document.createElement(t.tagName);
                }


                if (typeof(dataItem.data[modelName]) != "undefined") {

                  // TODO: check for datatype here...
                  var subModel = dataItem.data[modelName];
                  var modelView = me._createViewDef(subModel.__id, currentView);

                  modelView.dom = childDom;

                  // if this is actually a model-view, then save the name...
                  if (viewName) me._setNamedView(viewName, modelView);

                  t._seta(childDom, "data-id", subModel.__id);
                  // childDom.setAttribute("data-id", subModel.__id);
                  modelView.tagName = t.tagName;
                  modelView.baseTpl = t;

                  // This should create a worker for the model view...
                  var w = _dataLink._createWorker(subModel.__id, "*", _workers().fetch(7), modelView);
                  modelView.workers.push(w);

                  if (subModel.data.forEach) {
                    subModel.data.forEach(function(m) {
                      me.composeModelView(childDom, m, modelView);
                    });
                  }
                  dom.appendChild(childDom);
                }

              } else {

                var childDom = me.composeTemplate(dataItem, t, currentView);
                if (childDom) {
                  dom.appendChild(childDom);
                }
              }
            });
          }

        }

        return dom;

      }
      _myTrait_.createElemFromTpl = function(elem, model) {

        /*
                           me._addModelTemplate( elem, {
                               baseTpl : html.trim(),
                               classTpl : templateList,
                               cProp : cProp
                           });
           */

        // if you need to find again the compiled template options for this current
        // view for the template...
        var tpl = this._findModelTemplate(elem);

        console.log("Tpl", tpl);

        var cProp = tpl.cProp,
          html = tpl.baseTpl,
          m = model,
          me = this;

        if (cProp) {
          var templateList = tpl.classTpl;
          if (m.data[cProp]) {
            var subClass = m.data[cProp],
              h = templateList[subClass];
            if (h) {
              h = h.trim();
              var newDom = me.createNewTemplate(m, h, elem.tagName);
              return newDom; // elem.appendChild( newDom );  
            }
          }
        } else {
          var newDom = me.createNewTemplate(m, html, elem.tagName);
          return newDom; // elem.appendChild( newDom );
        }
      }
      _myTrait_.createItemView = function(item) {
        var vf = this.getViewFunction(item),
          me = this,
          newView;
        if (vf) {
          newView = vf(item);

          if (item.viewClass) {
            if (this.isFunction(item.viewClass)) {
              var oo = item.viewClass(null, true);
              var oldClass = item.viewClass();
              var myEventH = function(o, v) {
                if (oldClass != v) {
                  console.log("Replaced to " + v);
                  var nv = me.createItemView(item);
                  oldClass = v;
                  newView.replaceWith(nv);
                  newView = nv;
                  oo.me.removeListener(oo.name, myEventH);
                }
              };
              oo.me.on(oo.name, myEventH);
            }
          }

        }
        return newView;
      }
      _myTrait_.createNewTemplate = function(dataItem, html, parentView) {

        if (parentView) {
          var dom = document.createElement(parentView.tagName);
          dom.innerHTML = html;
        } else {
          var dom = document.createElement("DIV");
          dom.innerHTML = html;
        }
        /*
           var viewDef = {
               dataid : dataId,
               baseTpl : "",
               parentView : null
           }
           */

        // here is the view definition...
        var currentView = this._createViewDef(dataItem.__id, parentView);

        currentView.baseTpl = html;

        // console.log( "Entering the createNewTemplate with ", dataItem, html);

        var me = this;
        me.domIterator(dom, function(elem, nameSpace) {

          var localView = null;

          // do not process comment nodes
          if (elem.nodeType == 8) return true;

          if (nameSpace == "svg") {
            for (var i = 0; i < elem.childNodes.length; i++) {
              var ch = elem.childNodes[i];
              // console.log(ch.tagName);
            }
          } else {

            if (elem && elem.getAttribute) {

              // for example content Area...

              var viewName = elem.getAttribute("data-view");
              var modelName = elem.getAttribute("data-model");

              // if this is just a name for the view..
              if (viewName && !(modelName)) {
                me._setNamedView(viewName, currentView);
              }

              // *** data model essentially creates a new model-view for the array - object ***
              // TODO: the model could be also traditional object, here only arrays are considered

              if (modelName) {

                // Object HAS view... mark the object having the view using the view definition...
                // CREATE new view... can the view be a class or should it be just object def
                // let's do it using object def to save memory...


                //console.log("*** MODEL ", modelName);
                //console.log(dataItem);

                var cProp;
                var templateList = {},
                  useClass = false;

                if (cProp = elem.getAttribute("data-class-switch")) {
                  useClass = true;
                  // var propsList = elem.getAttribute("data-props");
                  for (var ii = 0; ii < elem.childNodes.length; ii++) {
                    var tempCandidate = elem.childNodes[ii];
                    if (tempCandidate.getAttribute) {
                      var cName = tempCandidate.getAttribute("data-class");
                      if (cName) {
                        templateList[cName] = tempCandidate.outerHTML;
                      }
                    }
                  }
                }

                // if there is a model -template for certain class...
                var html = elem.innerHTML;
                me._addModelTemplate(elem, {
                  baseTpl: html.trim(),
                  classTpl: templateList,
                  cProp: cProp
                });

                elem.innerHTML = "";
                if (typeof(dataItem.data[modelName]) != "undefined") {

                  // <div data-model="items" data-view="contentList">



                  // TODO: check for datatype here...
                  var subModel = dataItem.data[modelName];
                  var modelView = me._createViewDef(subModel.__id, currentView);
                  modelView.dom = elem;

                  // if this is actually a model-view, then save the name...
                  if (viewName) me._setNamedView(viewName, modelView);

                  elem.setAttribute("data-id", subModel.__id);
                  elem.setAttribute("data-sub-id", subModel.__id);
                  // console.log("**** found a new submodel "+modelName+ " ***** ");
                  modelView.tagName = elem.tagName;

                  if (subModel.data.forEach) {
                    html = html.trim();
                    subModel.data.forEach(function(m) {
                      // console.log(m, "with", html);
                      if (cProp) {
                        if (typeof(m.data[cProp]) != "undefined") {
                          var subClass = m.data[cProp],
                            h = templateList[subClass];
                          if (h) {
                            h = h.trim();
                            var newDom = me.createNewTemplate(m, h, modelView);
                            elem.appendChild(newDom);

                          }
                        }
                      } else {
                        var newDom = me.createNewTemplate(m, html, modelView);
                        elem.appendChild(newDom);
                      }
                    });
                  }
                }
                return true;
              }

              // if data properties...
              var propsList = elem.getAttribute("data-props");
              if (propsList) {
                var list = propsList.split(",");
                // This is the template to use...
                var subHtml = elem.innerHTML;
                elem.innerHTML = "";
                subHtml = subHtml.trim().split("\n").join(" ");
                list.forEach(function(propName) {

                  if (typeof(dataItem.data[propName]) != "undefined") {
                    // console.log(subHtml, propName);
                    var newTpl = subHtml.replace("{{propValue}}", "{{" + propName + "}}");
                    newTpl = newTpl.replace("{{propName}}", propName);
                    // console.log("After change ", newTpl);
                    // console.log("**** found a new submodel "+modelName+ " ***** ");
                    var pView = {
                      tagName: elem.tagName
                    }
                    var newDom = me.createNewTemplate(dataItem, newTpl, pView);
                    elem.appendChild(newDom);
                  }


                });


                return true;
              }

            }

            if (elem.tagName && elem.tagName.toLowerCase() == "textarea") {
              //console.log("Textarea!!!");
              var v = elem.value;
              //console.log("Value "+v);
              var list = me.findTemplateList(v);
              for (var i = 0; i < list.length; i++) {
                var item = list[i];
                if (item.length > 3 && (item.charAt(0) == "{") && (item.charAt(1) == "{")) {

                  var vName = item.substring(2, item.length - 2);
                  //console.log("**** FOUND a value bind for TEXTAREA ****", vName);
                  // elem.setAttribute("data-id", dataItem._guid);
                  elem.setAttribute("data-value-id", dataItem.__id + "::" + vName);
                  elem.value = dataItem.data[vName];
                } else {

                }
              }
            }


            if (elem.tagName && elem.tagName.toLowerCase() == "style") {
              //console.log("Textarea!!!");
              var v = elem.innerHTML;
              v = v.trim();
              //console.log("Value "+v);
              var list = me.findTemplateList(v);
              for (var i = 0; i < list.length; i++) {
                var item = list[i];
                if (item.length > 3 && (item.charAt(0) == "{") && (item.charAt(1) == "{")) {

                  var vName = item.substring(2, item.length - 2);
                  //console.log("**** FOUND a value bind for TEXTAREA ****", vName);
                  // elem.setAttribute("data-id", dataItem._guid);
                  elem.setAttribute("data-text-id", dataItem.__id + "::" + vName);
                  elem.textContent = dataItem.data[vName];
                } else {

                }
              }
            }

            if (elem.tagName && elem.tagName.toLowerCase() == "select") {

              var v = elem.value;
              var dn = elem.getAttribute("data-name");

              if (dn) {
                // elem.setAttribute("data-id", dataItem._guid);
                elem.setAttribute("data-value-id", dataItem.__id + "::" + dn);

              }

            }

            var bFullElem = elem instanceof HTMLElement;
            if (elem.textContent && (!bFullElem) && !(nameSpace == "svg")) {
              //console.log("Trying to re-organize "+elem.tagName);
              //console.log("Which is child of "+elem.parentNode.tagName);
              //console.log("Which is  type "+elem.nodeType);
              //console.log("Whichs has "+elem.innerHTML);
              //console.log("whole '"+elem.wholeText+"'");
              //console.log("data '"+elem.data+"'");
              //console.log("whites "+elem.isElementContentWhitespace);
              /*
                       var doNot = false;
                       var p = elem.parentNode;
                       for( var ii=0; ii<p.childNodes.length; ii++) {
                           var pcc = p.childNodes[ii];
                           if(pcc) {
                               if(pcc.nodeType!= elem.nodeType) doNot = true;
                           }
                       }
                       
                       var myTxt = elem.wholeText.trim();
                       
                       console.log("trimmed text '"+myTxt+"'");
                       
                       
                       if(!elem.data.trim()) doNot = true;
                       if(!elem.wholeText.trim()) doNot = true;
                       
                       doNot = true;
                       */
              if (1) {
                // console.log("*** splitting the text into spans ***");
                var text = elem.textContent;
                text.trim();
                var list = me.findTemplateList(text);
                var newParent = document.createElement("span");
                var p = elem.parentNode;

                // cant do this text thing for textareas...
                if (p.tagName == "textarea" || p.tagName.toLowerCase() == "style") {
                  // we can't do this...

                  //console.log("*** textarea ***");
                  //console.log( text );

                } else {
                  elem.parentNode.replaceChild(newParent, elem);
                  newParent.setAttribute("data-sid", dataItem.__id);
                  for (var i = 0; i < list.length; i++) {
                    var s = document.createElement("span");
                    s.setAttribute("data-sid", dataItem.__id);
                    var item = list[i];
                    if (item.length > 3 && (item.charAt(0) == "{") && (item.charAt(1) == "{")) {
                      var vName = item.substring(2, item.length - 2);
                      if (typeof(dataItem.data[vName]) != "undefined") {
                        // up._createWorker( t.__id, 'cx', svgAW,  rectDOM, 'x' );

                        var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(1), s, null);
                        currentView.workers.push(w);
                        me._setDomText(s, dataItem.data[vName]);

                        // The "data-text-id" is not necessary here any more...
                        s.setAttribute("data-text-id", dataItem.__id + "::" + vName);
                      }
                      newParent.appendChild(s);
                    } else {
                      me._setDomText(s, item);
                      newParent.appendChild(s);
                    }
                  }
                  return true; // Stop right here...
                }
              }
            }
          }
          if (nameSpace == "svg") {
            me.domAttrIterator(elem, function(n, v) {
              if (n == "data-text") {
                // then this might be assigned to some value...   
                elem.setAttributeNS(null, "data-text-id", dataItem.__id);
                me._setDomText(elem, dataItem.data[v]);
              } else {
                var list = me.findTemplateList(v);
                for (var i = 0; i < list.length; i++) {
                  var item = list[i];
                  if (item.length > 3 && (item.charAt(0) == "{") && (item.charAt(1) == "{")) {
                    if (n == "value") {
                      var vName = item.substring(2, item.length - 2);
                      // console.log("**** FOUND a value bind ****", n, v);
                      // elem.setAttributeNS(null, "data-id", dataItem._guid);
                      elem.setAttributeNS(null, "data-value-id", dataItem.__id + "::" + vName);
                      if (dataItem.data[vName]) elem.value = dataItem.data[vName];
                    } else {
                      var vName = item.substring(2, item.length - 2);
                      //console.log("**** FOUND an attr bind ****", n, v);
                      elem.setAttributeNS(null, "data-attr-" + dataItem.__id + "-" + vName, n);
                      if (dataItem.data[vName]) elem.setAttribute(n, dataItem.data[vName]);
                      ///  elem.setAttribute("data-value-id", dataItem._guid+"::"+vName);                          
                    }
                  } else {

                  }
                }
              }
            }, nameSpace);
          } else {
            me.domAttrIterator(elem, function(n, v) {

              if (n == "data-select") {
                // then this might be assigned to some value...   
                elem.setAttribute("data-select-id", dataItem.__id);
                elem.setAttribute("data-select-value", v);
                later().add(function() {
                  me.domIterator(elem, function(e) {
                    if (e && e.setAttribute) {
                      e.setAttribute("data-select-id", dataItem.__id);
                      e.setAttribute("data-select-value", v);
                    }
                  });
                });
                return;
              }

              if (n == "data-text") {
                // then this might be assigned to some value...   
                elem.setAttribute("data-text-id", dataItem.__id);
                me._setDomText(elem, dataItem.data[v]);
              } else {
                var list = me.findTemplateList(v);
                for (var i = 0; i < list.length; i++) {
                  var item = list[i];
                  if (item.length > 3 && (item.charAt(0) == "{") && (item.charAt(1) == "{")) {
                    if (n == "value") {
                      var vName = item.substring(2, item.length - 2);
                      // console.log("**** FOUND a value bind ****", n, v);
                      // elem.setAttribute("data-id", dataItem._guid);
                      elem.setAttribute("data-value-id", dataItem.__id + "::" + vName);

                      // input worker...
                      var w = _dataLink._createWorker(dataItem.__id, vName, _workers().fetch(2), elem, null);
                      currentView.workers.push(w);
                      // currentView

                      if (typeof(dataItem.data[vName]) != "undefined") elem.value = dataItem.data[vName];
                    } else {
                      var vName = item.substring(2, item.length - 2);
                      // console.log("**** FOUND an attr bind ****", n, v);
                      elem.setAttribute("data-attr-" + dataItem.__id + "-" + vName, n);
                      if (typeof(dataItem.data[vName]) != "undefined") elem.setAttribute(n, dataItem.data[vName]);
                      ///  elem.setAttribute("data-value-id", dataItem._guid+"::"+vName);                          
                    }
                  } else {

                  }
                }
              }
            });
          }

        });

        var tplDom = dom.childNodes[0];
        if (tplDom) {
          if (tplDom.getAttribute) {
            //console.log("SETTING ", dataItem._guid, tplDom, html);
            //console.log(dataItem.toData());
            if (!tplDom.getAttribute("data-id")) tplDom.setAttribute("data-id", dataItem.__id);
          }
        }

        currentView.dom = tplDom;

        return tplDom;

      }
      _myTrait_.findTemplateList = function(str) {
        // So, the templates are of form {{firstname}} {{lastname}}

        // parset this list into parts...

        var parts = str.split("{{"),
          len = parts.length,
          hCnt = 0;

        if (len < 2) {
          return [str];
        }

        //console.log("*parts*");
        //console.log(parts);

        var list = [];
        for (var i = 0; i < parts.length; i++) {
          var part = parts[i];

          if (part.length == 0) continue;

          var rest = part.split("}}");
          if (rest.length > 1) {
            list.push("{{" + rest[0] + "}}");
            list.push(rest[1]);
          } else {
            // there was no end
            list.push(part);
          }
        }

        return list;
      }
      _myTrait_.getViewFunction = function(item) {
        if (this.isFunction(this._view)) {
          return this._view;
        }
        if (item.viewClass) {
          var vf;
          if (vf = this._view[item.viewClass()])
            return vf;
        }
        // if no other options...
        for (var n in this._view) {
          if (this._view.hasOwnProperty(n)) {
            var vf = this._view[n];
            if (this.isFunction(vf)) {
              return vf;
            }
          }
        }
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {


        if (!_namedModels) {
          _namedModels = {};
          _namedViews = {};
          _dataLink = _docUp();
        }
      });
      _myTrait_.mvc = function(model, view, controller) {
        var me = this;
        if (view) {
          this._view = view;
        }

        if (model) {
          // assume now that it is array 
          this._model = model;

          // TODO: sort, delete, move...
          if (this._model.on) {
            this._model.on("insert", function(o, i) {
              // console.log("Inserting new item at ",i);

              //console.log("len ",me._children.length);
              //console.log("iterating children for ",i);

              var item = me._model.item(i);
              // console.log("The item was ", item);
              //console.log("len ",me._children.length);
              var nv = me.createItemView(item);
              //console.log("len ",me._children.length);
              if (nv) {
                //console.log("len ",me._children.length);
                me.insertAt(i, nv);

              } else {
                //console.log("Was not able to create new item");
              }

              /*
                       for(var i=0; i<me._children.length; i++) {
                           var ch = me._children[i];
                           console.log(i);
                           console.log(ch._dom);
                       }  
                       */

            });

            this._model.on("move", function(o, cmd) {
              //console.log(cmd);
              var old = me.child(cmd.from),
                after = me.child(cmd.to);
              //console.log("Old", old);
              //console.log("After", after);

              if (!after || !old) {
                console.log("**** could not perform move ****");
                console.log(cmd);
                console.log(me);
                console.log(me._children.length);
                console.log(old);
                console.log(after);
                console.trace();

                return;
              }

              if (cmd.to < cmd.from) {
                //console.log("insertBefore ");
                after.insertBefore(old);
              } else {
                after.insertAfter(old);
              }
              /*
                       var item = me._model.item(i);
                       var nv = me.createItemView(item);
                       if(nv) {
                           me.insertAt(i,nv);
                       }
                       */
            });
            this._model.on("remove", function(o, i) {

              // console.log("Asking to remove child ",i);


              // The child...
              /*
                       console.log("Asking to remove child ",i);
                       for(var i=0; i<me._children.length; i++) {
                           var ch = me._children[i];
                           console.log(i);
                           console.log(ch._dom);
                       }
                       */

              var ch = me.child(i);
              if (ch) {
                // console.log(ch._dom);
                ch.remove();
              }
              /*
                       for(var i=0; i<me._children.length; i++) {
                           var ch = me._children[i];
                           console.log(i);
                           console.log(ch._dom);
                       } 
                       */

            });
            this._model.on("sort", function(o, ops) {

              if (ops.length == 0) return;

              if (me.isObject(ops[0][1])) return;

              var tmpOps = new Array();

              // console.log("Sort with", ops, JSON.stringify(ops));
              for (var i = 0; i < ops.length; i++) {
                if (ops[i][1] == ops[i][2]) {
                  ops[i][0] = null;
                  continue;
                }
                tmpOps[i] = new Array(3);
                tmpOps[i][1] = me.child(ops[i][1]);
                tmpOps[i][2] = me.child(ops[i][2]);
              }

              // console.log("Sort with", ops, JSON.stringify(ops));
              for (var i = 0; i < tmpOps.length; i++) {
                var c1 = tmpOps[i][1],
                  c2 = tmpOps[i][2],
                  cmd = ops[i][0];
                if (cmd == "a") {
                  c2.insertBefore(c1);
                }
                if (cmd == "b") {
                  c2.insertAfter(c1);
                }
              }

            });
          }

          if (this._model.forEach) {
            this._model.forEach(function(item) {
              var nv = me.createItemView(item);
              if (nv) {
                me.add(nv);
              }
            });
          }

        }

        if (controller) {
          this._controller = controller;
        }
        return this;
      }
      _myTrait_.popCurrentView = function(viewName) {
        if (!_viewTemplates) return;

        if (!_viewContent) {
          _viewContent = {};
        }

        var theView = document.querySelector("[data-view='" + viewName + "']");

        if (theView) {

          console.log("*** FOUND The view...*****");
          if (!_viewContent[viewName]) {
            _viewContent[viewName] = [];
          }

          var currData = _viewContent[viewName].pop();

          if (!currData) return;

          // Find template...

          var tplDef = _viewTemplates[viewName];
          /*
               var viewDef = {
                   name : viewName,
                   elem : elem,
                   baseTpl : html.trim(),
                   parentTag : par.tagName
               };
           */

          // Might push another view now...
          // Changes the view to have this kind of content...
          var newDom = this.createNewTemplate(currData.model, tplDef.baseTpl, tplDef.parentTag);
          console.log("Created newDom ", newDom.innerHTML);
          theView.innerHTML = "";
          theView.appendChild(newDom);


        }
      }
      _myTrait_.pushToView = function(viewName, model) {

        // The view has certain content...
        /*   
              <div data-view="topnavi">
                   The top navigation has this kind of content, which is quite nice :)  - this can be done of course...
              </div>
           */

        if (!_viewTemplates) return;

        if (!_viewContent) {
          _viewContent = {};
        }

        // here you have the view definition... like
        // <div data-view="leftNavi"></div>
        // find the view definition....

        var theView = document.querySelector("[data-view='" + viewName + "']");
        var me = this;

        if (theView) {
          console.log("*** FOUND The view...*****");
          if (!_viewContent[viewName]) {
            _viewContent[viewName] = [];
          }

          // Find template...

          var tplDef = _viewTemplates[viewName];
          /*
               var viewDef = {
                   name : viewName,
                   elem : elem,
                   baseTpl : html.trim(),
                   parentTag : par.tagName
               };
           */

          // Might push another view now...
          // Changes the view to have this kind of content...
          var newDom = this.createNewTemplate(model, tplDef.baseTpl, tplDef.parentTag);
          console.log("Created newDom ", newDom.innerHTML);
          theView.innerHTML = "";
          theView.appendChild(newDom);

          if (!model._didBindA) {
            model._didBindA = true;
            model.onValue("change", function(v) {
              me.broadcastDOMChange(document, v);
            });
          }

          // save the old view definition, to be restored later on...
          var viewContentDef = {
            model: model
          };
          _viewContent[viewName].push(viewContentDef);

        }

      }
      _myTrait_.renderTemplate = function(rootData, templateObj) {

        var tpl;
        var main = this;
        var me = this;

        // if the template is actually function....
        if (this.isFunction(templateObj)) {

          var oo = templateObj(null, true);
          // if the tpl is updated.
          oo.me.on(oo.name, function() {
            // Then render the templates data again on the rootnode...
            me.renderTemplate(rootData, templateObj());
          });
          tpl = templateObj();
        } else {
          tpl = templateObj;
        }

        me.clear();

        if (!me.evenInfo) {
          me.evenInfo = {
            isOn: false
          }
        }

        if (!main._hasRenderCh) {


          main._dom.addEventListener("dblclick", function(event) {
            me._eventActionFor(event, "data-dbl-click", rootData);
          });
          main._dom.addEventListener("mouseenter", function(event) {
            me._eventActionFor(event, "data-mouseenter", rootData);
          });
          main._dom.addEventListener("mouseleave", function(event) {
            me._eventActionFor(event, "data-mouseleave", rootData);
          });
          main._dom.addEventListener("mousemove", function(event) {
            me._eventActionFor(event, "data-mousemove", rootData);
          });
          main._dom.addEventListener("keydown", function(event) {
            me._eventActionFor(event, "data-keydown", rootData);
          });
          main._dom.addEventListener("keyup", function(event) {
            me._eventActionFor(event, "data-keyup", rootData);
          });
          main._dom.addEventListener("change", function(event) {
            me._eventActionFor(event, "data-change", rootData);
          });

          main._dom.addEventListener("click", function(event) {

            // console.log("had a click event");

            var elem = event.target;
            if (!elem) return;

            var isSid = elem.getAttribute("data-sid"),
              myId = elem.getAttribute("data-id");

            //         if(isSid) console.log("***** SID !!! ******");
            if (isSid && !myId) {
              elem = elem.parentNode;
              var isSid = elem.getAttribute("data-sid"),
                myId = elem.getAttribute("data-id");
              if (isSid && !myId) {
                elem = elem.parentNode;
              }
            }

            var routeId = elem.getAttribute("data-select-id");
            // dataItem._guid+"::"+vName
            if (routeId) {
              var oo = rootData.findFromCache(routeId);
              var value = elem.getAttribute("data-select-value");
              // e.setAttribute("data-select-value
              main.emitValue("select", {
                obj: oo,
                value: value
              });
            }

            // Might be also "any" view with name...
            var routeId = elem.getAttribute("data-popview");

            if (routeId) {

              var findView = elem;
              while (findView) {
                if (findView.getAttribute) {
                  var vn;
                  if (vn = findView.getAttribute("data-view")) {
                    me.popCurrentView(vn);
                    break;
                  }
                }
                findView = findView.parentNode;
              }
            }

            var action = elem.getAttribute("data-action");
            // dataItem._guid+"::"+vName
            if (action) {
              var max = 10,
                dom = elem,
                objid;
              // console.log("Looking action ", action);
              while (dom && !(objid = dom.getAttribute("data-id")) && (max--)) {
                dom = dom.parentNode;
              }
              if (dom && objid) {
                // console.log("Had object ", objid);
                var params = action.split("("),
                  action = params.shift();
                var argStr = params.pop(),
                  plist = null;
                if (argStr) {
                  var prms = argStr.split(")"),
                    plist = prms.shift().split(",");
                }
                // console.log("Found the action");
                var oo = rootData.findFromCache(objid);
                // if(!oo) console.log("**** DID NOT FIND THE OBJECT FROM CACHE ***");
                if (oo && me.isFunction(oo[action])) {
                  if (me.isArray(plist)) {
                    //console.log("Calling with parans ", plist);  
                    oo[action].apply(oo, plist);
                  } else {
                    oo[action](); // just a test for the sake of easiness...
                  }
                } else {
                  //console.log("The object  had no ", action);
                  //console.log(oo);
                }
              }
            }

          });
          main._hasRenderCh = true;

          main._dom.addEventListener("input", function(event) {
            var elem = event.target;
            if (!elem) return;
            var routeId = elem.getAttribute("data-value-id");
            // dataItem._guid+"::"+vName
            if (routeId) {
              var parts = routeId.split("::");

              // console.log("Changed ", parts);

              // Then, tell others...

              var objid = parts[0];
              var obj = _docUp()._find(objid),
                prop = parts[1];

              if (!obj) {
                // console.log("**** value changed, but object not in cache ****");
                return;
              }

              // Change the object value...
              if (typeof(obj.data[prop]) != "undefined") {
                var v = elem.value,
                  oldValue = obj.data[prop];
                if (v != oldValue) {
                  obj.data[prop] = v;

                  // AND emit then change event...
                  _docUp()._emitEvent(parts[0], "change", [4, prop, v, oldValue, objid]);
                }

                //                obj[prop](elem.value); 
              }
              // Should be handled by the broadcast
              /*        
                       var m = document.querySelectorAll("[data-text-id='"+routeId+"']");
                       for(var i=0; i<m.length; i++) {
                           var ee = m[i];
                           ee.textContent= elem.value;
                       };        
                       
                       var m = document.querySelectorAll("[data-attr-"+parts[0]+"-"+parts[1].toLowerCase());
                       for(var i=0; i<m.length; i++) {
                           var ee = m[i];
                           var aN = ee.getAttribute( "data-attr-"+parts[0]+"-"+parts[1].toLowerCase());
                           ee.setAttribute(aN, elem.value);
                       };        
                       
                       var oo = rootData.findFromCache(parts[0]);
                       
                       if(oo) {
                           me.evenInfo.isOn = true;
                           if(oo[parts[1]]) oo[parts[1]]( elem.value );
                           me.evenInfo.isOn = false;
                       }
                       */

            }
          });
        }

        tpl = tpl.trim();

        try {
          var dom = this.createNewTemplate(rootData, tpl);
        } catch (e) {
          return this;
        }


        this._dom.appendChild(dom);

        if (!rootData._didBindA) {
          rootData._didBindA = true;
          // TODO:
          // Changing the root-data event can not be binded here... the "onValue" change is not triggered
          // because of the new object model does not have this kind of change event...
          // Listening the changes for some certain object is to be implemented

          _docUp()._onValue(rootData.__id, "change", function(v) {
            // We got the change here..
            me.broadcastDOMChange(document, v);
          });
          /*
               rootData.onValue("change", function(v) {
                   // Making the change to be a real DOM mutation... this might be a generic function to do so...
                   if(me.evenInfo.isOn) return;
                   me.broadcastDOMChange( document, v );
               });
               */

        }

        return this;

      }
      _myTrait_.template = function(dataList, html) {

        // here the dataList is of type _data and of type "array", if there is 
        // mutation in the array, then something must happen at the clientside

        this._htmlTemplate = html;




      }
      _myTrait_.templateIterator = function(elem, fn, nameSpace) {

        if (!elem) return;

        var noRecurse = {
          "textarea": true
        };


        var childNodes = elem.children;
        if (childNodes) {
          var len = childNodes.length;
          for (var i = 0; i < len; i++) {
            var child = childNodes[i];
            if (child) {
              var bStop = fn(child, nameSpace);
              if (bStop) {

              } else {
                this.templateIterator(child, fn);
              }

            }
          }
        }

      }
    }(this));;
    (function(_myTrait_) {
      _myTrait_.circle = function(className, attrs) {
        var el = this.shortcutFor("circle", className, attrs);
        return el;
      }
      _myTrait_.createPath = function(pathString, w, h) {

        var p = svgPathParser();
        p.parse(pathString);
        p.makePathAbsolute();
        if (w && h) p.fitPathInto(w, h);

        return this.path({
          d: p.svgString()
        });

      }
      _myTrait_.createShadowFilter = function(withId, amount, dx, dy) {

        var svgRoot = this;

        later().add(
          function() {

            while (svgRoot && !(svgRoot._dom.tagName == "svg")) {
              svgRoot = svgRoot.parent();
              console.log("Looking ", svgRoot);
            }

            if (svgRoot) {
              console.log("Found svgRoot for filter " + withId);
              console.log("Tag is ", svgRoot._dom.tagName, svgRoot);
            } else {
              console.log("Did not find the svgRoot for filter " + withId);
            }

            if (!dx) dx = 0;
            if (!dy) dy = 0;
            if (!amount) amount = 5;

            if (svgRoot && (svgRoot._dom.tagName == "svg")) {

              var findDef = null;
              svgRoot.forChildren(function(ch) {
                if (ch._dom.tagName == "defs") findDef = ch;
              })

              var defs;
              if (findDef) {
                defs = findDef;
              } else {
                defs = svgRoot.defs();
              }

              console.log("Defs for " + withId, "is", defs);

              var filter = defs.filter("", {
                id: withId,
                height: "130%"
              });
              filter.feGaussianBlur("", { in : "SourceAlpha",
                stdDeviation: amount
              });
              filter.feOffset("", {
                dx: dx,
                dy: dy,
                result: "offsetblur"
              });
              var merge = filter.feMerge();
              merge.feMergeNode();
              merge.feMergeNode("", { in : "SourceGraphic"
              });

              return filter;

            }
          });


      }
      _myTrait_.defs = function(className, attrs) {
        var el = this.shortcutFor("defs", className, attrs);
        return el;
      }
      _myTrait_.draggableBox = function(options) {
        options = options || {};
        if (!options.x) options.x = 0;
        if (!options.y) options.y = 0;
        var rData = _data({
            x: options.x,
            y: options.y,
            alpha: options.alpha || 1
          })
          // SVG element, test layer goes here...
        var rect = this.rect("", {
          fill: options.fillStyle || "yellow",
          x: rData.x,
          y: rData.y,
          width: 10,
          height: 10,
          "fill-opacity": rData.alpha
        });

        // where the data-model should be placed?
        rect._data = rData;

        rect._x = rData.x();
        rect._y = rData.y();

        var sx, sy, me;
        rect.draggable(function() {
          sx = rData.x(),
          sy = rData.y();
          rect.trigger("focus");
        }, function(o, dv) {
          rData.x(dv.dx + sx);
          rData.y(dv.dy + sy);

          rect._x = rData.x();
          rect._y = rData.y();

          rect.trigger("x", rData.x());
          rect.trigger("y", rData.y());
          rect.trigger("change");
        }, function(o, dv) {
          rData.x(dv.dx + sx);
          rData.y(dv.dy + sy);
          rect.trigger("x", rData.x());
          rect.trigger("y", rData.y());
          rect._x = rData.x();
          rect._y = rData.y();
          rect.trigger("blur");
        });

        return rect;
      }
      _myTrait_.feGaussianBlur = function(className, attrs) {
        var el = this.shortcutFor("feGaussianBlur", className, attrs);
        return el;
      }
      _myTrait_.feMerge = function(className, attrs) {
        var el = this.shortcutFor("feMerge", className, attrs);
        return el;
      }
      _myTrait_.feMergeNode = function(className, attrs) {
        var el = this.shortcutFor("feMergeNode", className, attrs);
        return el;
      }
      _myTrait_.feOffset = function(className, attrs) {
        var el = this.shortcutFor("feOffset", className, attrs);
        return el;
      }
      _myTrait_.filter = function(className, attrs) {
        var el = this.shortcutFor("filter", className, attrs);
        return el;
      }
      _myTrait_.g = function(className, attrs) {
        var el = this.shortcutFor("g", className, attrs);
        return el;
      }
      _myTrait_.image = function(className, attrs) {
        var el = this.shortcutFor("image", className, attrs);
        return el;
      }
      _myTrait_.line = function(className, attrs) {
        var el = this.shortcutFor("line", className, attrs);
        return el;
      }
      _myTrait_.path = function(className, attrs) {
        var el = this.shortcutFor("path", className, attrs);
        return el;
      }
      _myTrait_.rect = function(className, attrs) {
        var el = this.shortcutFor("rect", className, attrs);
        return el;
      }
      _myTrait_.svg = function(className, attrs, none) {
        var el = this.shortcutFor("svg", className, attrs);
        return el;
      }
      _myTrait_.svg_text = function(className, attrs) {
        var el = this.shortcutFor("text", className, attrs);
        return el;
      }
      _myTrait_.tspan = function(className, attrs) {
        var el = this.shortcutFor("tspan", className, attrs);
        return el;
      }
    }(this));;
    (function(_myTrait_) {
      _myTrait_.isArray = function(someVar) {
        return Object.prototype.toString.call(someVar) === '[object Array]';
      }
      _myTrait_.isFunction = function(fn) {
        return Object.prototype.toString.call(fn) == '[object Function]';
      }
      _myTrait_.isObject = function(obj) {
        return obj === Object(obj);
      }
    }(this));;
    (function(_myTrait_) {
      _myTrait_.bs_accordion = function(options) {
        // Does the things...

        var pg = _e("div").addClass("panel-group"),
          myId = pg.guid();
        pg.q.attr("id", myId);

        // And the accordion panels

        var me = this;

        options.items.forEach(function(item) {

          var contentId = pg.guid();
          item.body_collapse_id = contentId;

          var panel = me.panel(item);
          pg.add(panel);

          var title = panel.component_title();
          if (title) {
            title.clear();
            var a = title.a("", {
              "data-toggle": "collapse",
              "data-parent": "#" + myId,
              "href": "#" + contentId
            });
            a.add(item.title);
          }


        });
        return pg;

        /*
           <div class="panel-group" id="accordion">
             <div class="panel panel-default">
               <div class="panel-heading">
                 <h4 class="panel-title">
                   <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne">
                     Collapsible Group Item #1
                   </a>
                 </h4>
               </div>
               <div id="collapseOne" class="panel-collapse collapse in">
                 <div class="panel-body">
                   Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson ad squid. 3 wolf moon officia aute, non cupidatat skateboard dolor brunch. Food truck quinoa nesciunt laborum eiusmod. Brunch 3 wolf moon tempor, sunt aliqua put a bird on it squid single-origin coffee nulla assumenda shoreditch et. Nihil anim keffiyeh helvetica, craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. Leggings occaecat craft beer farm-to-table, raw denim aesthetic synth nesciunt you probably haven't heard of them accusamus labore sustainable VHS.
                 </div>
               </div>
             </div>
             <div class="panel panel-default">
               <div class="panel-heading">
                 <h4 class="panel-title">
                   <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo">
                     Collapsible Group Item #2
                   </a>
                 </h4>
               </div>
               <div id="collapseTwo" class="panel-collapse collapse">
                 <div class="panel-body">
                   Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson ad squid. 3 wolf moon officia aute, non cupidatat skateboard dolor brunch. Food truck quinoa nesciunt laborum eiusmod. Brunch 3 wolf moon tempor, sunt aliqua put a bird on it squid single-origin coffee nulla assumenda shoreditch et. Nihil anim keffiyeh helvetica, craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. Leggings occaecat craft beer farm-to-table, raw denim aesthetic synth nesciunt you probably haven't heard of them accusamus labore sustainable VHS.
                 </div>
               </div>
             </div>
             <div class="panel panel-default">
               <div class="panel-heading">
                 <h4 class="panel-title">
                   <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree">
                     Collapsible Group Item #3
                   </a>
                 </h4>
               </div>
               <div id="collapseThree" class="panel-collapse collapse">
                 <div class="panel-body">
                   Anim pariatur cliche reprehenderit, enim eiusmod high life accusamus terry richardson ad squid. 3 wolf moon officia aute, non cupidatat skateboard dolor brunch. Food truck quinoa nesciunt laborum eiusmod. Brunch 3 wolf moon tempor, sunt aliqua put a bird on it squid single-origin coffee nulla assumenda shoreditch et. Nihil anim keffiyeh helvetica, craft beer labore wes anderson cred nesciunt sapiente ea proident. Ad vegan excepteur butcher vice lomo. Leggings occaecat craft beer farm-to-table, raw denim aesthetic synth nesciunt you probably haven't heard of them accusamus labore sustainable VHS.
                 </div>
               </div>
             </div>
           </div>
           */
      }
      _myTrait_.bs_breadcrumb = function(options) {
        /*
           {
            content : object,
            items : [
                   { title : "Home", view : obj },
                   { title : "Some", view : obj },
                   { title : "other", view : obj }
               ]
           }
           
           */
        var o = _e("div");
        var bc = o.ol("breadcrumb");

        if (options.items) {
          options.items.forEach(function(item) {
            var aa = bc.li().a().text(item.title);
            aa.on("click", function() {
              if (item.action) item.action();
              if (item.view) {
                if (options.content) {
                  options.content.pushView(item.view);
                }
              }
            })
          });
        }
        return o;

      }
      _myTrait_.bs_button = function(item, options) {
        /*
           <button type="button" class="btn btn-default">Default</button>
           */

        var sz = "";
        if (item.size) {
          if (item.size == "xs") sz = "btn-xs";
          if (item.size == "s") sz = "btn-sm";
          if (item.size == "l") sz = "btn-lg";
          if (item.size == "m") sz = "";
        }
        var aa = _e("button");
        aa.addClass("btn btn-" + (item.type || "default"));
        if (sz) aa.addClass(sz);

        this.bs_setItemContent(item, aa);
        this.bs_setItemAction(item, aa, options);

        this.add(aa);
        return aa;

      }
      _myTrait_.bs_buttonDropdown = function(options) {
        /*var bg = o.div("btn-group");
           var b = bg.button("btn btn-default dropdown-toggle", {"data-toggle":"dropdown", "type":"button"});
           b.span("Action");
           b.span("caret");
           
           var ul = bg.ul("dropdown-menu", {role:"menu"});
           ul.li().a().text("Action");
           ul.li().a().text("Action2");
           ul.li().a().text("Action3").on("click", function() {
               alert("Got action 3"); 
           });
           */

        var bg = _e("div").addClass("btn-group");
        var b = bg.button("btn btn-default dropdown-toggle", {
          "data-toggle": "dropdown",
          "type": "button"
        });
        if (options.title) b.span().text(options.title);
        b.span("caret");



        var ul = bg.ul("dropdown-menu", {
          role: "menu"
        });
        if (options.items) {
          options.items.forEach(function(item) {
            var myLi = ul.li();
            var aa = myLi.a(); // .a().text(item.title);
            if (item.leftBadge) aa.span("badge").text(item.leftBadge);
            if (item.title) aa.span().add(item.title);
            if (item.rightBadge) aa.span("badge").text(item.rightBadge);
            if (item.active) myLi.addClass("active");
            aa.on("click", function() {
              if (item.action) item.action();
              if (item.view) {
                if (options.content) {
                  options.content.pushView(item.view);
                }
              }
            })
          });
        }
        return bg;
      }
      _myTrait_.bs_buttonGroup = function(options) {
        /*
           <div class="btn-group">
             <button type="button" class="btn btn-default">Left</button>
             <button type="button" class="btn btn-default">Middle</button>
             <button type="button" class="btn btn-default">Right</button>
           </div>
           */



        var bc = _e("div").addClass("btn-group"),
          me = this;

        if (options.items) {
          options.items.forEach(function(item) {

            var aa = me.button(item, options);
            bc.add(aa);
          });
        }
        return bc;
      }
      _myTrait_.bs_componentSubitems = function(myLi, item, options) {

        if (item.buttongroup) {
          var o = this.buttonGroup(item.buttongroup);
          myLi.add(o);
        }
      }
      _myTrait_.bs_createButton = function(icon, text, className) {

        if (!className) className = "myButton";
        return _e("button").addClass(className).add(_e("span").addClass("fa fa-" + icon), _e("span").text(text));

      }
      _myTrait_.bs_createDropDown = function(list) {

        var o = _e("div");
        var addNewBtn = _e("button").addClass("buttonStyle").text("Drop Down Text");

        o.addItem(addNewBtn);

        var dropDown = this.dropDownMenu(0, 0);
        o.addItem(dropDown);

        /*
           LIST OF items as
           
           list = [
             { text : "", value : ""},
             { text : "", value : ""},
             { text : "", value : ""},
             
           ]
           */

        var cC = _e("div");
        var content = dropDown.content();

        list.forEach(function(i) {
          var tbl = _e("table").addRow(_e("div").addClass("circlebtn-13").text("<span class='fa fa-user'>"), i.text);
          var d = _e("div").addItem(tbl);
          content.addItem(d);
          d.q.css("font-size", 12);
          d.on("click", function() {
            dropDown.val(i);
            dropDown.hide();
          })
        });

        dropDown.content().addClass("ddMenuStyle");

        dropDown.on("value", function() {
          addNewBtn.text("");
          addNewBtn.clear();
          var tbl = _e("table").addRow(_e("div").addClass("circlebtn-13").text("<span class='fa fa-user'>"), dropDown.val().text);
          tbl.q.css("font-size", 16).css("line-height", 2).css("width", 130);
          addNewBtn.addItem(tbl);
          o.trigger("value", dropDown.val());
        });

        o.val = function() {
          return dropDown.val();
        }

        // Selected item...
        /*
           if(roleName) {
               list.forEach( function(d) {
                   if(d.text==roleName) dropDown.val( d );
               });
           } else {
               dropDown.val( list[0] );    
           }
           */


        addNewBtn.on("click", function() {
          // var pop = popupWindow(10000,0.5,0.5);
          dropDown.show();
        });

        return o;

      }
      _myTrait_.bs_createListItem = function(item) {
        var aa;
        var options = {};

        var etype = options.liElem || "li",
          myLi = _e(etype);
        myLi.addClass(item.itemClass || options.itemClass || "list-group-item"); // .a().text(item.title);

        var aa;

        if (!options.listClass) {
          aa = myLi;
        } else {
          aa = myLi[options.aElem || "a"]();
        }

        if (item.iconImg) {
          aa.img("iconImg", {
            src: item.iconImg
          });
        }

        if (item.leftBadge) aa[options.spanElem || "span"]("badge").text(item.leftBadge);
        if (item.title) aa[options.titleElem || options.spanElem || "span"]("title").add(item.title);

        // then the subs...
        // me.componentSubitems(myLi, item, options);


        if (item.rightBadge) aa[options.spanElem || "span"]("badge").text(item.rightBadge);
        if (item.active) myLi.addClass("active");

        aa.on("click", function() {
          if (item.viewFn) {
            if (!item.view) {
              item.view = item.viewFn();
            }
          }
          if (item.action) item.action()();
          if (item.view) {
            if (options.content) {
              options.content.pushView(item.view);
            }
          }
        });

        return myLi;
      }
      _myTrait_.bs_createSubNavigator = function(headItems, pageConstructors, contentArea) {

        var o = _e("div");
        var _pages = [];
        var i = 0,
          me = this,
          activeNavi;
        pageConstructors.forEach(function(pc) {

          var bind = function(i) {
            if (headItems[i]) {
              headItems[i].addClass("navi-item");
              headItems[i].on("click", function() {

                if (activeNavi) {
                  if (activeNavi == headItems[i]) return;
                  activeNavi.removeClass("activeNavi");
                  headItems[i].addClass("activeNavi");
                  activeNavi = headItems[i];
                } else {
                  headItems[i].addClass("activeNavi");
                  activeNavi = headItems[i];
                }

                if (_pages[i]) {
                  contentArea.pushView(_pages[i]);
                } else {
                  pageConstructors[i]();
                  _pages[i] = contentArea.getCurrentView();
                  // _pages[i]
                }

              });
              o.add(headItems[i]);
            }
          }(i);

          i++;
        });





        return o;
      }
      _myTrait_.bs_dateInputEditable = function(dateStr) {

        var dateObj;

        if (dateStr) {
          dateObj = Date.parse(dateStr);
        } else {
          dateObj = new Date();
        }

        if (!dateObj) dateObj = new Date();

        var holder = _e("div");
        var plainText = _e("div");

        var plainTbl = _e("table");
        var textContainer = _e("div").text(dateStr).addClass("textDisplay");

        var btnSave = createButton("save", "Save");
        var btnCancel = createButton("ban", "Cancel"); // _e("button").addClass("myButton").addItem(  _e("table").addRow( _e("span").addClass("fa fa-ban"), _e("div").addClass("btnText").text("Cancel ") ) );
        var btnEdit = createButton("edit", "Edit", "myButton2"); // _e("button").addClass("myButton").addItem(  _e("table").addRow( _e("span").addClass("fa fa-edit"), _e("div").addClass("btnText").text("Edit ") ) );


        plainTbl.addRow(textContainer, btnEdit); // <span class='fa-edit'>");
        plainText.addItem(plainTbl);


        var bEditMode = false;

        var dateSelect = _e("table");
        var yearVal = _e("select");
        var monthVal = _e("select");
        var dayVal = _e("select");

        var year = (new Date()).getFullYear();
        var m = 1;
        var dayI = 1;

        while (year > 1900) {
          var opt = _e("option").val(year).text(year);
          yearVal.addItem(opt);
          if (dateObj.getFullYear() == year) {
            opt.q.attr("selected", true);
            yearVal.val(year);
          }

          year--;
        }
        var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        while (m <= 12) {
          var opt = _e("option").val(m).text(months[m - 1]);
          monthVal.addItem(opt);
          if (dateObj.getMonth() + 1 == m) {
            opt.q.attr("selected", true);
            monthVal.val(m);
          }
          m++;
        }
        while (dayI <= 31) {
          var opt = _e("option").val(dayI).text(dayI);
          dayVal.addItem(opt);
          if (dateObj.getDate() == dayI) {
            opt.q.attr("selected", true);
            dayVal.val(dayI);
          }
          dayI++;
        }

        yearVal.on("value", function() {
          dateSelect.trigger("value");
        });
        monthVal.on("value", function() {
          dateSelect.trigger("value");
        });
        dayVal.on("value", function() {
          dateSelect.trigger("value");
        });


        dateSelect.addClass("dateSelect");
        dateSelect.addRow(yearVal, monthVal, dayVal, btnSave);

        dateSelect.val = function() {
          return yearVal.val() + "-" + monthVal.val() + "-" + dayVal.val();
        }

        dateSelect.on("value", function() {
          console.log(dateSelect.val());
        });

        dateSelect.hide();

        plainText.on("click", function() {
          bEditMode = true;
          plainText.hide();
          dateSelect.show();
        });

        btnSave.on("click", function() {
          plainText.show();
          dateSelect.hide();
          dateStr = dateSelect.val();
          textContainer.text(dateStr);
          holder.trigger("value");
        })

        btnCancel.on("click", function() {
          plainText.show();
          dateSelect.hide();
        })

        holder.addItem(plainText).addItem(dateSelect);
        holder.val = function() {
          return dateStr;
        }

        return holder;

      }
      _myTrait_.bs_dropdown = function(options) {
        /*var bg = o.div("btn-group");
           var b = bg.button("btn btn-default dropdown-toggle", {"data-toggle":"dropdown", "type":"button"});
           b.span("Action");
           b.span("caret");
           
           var ul = bg.ul("dropdown-menu", {role:"menu"});
           ul.li().a().text("Action");
           ul.li().a().text("Action2");
           ul.li().a().text("Action3").on("click", function() {
               alert("Got action 3"); 
           });
           
             <ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu1">
               <li role="presentation"><a role="menuitem" tabindex="-1" href="#">Action</a></li>
               <li role="presentation"><a role="menuitem" tabindex="-1" href="#">Another action</a></li>
               <li role="presentation"><a role="menuitem" tabindex="-1" href="#">Something else here</a></li>
               <li role="presentation" class="divider"></li>
               <li role="presentation"><a role="menuitem" tabindex="-1" href="#">Separated link</a></li>
             </ul>
             
           
           */

        var ul = _e("ul").addClass("dropdown-menu");
        ul.q.attr("role", "menu");
        if (options.items) {
          options.items.forEach(function(item) {
            var myLi = ul.li("", {
              role: "presentation"
            });
            var aa = myLi.a("", {
              role: "menuitem",
              href: "#",
              tabindex: -1
            }); // .a().text(item.title);
            if (item.leftBadge) aa.span("badge").text(item.leftBadge);
            if (item.title) aa.span().add(item.title);
            if (item.rightBadge) aa.span("badge").text(item.rightBadge);
            if (item.active) myLi.addClass("active");
            aa.on("click", function() {
              if (item.action) item.action();
              if (item.view) {
                if (options.content) {
                  options.content.pushView(item.view);
                }
              }
            })
          });
        }
        return ul;

      }
      _myTrait_.bs_dropDownMenu = function(dx, dy) {
        var o = _e("div");
        var content = _e("div");

        var _bVisible = false;

        if (!dx) dx = 0;
        if (!dy) dy = 0;
        o.q.css("position", "relative");
        content.q.css("position", "absolute").css("left", dx).css("top", dy);
        content.hide();

        o.addItem(content);

        o.show = function() {
          if (_bVisible) {
            o.hide();
            return;
          }
          $(content._dom).slideDown();
          _bVisible = true;
        }

        var _myVal;
        o.val = function(v) {
          if (typeof(v) != "undefined") {
            _myVal = v;
            o.trigger("value");
          }
          return _myVal;
        }

        o.hide = function() {
          $(content._dom).slideUp();
          _bVisible = false;
        }

        o.content = function() {
          return content;
        }


        o.x = function(x) {
          dx = x;
          content.q.css("left", x);
          return o;
        }

        o.y = function(y) {
          dy = y;
          content.q.css("top", y);
          return o;
        }



        return o;

      }
      _myTrait_.bs_fileupload = function(options) {
        /*
           <form id="my_form" name="form" action="upload.php" method="POST" 
           enctype="multipart/form-data" >
           
           <div id="main">
           <input name="my_files" id="my_file" size="27" type="file" />
           <input type="button" name="action" value="Upload" onclick="redirect()"/>
           <iframe id='my_iframe' name='my_iframe' src="">
           </iframe>
           </div>
           
           </form>
           */

        var o = _e();

        var form = o.form("", {
          "action": options.target,
          "enctype": "multipart/form-data",
          "method": "POST",
          "name": o.guid()
        });

        var maxCnt = options.maxCnt || 20;

        var onComplete = function(v) {
          if (options.onComplete) {
            options.onComplete(v);
          }
        };

        var chStr = "complete" + ((new Date()).getTime());
        window[chStr] = onComplete;
        form.input("", {
          type: "hidden",
          value: chStr,
          name: "onComplete"
        });
        form.label("control-label").text(_t(options.title || "Valitse tiedostot"));

        if (options.vars) {
          for (var n in options.vars) {
            if (options.vars.hasOwnProperty(n)) {
              form.input("", {
                type: "hidden",
                value: options.vars[n],
                name: n
              });
            }
          }
        }
        var uplFields = form.div("form-group");

        var maxFileCnt = options.maxFileCnt || 5,
          fileCnt = 0;

        var createUploadField = function() {
          if (fileCnt >= maxFileCnt) return;
          // <label for="exampleInputFile">File input</label>
          var inp = uplFields.input("", {
            type: "file",
            name: "file_" + fileCnt
          });
          inp.on("value", function() {
            if (options.autoUpload) {
              o.uploadFiles();
            } else {
              if (fileCnt < maxCnt) createUploadField();
            }
          });

          fileCnt++;
        }

        createUploadField();
        var iFrame = _e("iframe");
        var frame_id = o.guid();
        iFrame.q.attr("id", frame_id);
        iFrame.q.attr("name", frame_id);
        iFrame.absolute().x(-4000).y(-4000);

        o.add(iFrame);



        o.uploadFiles = function(vars) {
          if (vars) {
            for (var n in vars) {
              if (vars.hasOwnProperty(n)) {
                form.input("", {
                  type: "hidden",
                  value: vars[n],
                  name: n
                });
              }
            }
          }
          form._dom.target = frame_id; //'my_iframe' is the name of the iframe
          form._dom.submit();
          uplFields.clear();
          fileCnt = 0;
          createUploadField();

        }

        if (options.getUploader) {
          options.getUploader(o.uploadFiles);
        }

        this.add(o);

        return o;


      }
      _myTrait_.bs_form = function(dataObject, fieldFormat) {
        /*
                    <form role="form">
                      <div class="form-group">
                        <label for="exampleInputEmail1">Email address</label>
                        <input type="email" class="form-control" id="exampleInputEmail1" placeholder="Enter email">
                      </div>
                      <div class="form-group">
                        <label for="exampleInputPassword1">Password</label>
                        <input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password">
                      </div>
                      <div class="form-group">
                        <label for="exampleInputFile">File input</label>
                        <input type="file" id="exampleInputFile">
                        <p class="help-block">Example block-level help text here.</p>
                      </div>
                      <div class="checkbox">
                        <label>
                          <input type="checkbox"> Check me out
                        </label>
                      </div>
                      <button type="submit" class="btn btn-default">Submit</button>
                    </form>
                    */
        var tbl = _e().div('', {
            role: 'form'
          }),
          me = this;
        var buttons = _e('div').addClass('btn-group');
        var errors = _e('div').addClass('textDisplayHead').addClass('errorDisplay').text(' ');
        tbl.add(errors);
        fieldFormat.fields.forEach(function(field) {
          var v = dataObject[field.name];
          var realName = field.name,
            triggerName = realName;
          var input, errorField = tbl.div('inputError');
          // detect the type of the field
          var typeName = 'str';
          var parts = field.name.split(':');
          if (parts.length == 2) {
            typeName = parts[1];
            realName = parts[0];
            triggerName = realName;
          } else {
            if (field.name.substr(0, 3) == 'btn') {
              typeName = 'btn';
              triggerName = field.name.substr(3);
            }
            if (!typeName && field.name.substr(0, 1) == 'b')
              typeName = 'bool';
            if (!typeName && field.name.substr(0, 1) == 'i')
              typeName = 'int';
            if (!typeName && field.name.substr(0, 2) == 'pe')
              typeName = 'pw';
            if (!typeName && field.name.substr(0, 4) == 'date')
              typeName = 'date';
            if (field.type == 'text')
              typeName = 'text';

          }

          if (typeName == "file") {
            if (field.target) {
              var upl = me.bs_fileupload({
                target: field.target,
                title: field.text,
                vars: field.vars || {},
                getUploader: field.getUploader
              });
              tbl.add(upl);
            }
          }

          if (typeName == "custom") {
            if (field.content) tbl.add(field.content);
            return;
          }

          var conf = {
            type: 'text',
            bind: {
              data: dataObject,
              name: realName
            },
            text: field.text,
            joyride: field.joyride
          };
          // tbl
          if (typeName == 'str') {
            conf.type = 'text';
            tbl.bs_input(conf);
          }
          /*
                          <div class="checkbox">
                            <label>
                              <input type="checkbox"> Check me out
                            </label>
                          </div>
                        */
          if (typeName == 'bool') {
            input = _e('checkbox');
            input.checked(parseInt(v));
            input.bind(dataObject, realName);
            var cbd = tbl.div('checkbox');
            cbd.label().add(input).span().text(field.text);
          }
          /*
                          <div class="form-group">
                            <label for="exampleInputPassword1">Password</label>
                            <input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password">
                          </div>
                        */
          if (typeName == 'password') {
            conf.type = 'password';
            tbl.bs_input(conf);
          }

          if (typeName == 'text') {
            conf.rows = field.rows || 6;
            conf.type = 'textarea';
            tbl.bs_textarea(conf);
          }

          if (typeName == 'date') {
            conf.type = 'date';
            tbl.bs_input(conf);
          }
          if (typeName == 'time') {
            conf.type = 'time';
            tbl.bs_input(conf);
          }

          if (typeName == "btn") {


            buttons.bs_button({
              title: field.text,
              type: field.type || "primary"
            }).on("click", function() {
              tbl.trigger(triggerName);
              return false;
            })
          }
          /*
                                if(typeName=="btn") {
                            
                                    input = me.createButton( field.name.substr(3), field.text, field.className );
                                    buttons.addItem( input );
                                    buttons.addItem(_e("span").text(" "));
                            
                                    input.on("click", function() {
                                        o.trigger(triggerName);
                                    })
                                } 
                                if(typeName=="bool") {
                                    input = _e("checkbox");
                                    input.checked( parseInt( v ) );
                                    input.bind( dataObject, realName);
                                    
                                    var hold = tbl.div("checkBoxHolder").add(  input );
                                    var head = _e("div").addClass("checkBoxHead").text(field.text);
                                    hold.add( head );
                                }
                            
                                if(typeName=="int") {
                                    input = _e("input").addClass("textDisplay");
                                    var head = _e("div").addClass("textDisplayHead").text(field.text);
                                    tbl.add( head , input );
                                    input.bind( dataObject, realName);
                            
                                }
                            
                                if(typeName=="str") {
                                    input = _e("input").addClass("textDisplay");
                                    var head = _e("div").addClass("textDisplayHead").text(field.text);
                                    tbl.add( head , input );
                                    input.bind( dataObject, realName );
                                }
                                
                                if(typeName=="text") {
                                     input = _e("textarea").addClass("textArea");
                                    // input.q.css("width",400);
                                    var head = _e("div").addClass("textDisplayHead").text(field.text);
                                    tbl.add( head , input );
                                    input.bind( dataObject, realName );         
                                }
                            
                            
                                if(typeName=="password") {
                                    input = _e("input").addClass("textDisplay");
                                    // input.q.css("width",100);
                                    input.q.attr("type", "password");
                                    input.bind( dataObject, realName );
                                    var head = _e("div").addClass("textDisplayHead").text(field.text);
                                    tbl.add( head , input );
                                }
                            
                            
                                if(typeName=="date") {
                                    input = me.dateInputEditable( v );
                                    var head = _e("div").addClass("textDisplayHead").text(field.text);
                                    tbl.add( head, input );
                                }
                                
                                if(field.validator) {
                                    
                                    input.on("value", function() {
                                        var s;
                                        if(s = field.validator(input)) {
                                            errorField.add(s);
                                            errorField.addClass("errorActive");
                                        } else {
                                            errorField.removeClass("errorActive");
                                        }
                                    });
                                    
                                }
                                */
        });
        tbl.add(buttons);
        this.add(tbl);
        return tbl;
      }
      _myTrait_.bs_formAsDivs = function(dataObject, fieldFormat) {

        var o = _e("div"),
          me = this;
        o.addClass("formarea");

        var tbl = _e("div");
        tbl.addClass("formTable");

        var buttons = _e("div").addClass("formButtons");
        var errors = _e("div").addClass("textDisplayHead").addClass("errorDisplay").text(" ");

        tbl.add(errors);


        o.error = function(txt) {
          errors.clear();
          errors.addItem(txt);
          return o;
        }


        fieldFormat.fields.forEach(function(field) {


          var v = dataObject[field.name];
          var realName = field.name,
            triggerName = realName;
          var input,
            errorField = tbl.div("inputError");

          // detect the type of the field

          var typeName = "str";

          var parts = field.name.split(":");
          if (parts.length == 2) {
            typeName = parts[1];
            realName = parts[0];
            triggerName = realName;
          } else {
            if (field.name.substr(0, 3) == "btn") {
              typeName = "btn";
              triggerName = field.name.substr(3);
            }
            if (!typeName && field.name.substr(0, 1) == "b") typeName = "bol";
            if (!typeName && field.name.substr(0, 1) == "i") typeName = "int";
            if (!typeName && field.name.substr(0, 2) == "pe") typeName = "pw";
            if (!typeName && field.name.substr(0, 4) == "date") typeName = "date";
            if (field.type == "text") typeName = "text";
          }


          if (typeName == "btn") {

            input = me.createButton(field.name.substr(3), field.text, field.className);
            buttons.addItem(input);
            buttons.addItem(_e("span").text(" "));

            input.on("click", function() {
              o.trigger(triggerName);
            })
          }
          if (typeName == "bool") {
            input = _e("checkbox");
            input.checked(parseInt(v));
            input.bind(dataObject, realName);

            var hold = tbl.div("checkBoxHolder").add(input);
            var head = _e("div").addClass("checkBoxHead").text(field.text);
            hold.add(head);
          }

          if (typeName == "int") {
            input = _e("input").addClass("textDisplay");
            var head = _e("div").addClass("textDisplayHead").text(field.text);
            tbl.add(head, input);
            input.bind(dataObject, realName);

          }

          if (typeName == "str") {
            input = _e("input").addClass("textDisplay");
            var head = _e("div").addClass("textDisplayHead").text(field.text);
            tbl.add(head, input);
            input.bind(dataObject, realName);
          }

          if (typeName == "text") {
            input = _e("textarea").addClass("textArea");
            // input.q.css("width",400);
            var head = _e("div").addClass("textDisplayHead").text(field.text);
            tbl.add(head, input);
            input.bind(dataObject, realName);
          }


          if (typeName == "password") {
            input = _e("input").addClass("textDisplay");
            // input.q.css("width",100);
            input.q.attr("type", "password");
            input.bind(dataObject, realName);
            var head = _e("div").addClass("textDisplayHead").text(field.text);
            tbl.add(head, input);
          }


          if (typeName == "date") {
            input = me.dateInputEditable(v);
            var head = _e("div").addClass("textDisplayHead").text(field.text);
            tbl.add(head, input);
          }

          if (field.validator) {

            input.on("value", function() {
              var s;
              if (s = field.validator(input)) {
                errorField.add(s);
                errorField.addClass("errorActive");
              } else {
                errorField.removeClass("errorActive");
              }
            });

          }


        })

        tbl.add(buttons);

        o.addItem(tbl);

        return o;

      }
      _myTrait_.bs_genericTabSelector = function(tabNames, tabItems) {
        var o = _e("div");

        var tabCont = o.div("tabContainer");
        var leftDiv = tabCont.div("tabLeft"),
          rightDiv = tabCont.div("tabRight");

        // The items...

        var activeIndex = 0,
          me = this,
          activeItem = null,
          activeNameDiv;

        var ii = 0;
        tabNames.forEach(function(i) {
          var nD = leftDiv.div("tabName").add(i);
          nD.on("click", function(o) {
            if (activeIndex != o.__index) {
              tabItems[activeIndex].hide();
              tabItems[o.__index].show();
              var oldNd = tabNames[activeIndex];
              activeNameDiv.removeClass("tabName")
                .addClass("tabItemNotActive");
              activeItem = tabItems[o.__index];
              activeIndex = o.__index;
              nD.removeClass("tabItemNotActive")
                .addClass("tabName");
              activeNameDiv = nD;
            }
          });
          nD.__index = ii;
          if (ii > 0) {
            nD.removeClass("tabName");
            nD.addClass("tabItemNotActive");
          } else {
            activeNameDiv = nD;
            nD.removeClass("tabItemNotActive");
          }
          ii++;
        });

        var ii = 0;
        tabItems.forEach(function(item) {
          if (ii > 0) {
            item.hide();
          } else {
            item.show();
            activeItem = item;
          }
          rightDiv.add(item);
          ii++;
        });


        return o;
      }
      _myTrait_.bs_infoAsTable = function(dataObject, fieldFormat) {

        var o = _e("div"),
          me = this;
        o.addClass("formarea");

        var tbl = _e("table");
        tbl.addClass("formTable");

        var buttons = _e("div");
        var errors = _e("div").addClass("textDisplayHead").addClass("errorDisplay").text(" ");

        tbl.addRow("", errors);


        o.error = function(txt) {
          errors.clear();
          errors.addItem(txt);
          return o;
        }


        fieldFormat.fields.forEach(function(field) {


          var v = dataObject[field.name];
          var input;


          if (field.name.substr(0, 3) == "btn") {

          } else {
            if (field.name.substr(0, 1) == "b") {
              input = _e("div").text("X");
              tbl.addRow("", _e("table").addRow(input, field.text));

            }
          }

          if (field.name.substr(0, 1) == "i") {
            input = _e("div").addClass("textDisplay");
            var head = _e("div").addClass("textDisplayHead").text(field.text);
            tbl.addRow(head, input);
            input.bind(dataObject, field.name);
          }

          if (field.name.substr(0, 3) == "str") {
            if (field.type && field.type == "text") {
              input = _e("div").addClass("textArea");
              // input.q.css("width",400);
              var head = _e("div").addClass("textDisplayHead").text(field.text);
              tbl.addRow(head, input);
              input.bind(dataObject, field.name);
            } else {
              input = _e("duv").addClass("textDisplay");
              var head = _e("div").addClass("textDisplayHead").text(field.text);
              tbl.addRow(head, input);
              input.bind(dataObject, field.name);
            }
          }

          if (field.name.substr(0, 4) == "date") {
            // Not implemented
          }


        })

        tbl.addRow("", buttons);

        o.addItem(tbl);

        return o;

      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(file) {

      });
      _myTrait_.bs_input = function(options) {
        /*
                    <div class="form-group has-success has-feedback">
                      <label class="control-label" for="inputSuccess2">Input with success</label>
                      <input type="text" class="form-control" id="inputSuccess2">
                      <span class="glyphicon glyphicon-ok form-control-feedback"></span>
                    </div>
                    *
                    
                    /*
                    { type:"text", bind : { data : o, name : "" }, text : "" }
                    */
        var g = _e('div').addClass('form-group');
        if (options.feedback) {
          g.addClass('has-success has-feedback');
        }
        var id = g.guid();
        if (options.text) {
          g.label('control-label', {
            'for': id
          }).text(options.text);
        }


        var inp = g.input('form-control', {
          id: id,
          type: options.type || 'text'
        });

        if (options.joyride) {
          inp._joyride = options.joyride;
        }

        if (options.bind) {
          inp.bind(options.bind.data, options.bind.name);
        }
        var feedback, fbClass = 'glyphicon-ok';
        if (options.feedback) {
          feedback = g.span('glyphicon form-control-feedback');
          feedback.hide();
        }
        g.setFeedback = function(state) {
          feedback.removeClass(fbClass);
          if (state == 'ok')
            fbClass = 'glyphicon-ok';
          if (state == 'error')
            fbClass = 'glyphicon-remove';
          if (state == 'warning')
            fbClass = 'glyphicon-warning-sign';
          feedback.addClass(fbClass);
        };
        this.add(g);
        return g;
      }
      _myTrait_.bs_joyride = function(fromItem) {

        var places = [];

        var collectShow = function(item) {
          if (item._joyride) places.push(item);
          item.forChildren(collectShow);
        }
        collectShow(fromItem);

        var me = this,
          joyPanel, index = 0;

        joyPanel = me.popover({
          title: "Otsikko",
          content: "Sislt",
          type: "info",
          position: "right",
          footer: me.pager({
            items: [{
              title: "Edellinen",
              action: function() {
                if (index == 0) index = places.length;
                index--;
                moveToIndex(index);
              }
            }, {
              title: "Seuraava",
              action: function() {
                index++;
                if (index == places.length) index = 0;
                moveToIndex(index);
              }
            }]
          })
        }).absolute();

        var body = _e("body", document.body);
        body.add(joyPanel);

        var lastElem;
        var moveToIndex = function(i) {

          joyPanel._dom.style.display = "block";

          if (lastElem) lastElem.removeClass("joyride-info");

          var elem = places[i];
          elem.addClass("joyride-info");
          var off = elem.offset();
          var box = joyPanel.box(),
            contBox = elem.box();
          joyPanel.x(off.left + 200).y(off.top - box.height / 2 + contBox.height / 2);

          joyPanel.component_title(elem._joyride.title);
          joyPanel.component_content(elem._joyride.content);

        }

        if (places.length) {
          moveToIndex(0);
        }

        // and then you close it and so on...
      }
      _myTrait_.bs_jumbotron = function(options) {
        var o = _e("div");
        var jumbo = o.div("jumbotron");

        if (options.content) {
          jumbo.add(options.content);
        }

        return o;
      }
      _myTrait_.bs_listgroup = function(options) {
        /*
           {
            content : object,
            items : [
                   { title : "Home", leftBadge : 14 },
                   { title : "Some", rightBadge : 0 },
                   { title : "other", view : obj }
               ]
           }
           
           */
        var me = this;
        var bc = _e(options.ulElem || "ul").addClass(options.listClass || "list-group");

        if (options.className) bc.addClass(options.className);

        if (options.items) {
          options.items.forEach(function(item) {
            var aa;
            if (item.dropdown && options.listClass) {

              /*
                          <li class="dropdown">
               <a class="dropdown-toggle" data-toggle="dropdown" href="#">
                 Dropdown <span class="caret"></span>
               </a>
               <ul class="dropdown-menu" role="menu">
                 ...
               </ul>
             </li>
                        */
              var myLi = bc.li("dropdown"); // .a().text(item.title);
              var aa = myLi.a("dropdown-toggle", {
                "data-toggle": "dropdown",
                "href": "#"
              });

              setTimeout(function() {
                $(aa._dom).dropdown();
              }, 50);

            } else {
              var etype = options.liElem || "li";
              var myLi = bc[etype](item.itemClass || options.itemClass || "list-group-item"); // .a().text(item.title);
              var aa;

              if (!options.listClass) {
                aa = myLi;
              } else {
                aa = myLi[options.aElem || "a"]();
              }
            }
            /*
                    if(item.leftBadge) aa.span("badge").text(item.leftBadge); 
                    if(item.title) aa.span().add(item.title);
                    if(item.rightBadge) aa.span("badge").text(item.rightBadge); 
                    
                    if(item.active) myLi.addClass("active");
                    
                    if(item.dropdown) {
                        aa.span("caret")
                        myLi.add(item.dropdown);
                    }
                    
                    aa.on("click", function() {
                        if(item.action) item.action();
                        if(item.view) {
                            if(options.content) {
                                options.content.pushView(item.view);
                            }
                        }
                    })
           */

            if (item.iconImg) {
              aa.img("iconImg", {
                src: item.iconImg
              });
            }

            if (item.leftBadge) aa[options.spanElem || "span"]("badge").text(item.leftBadge);
            if (item.title) aa[options.titleElem || options.spanElem || "span"]("title").add(item.title);

            // then the subs...
            me.componentSubitems(myLi, item, options);


            if (item.rightBadge) aa[options.spanElem || "span"]("badge").text(item.rightBadge);
            if (item.active) myLi.addClass("active");

            if (item.dropdown && options.listClass) {
              aa[options.spanElem || "span"]("caret")
              myLi.add(item.dropdown);
            }

            aa.on("click", function() {
              if (item.viewFn) {
                if (!item.view) {
                  item.view = item.viewFn();
                }
              }
              if (item.action) item.action();
              if (item.view) {
                if (options.content) {
                  options.content.pushView(item.view);
                }
              }
            })
          });
        }
        return bc;
      }
      _myTrait_.bs_listgrouptest = function(options) {
        /*
           {
            content : object,
            items : [
                   { title : "Home", leftBadge : 14 },
                   { title : "Some", rightBadge : 0 },
                   { title : "other", view : obj }
               ]
           }
           
           */
        var me = this;
        var bc = _e(options.ulElem || "ul").addClass(options.listClass || "list-group");

        if (options.className) bc.addClass(options.className);

        var createItem = function(item) {
          var aa;

          var etype = options.liElem || "li";
          var myLi = bc[etype](item.itemClass || options.itemClass || "list-group-item"); // .a().text(item.title);
          var aa;

          if (!options.listClass) {
            aa = myLi;
          } else {
            aa = myLi[options.aElem || "a"]();
          }

          if (item.iconImg) {
            aa.img("iconImg", {
              src: item.iconImg
            });
          }

          if (item.leftBadge) aa[options.spanElem || "span"]("badge").text(item.leftBadge);
          if (item.title) aa[options.titleElem || options.spanElem || "span"]("title").add(item.title);

          // then the subs...
          me.componentSubitems(myLi, item, options);


          if (item.rightBadge) aa[options.spanElem || "span"]("badge").text(item.rightBadge);
          if (item.active) myLi.addClass("active");

          aa.on("click", function() {
            if (item.viewFn) {
              if (!item.view) {
                item.view = item.viewFn();
              }
            }
            if (item.action) item.action()();
            if (item.view) {
              if (options.content) {
                options.content.pushView(item.view);
              }
            }
          });
        }

        if (options.items) {
          options.items.forEach(createItem);
          options.items.on("insert", function(o, i) {
            createItem(options.items.item(i));
          })
        }
        return bc;
      }
      _myTrait_.bs_maincontent = function(options) {
        /*
           <div class="panel panel-default">
             <div class="panel-heading">
               <h3 class="panel-title">Panel title</h3>
             </div>
             <div class="panel-body">
               Panel content
             </div>
           </div>
           */

        var o = _e("div").addClass("page page-" + (options.type || "default"));
        var head = o.div("page-heading"),
          body,
          footer,
          title;

        // just in case the panel content is collapsible...
        if (options.body_collapse_id) {
          /*
              <div id="collapseOne" class="panel-collapse collapse in">
                 <div class="panel-body">    
               */
          var bodyWrapper = o.div("panel-collapse collapse", {
            id: options.body_collapse_id
          });
          body = bodyWrapper.div("panel-body");
          footer = bodyWrapper.div("panel-footer");
        } else {
          body = o.div("page-body");
          footer = o.div("page-footer");
        }


        if (options.heading) {
          head.add(options.heading);
        }

        if (options.title) {
          title = head.h1("page-title");
          title.add(options.title);
        }

        if (options.content) {
          body.add(options.content);
        }
        if (options.footer) {
          footer.add(options.footer);
        }

        this.setContentFunctions(o, {
          heading: head,
          title: title,
          content: body,
          footer: footer
        });



        return o;
      }
      _myTrait_.bs_navbar = function(options) {

        console.log("Navbar test...");

        var nav = _e("nav").addClass("navbar navbar-default");
        var cont = nav.div("container-fluid"),
          myId = cont.guid();

        var head = cont.div("navbar-header");
        var b = head.button("navbar-toggle collapsed", {
          "type": "button",
          "data-toggle": "collapse",
          "data-target": "#" + myId
        });

        console.log("Navbar test...2");

        b.span("sr-only").text("Avaa navigaatio");
        b.span("icon-bar");
        b.span("icon-bar");
        b.span("icon-bar");

        if (options.leftIcon) {
          head.a("navbar-brand", {
            href: "#"
          }).add(options.leftIcon);
        }

        console.log("Navbar test...3");
        var main = cont.div("collapse navbar-collapse", {
          id: myId
        });

        console.log("Navbar test...4");

        if (options.itemsLeft) {

          var g = this.listgroup({
            listClass: "nav navbar-nav",
            itemClass: "item",
            items: options.itemsLeft,
            content: options.content
          });
          main.add(g);

        }

        return nav;




        /*
           <nav class="navbar navbar-default" role="navigation">
             <div class="container-fluid">
               <!-- Brand and toggle get grouped for better mobile display -->
               <div class="navbar-header">
                 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" 
                 data-target="#bs-example-navbar-collapse-1">
                   <span class="sr-only">Toggle navigation</span>
                   <span class="icon-bar"></span>
                   <span class="icon-bar"></span>
                   <span class="icon-bar"></span>
                 </button>
                 <a class="navbar-brand" href="#">Brand</a>
               </div>
           
               <!-- Collect the nav links, forms, and other content for toggling -->
               <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                 <ul class="nav navbar-nav">
                   <li class="active"><a href="#">Link</a></li>
                   <li><a href="#">Link</a></li>
                   <li class="dropdown">
                     <a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <span class="caret"></span></a>
                     <ul class="dropdown-menu" role="menu">
                       <li><a href="#">Action</a></li>
                       <li><a href="#">Another action</a></li>
                       <li><a href="#">Something else here</a></li>
                       <li class="divider"></li>
                       <li><a href="#">Separated link</a></li>
                       <li class="divider"></li>
                       <li><a href="#">One more separated link</a></li>
                     </ul>
                   </li>
                 </ul>
                 <form class="navbar-form navbar-left" role="search">
                   <div class="form-group">
                     <input type="text" class="form-control" placeholder="Search">
                   </div>
                   <button type="submit" class="btn btn-default">Submit</button>
                 </form>
                 <ul class="nav navbar-nav navbar-right">
                   <li><a href="#">Link</a></li>
                   <li class="dropdown">
                     <a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <span class="caret"></span></a>
                     <ul class="dropdown-menu" role="menu">
                       <li><a href="#">Action</a></li>
                       <li><a href="#">Another action</a></li>
                       <li><a href="#">Something else here</a></li>
                       <li class="divider"></li>
                       <li><a href="#">Separated link</a></li>
                     </ul>
                   </li>
                 </ul>
               </div><!-- /.navbar-collapse -->
             </div><!-- /.container-fluid -->
           </nav>
           */
      }
      _myTrait_.bs_navtabs = function(options) {
        /*
           <ul class="nav nav-tabs" role="tablist">
             <li class="active"><a href="#">Home</a></li>
             <li><a href="#">Profile</a></li>
             <li><a href="#">Messages</a></li>
           </ul>
           */


        var bc = _e("ul").addClass("nav nav-tabs");
        bc.q.attr("role", "tablist");
        if (options.items) {
          var lastActive;
          options.items.forEach(function(item) {
            var myLi = bc.li();
            if (item.active) {
              lastActive = myLi;
              myLi.addClass("active");
            }
            var aa = myLi.a(); // .a().text(item.title);
            if (item.title) aa.add(item.title);
            aa.on("click", function() {
              if (lastActive) {
                lastActive.removeClass("active");
              }
              myLi.addClass("active");
              lastActive = myLi;
              if (item.action) item.action();

              if (!item.view && item.viewFn) {
                item.view = item.viewFn(item);
              }

              if (item.view) {
                if (options.content) {
                  options.content.pushView(item.view);
                }
              }
            })
            if (item.active) {
              aa.trigger("click");
            }
          });
        }
        this.add(bc);
        return bc;
      }
      _myTrait_.bs_pager = function(options) {
        /*
           <ul class="pager">
             <li><a href="#">Previous</a></li>
             <li><a href="#">Next</a></li>
           </ul>
           */

        var bc = _e("ul").addClass("pager");
        if (options.items) {
          options.items.forEach(function(item) {
            var myLi = bc.li();
            if (item.active) myLi.addClass("active");
            var aa = myLi.a(); // .a().text(item.title);
            if (item.title) aa.text(item.title);
            aa.on("click", function() {
              if (item.action) item.action();
              if (item.view) {
                if (options.content) {
                  options.content.pushView(item.view);
                }
              }
            })
          });
        }
        return bc;

      }
      _myTrait_.bs_pagetitle = function(text) {

        /*
           <div class="page-header">
             <h1>Example page header <small>Subtext for header</small></h1>
           </div>
           */
        var c = _e("div").addClass("page-header");
        var h = c.h1();
        h.text(text);
        return c;
      }
      _myTrait_.bs_pagination = function(options) {
        /*
           <ul class="pagination">
             <li><a href="#">&laquo;</a></li>
             <li><a href="#">1</a></li>
             <li><a href="#">2</a></li>
             <li><a href="#">3</a></li>
             <li><a href="#">4</a></li>
             <li><a href="#">5</a></li>
             <li><a href="#">&raquo;</a></li>
           </ul>
           */

        var bc = _e("ul").addClass("pagination");
        var left = bc.li().a().text("&laquo;");
        if (options.items) {
          options.items.forEach(function(item) {
            var myLi = bc.li(); // .a().text(item.title);
            if (item.active) myLi.addClass("active");
            var aa = myLi.a();
            if (item.title) aa.text(item.title);
            aa.on("click", function() {
              if (item.action) item.action();
              if (item.view) {
                if (options.content) {
                  options.content.pushView(item.view);
                }
              }
            })
          });
        }
        var right = bc.li().a().text("&raquo;");
        return bc;

      }
      _myTrait_.bs_panel = function(options) {
        /*
           <div class="panel panel-default">
             <div class="panel-heading">
               <h3 class="panel-title">Panel title</h3>
             </div>
             <div class="panel-body">
               Panel content
             </div>
           </div>
           */

        var o = _e("div").addClass("panel panel-" + (options.type || "default"));
        var head = o.div("panel-heading"),
          body,
          footer,
          title;

        // just in case the panel content is collapsible...
        if (options.body_collapse_id) {
          /*
              <div id="collapseOne" class="panel-collapse collapse in">
                 <div class="panel-body">    
               */
          var bodyWrapper = o.div("panel-collapse collapse", {
            id: options.body_collapse_id
          });
          body = bodyWrapper.div("panel-body");
          footer = bodyWrapper.div("panel-footer");
        } else {
          body = o.div("panel-body");
          footer = o.div("panel-footer");
        }


        if (options.heading) {
          head.add(options.heading);
        }

        if (options.title) {
          title = head.h3("panel-title");
          title.add(options.title);
        }

        if (options.content) {
          body.add(options.content);
        }
        if (options.footer) {
          footer.add(options.footer);
        }

        this.setContentFunctions(o, {
          heading: head,
          title: title,
          content: body,
          footer: footer
        });



        return o;
      }
      _myTrait_.bs_pills = function(options) {
        /*
           <ul class="nav nav-pills">
             <li class="active"><a href="#">Home</a></li>
             <li><a href="#">Profile</a></li>
             <li><a href="#">Messages</a></li>
           </ul>
           */

        var bc = _e("ul").addClass("nav nav-pills");

        if (options.items) {
          options.items.forEach(function(item) {
            var className = "";
            if (item.dropdown) {

              /*
                          <li class="dropdown">
               <a class="dropdown-toggle" data-toggle="dropdown" href="#">
                 Dropdown <span class="caret"></span>
               </a>
               <ul class="dropdown-menu" role="menu">
                 ...
               </ul>
             </li>
                        */
              var myLi = bc.li("dropdown"); // .a().text(item.title);
              var aa = myLi.a("dropdown-toggle", {
                "data-toggle": "dropdown",
                "href": "#"
              });

              setTimeout(function() {
                $(aa._dom).dropdown();
              }, 50);

            } else {
              var myLi = bc.li(); // .a().text(item.title);
              var aa = myLi.a();
            }

            if (item.leftBadge) aa.span("badge").text(item.leftBadge);
            if (item.title) aa.span().add(item.title);
            if (item.rightBadge) aa.span("badge").text(item.rightBadge);

            if (item.active) myLi.addClass("active");

            if (item.dropdown) {
              aa.span("caret")
              myLi.add(item.dropdown);
            }

            aa.on("click", function() {
              if (item.action) item.action();
              if (item.view) {
                if (options.content) {
                  options.content.pushView(item.view);
                }
              }
            })
          });
        }
        return bc;
      }
      _myTrait_.bs_popover = function(options) {
        /*<div class="popover right">
                 <div class="arrow"></div>
                 <h3 class="popover-title">Popover right</h3>
                 <div class="popover-content">
                   <p>Sed posuere consectetur est at lobortis. Aenean eu leo quam. Pellentesque ornare sem lacinia quam venenatis vestibulum.</p>
                 </div>
               </div>
           */

        var o = _e("div").addClass("popover " + (options.position || "left"));

        var arrow = o.div("arrow");

        var head = o.div("popover-title"),
          body = o.div("popover-content"),
          footer = o.div("panel-footer"),
          title;


        if (options.title) {
          head.text(options.title);
        }

        if (options.content) {
          body.add(options.content);
        }
        if (options.footer) {
          footer.add(options.footer);
        }

        this.setContentFunctions(o, {
          title: head,
          content: body,
          footer: footer
        });



        return o;
      }
      _myTrait_.bs_progressBar = function(options) {
        /*
           {
               value
               onChange
               toText : function(v) {
               
               }
               
           }
           */

        options.value = options.value || 0;

        var prog = o.div("progress");
        bb = prog.div("progress-bar", {
          "role": "progressbar",
          "aria-valuenow": options.value || 0,
          "aria-valuemin": options.valuemin || 0,
          "aria-valuemax": options.valuemax || 100
        }).width(options.value + "%").text(options.value);

        if (options.toText) {
          options.toText(options.value);
        }
        bb.setProgress = function(v) {
          options.value = v;
          bb.width(v + "%");
          bb.text(v + "%");
        }

        bb.setProgress(options.value);


        return prog;
      }
      _myTrait_.bs_row = function(options) {

        if ((Object.prototype.toString.call(options) === '[object Array]')) {
          return;
        }
        var items = options.items;
        var itemCnt = items.length;
        if (itemCnt == 0) return _e();
        // .col-md-1

        if (options.widths) {

          var cont = _e("div").addClass("row"),
            wi = 0;
          options.items.forEach(function(ii) {
            // <div class="col-md-1">.col-md-1</div>
            var row_w = options.widths[wi++] + "",
              row_int = parseInt(row_w.substring(0, row_w.length));

            var partSize = Math.floor(12 * row_int / 100);


            var place = cont.div("col col-md-" + partSize);
            place.add(ii);
          });
          this.add(cont);
          return cont;

        }

        if (itemCnt > (options.rowSize || 12)) {
          var i = 0,
            list;
          var cont = _e("div").addClass("container");
          while (list = items.slice(i, i + (options.rowSize || 12))) {
            if (list.length == 0) break;

            cont.add(this.bs_row({
              rowSize: options.rowSize || 12,
              items: list
            }));

            i += options.rowSize || 12;
          }
          this.add(cont);
          return cont;
        }

        var partSize = Math.floor(12 / itemCnt); // can be like 3.45 or 1 or 12

        if (options.rowSize) {

          partSize = Math.floor(12 / options.rowSize);
        }

        var cont = _e("div").addClass("row");

        options.items.forEach(function(ii) {
          // <div class="col-md-1">.col-md-1</div>
          var place = cont.div("col col-md-" + partSize);
          place.add(ii);
        });
        this.add(cont);
        return cont;
      }
      _myTrait_.bs_setContentFunctions = function(toElem, options) {

        for (var n in options) {
          if (options.hasOwnProperty(n)) {
            if (options[n]) {
              (function(n) {
                var area = options[n];
                var fName = "component_";
                fName += n;
                toElem[fName] = function(newVal) {
                  if (!newVal) {
                    return area;
                  }
                  area.clear();
                  area.add(newVal);
                }
              }(n));
            }
          }
        }
      }
      _myTrait_.bs_setItemAction = function(item, toElem, options) {
        toElem.on("click", function() {
          if (item.action) item.action();
          if (item.view) {
            if (options.content) {
              options.content.pushView(item.view);
            }
          }
        })
      }
      _myTrait_.bs_setItemContent = function(item, toElem) {

        if (item.faicon) {
          toElem.span("fa fa-" + item.faicon);
          toElem.span().html("&nbsp;");
        }
        if (item.glyph) {
          toElem.span("glyphicon glyphicon-" + item.glyph);
          toElem.span().html("&nbsp;");
        }
        if (item.leftBadge) toElem.span("badge").text(item.leftBadge);
        if (item.title) toElem.span().add(item.title);
        if (item.rightBadge) toElem.span("badge").text(item.rightBadge);
        if (item.active) toElem.addClass("active");

        return toElem;
      }
      _myTrait_.bs_textarea = function(options) {
        /*
                    <div class="form-group has-success has-feedback">
                      <label class="control-label" for="inputSuccess2">Input with success</label>
                      <input type="text" class="form-control" id="inputSuccess2">
                      <span class="glyphicon glyphicon-ok form-control-feedback"></span>
                    </div>
                    *
                    
                    /*
                    { type:"text", bind : { data : o, name : "" }, text : "" }
                    */
        var g = _e('div').addClass('form-group');
        if (options.feedback) {
          g.addClass('has-success has-feedback');
        }
        var id = g.guid();
        if (options.text) {
          g.label('control-label', {
            'for': id
          }).text(options.text);
        }
        var inp = g.textarea('form-control', {
          id: id,
          type: options.type || 'text',
          rows: options.rows || 6
        });
        if (options.bind) {
          inp.bind(options.bind.data, options.bind.name);
        }
        var feedback, fbClass = 'glyphicon-ok';
        if (options.feedback) {
          feedback = g.span('glyphicon form-control-feedback');
          feedback.hide();
        }
        g.setFeedback = function(state) {
          feedback.removeClass(fbClass);
          if (state == 'ok')
            fbClass = 'glyphicon-ok';
          if (state == 'error')
            fbClass = 'glyphicon-remove';
          if (state == 'warning')
            fbClass = 'glyphicon-warning-sign';
          feedback.addClass(fbClass);
        };
        this.add(g);
        return g;
      }
    }(this));;
    (function(_myTrait_) {
      var colors;
      _myTrait_.colorMix = function(c1, c2, t) {

        var from = this.toRGB(c1),
          to = this.toRGB(c2);

        var res = this.yuvConversion2(from, to, function(y1, y2) {
          return {
            y: (1 - t) * y1.y + t * y2.y,
            u: (1 - t) * y1.u + t * y2.u,
            v: (1 - t) * y1.v + t * y2.v
          }
        });

        return res;
      }
      _myTrait_.colorToHex = function(color) {
        if (color.substr(0, 1) === '#') {
          return color;
        }
        var digits = /(.*?)rgb\((\d+), (\d+), (\d+)\)/.exec(color);

        var red = parseInt(digits[2]);
        var green = parseInt(digits[3]);
        var blue = parseInt(digits[4]);

        var rgb = blue | (green << 8) | (red << 16);
        return digits[1] + '#' + rgb.toString(16);
      }
      _myTrait_.colourNameToHex = function(colour) {

        if (typeof colors[colour.toLowerCase()] != 'undefined')
          return colors[colour.toLowerCase()];

        return false;
      }
      _myTrait_.componentToHex = function(c) {
        c = parseInt(c);
        var hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
      }
      _myTrait_.hexToRgb = function(hex) {
        if (hex[0] == "#") hex = hex.substr(1);
        if (hex.length == 3) {
          var temp = hex;
          hex = '';
          temp = /^([a-f0-9])([a-f0-9])([a-f0-9])$/i.exec(temp).slice(1);
          for (var i = 0; i < 3; i++) hex += temp[i] + temp[i];
        }
        if (!hex) return null;
        if (hex == null) return;
        var triplets = /^([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i.exec(hex).slice(1);

        return {
          r: parseInt(triplets[0], 16),
          g: parseInt(triplets[1], 16),
          b: parseInt(triplets[2], 16)
        }
      }
      _myTrait_.hexToYuv = function(hexVal) {
        var me = this;
        return me.rgbToYuv(me.toRGB(hexVal));
      }
      _myTrait_.hsvToRgb = function(c) {
        var r, g, b;
        var i;
        var f, p, q, t;

        // Make sure our arguments stay in-range
        var h = Math.max(0, Math.min(360, c.h));
        var s = Math.max(0, Math.min(100, c.s));
        var v = Math.max(0, Math.min(100, c.v));

        // We accept saturation and value arguments from 0 to 100 because that's
        // how Photoshop represents those values. Internally, however, the
        // saturation and value are calculated from a range of 0 to 1. We make
        // That conversion here.
        s /= 100;
        v /= 100;

        if (s == 0) {
          // Achromatic (grey)
          r = g = b = v;
          return {
            r: Math.round(r * 255),
            g: Math.round(g * 255),
            b: Math.round(b * 255)
          };
        }

        h /= 60; // sector 0 to 5
        i = Math.floor(h);
        f = h - i; // factorial part of h
        p = v * (1 - s);
        q = v * (1 - s * f);
        t = v * (1 - s * (1 - f));

        switch (i) {
          case 0:
            r = v;
            g = t;
            b = p;
            break;

          case 1:
            r = q;
            g = v;
            b = p;
            break;

          case 2:
            r = p;
            g = v;
            b = t;
            break;

          case 3:
            r = p;
            g = q;
            b = v;
            break;

          case 4:
            r = t;
            g = p;
            b = v;
            break;

          default: // case 5:
            r = v;
            g = p;
            b = q;
        }

        return {
          r: Math.round(r * 255),
          g: Math.round(g * 255),
          b: Math.round(b * 255)
        };
      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(t) {

        if (!colors) {
          colors = {
            "none": "#ffffff",
            "aliceblue": "#f0f8ff",
            "antiquewhite": "#faebd7",
            "aqua": "#00ffff",
            "aquamarine": "#7fffd4",
            "azure": "#f0ffff",
            "beige": "#f5f5dc",
            "bisque": "#ffe4c4",
            "black": "#000000",
            "blanchedalmond": "#ffebcd",
            "blue": "#0000ff",
            "blueviolet": "#8a2be2",
            "brown": "#a52a2a",
            "burlywood": "#deb887",
            "cadetblue": "#5f9ea0",
            "chartreuse": "#7fff00",
            "chocolate": "#d2691e",
            "coral": "#ff7f50",
            "cornflowerblue": "#6495ed",
            "cornsilk": "#fff8dc",
            "crimson": "#dc143c",
            "cyan": "#00ffff",
            "darkblue": "#00008b",
            "darkcyan": "#008b8b",
            "darkgoldenrod": "#b8860b",
            "darkgray": "#a9a9a9",
            "darkgreen": "#006400",
            "darkkhaki": "#bdb76b",
            "darkmagenta": "#8b008b",
            "darkolivegreen": "#556b2f",
            "darkorange": "#ff8c00",
            "darkorchid": "#9932cc",
            "darkred": "#8b0000",
            "darksalmon": "#e9967a",
            "darkseagreen": "#8fbc8f",
            "darkslateblue": "#483d8b",
            "darkslategray": "#2f4f4f",
            "darkturquoise": "#00ced1",
            "darkviolet": "#9400d3",
            "deeppink": "#ff1493",
            "deepskyblue": "#00bfff",
            "dimgray": "#696969",
            "dodgerblue": "#1e90ff",
            "firebrick": "#b22222",
            "floralwhite": "#fffaf0",
            "forestgreen": "#228b22",
            "fuchsia": "#ff00ff",
            "gainsboro": "#dcdcdc",
            "ghostwhite": "#f8f8ff",
            "gold": "#ffd700",
            "goldenrod": "#daa520",
            "gray": "#808080",
            "green": "#008000",
            "greenyellow": "#adff2f",
            "honeydew": "#f0fff0",
            "hotpink": "#ff69b4",
            "indianred": "#cd5c5c",
            "indigo ": "#4b0082",
            "ivory": "#fffff0",
            "khaki": "#f0e68c",
            "lavender": "#e6e6fa",
            "lavenderblush": "#fff0f5",
            "lawngreen": "#7cfc00",
            "lemonchiffon": "#fffacd",
            "lightblue": "#add8e6",
            "lightcoral": "#f08080",
            "lightcyan": "#e0ffff",
            "lightgoldenrodyellow": "#fafad2",
            "lightgrey": "#d3d3d3",
            "lightgreen": "#90ee90",
            "lightpink": "#ffb6c1",
            "lightsalmon": "#ffa07a",
            "lightseagreen": "#20b2aa",
            "lightskyblue": "#87cefa",
            "lightslategray": "#778899",
            "lightsteelblue": "#b0c4de",
            "lightyellow": "#ffffe0",
            "lime": "#00ff00",
            "limegreen": "#32cd32",
            "linen": "#faf0e6",
            "magenta": "#ff00ff",
            "maroon": "#800000",
            "mediumaquamarine": "#66cdaa",
            "mediumblue": "#0000cd",
            "mediumorchid": "#ba55d3",
            "mediumpurple": "#9370d8",
            "mediumseagreen": "#3cb371",
            "mediumslateblue": "#7b68ee",
            "mediumspringgreen": "#00fa9a",
            "mediumturquoise": "#48d1cc",
            "mediumvioletred": "#c71585",
            "midnightblue": "#191970",
            "mintcream": "#f5fffa",
            "mistyrose": "#ffe4e1",
            "moccasin": "#ffe4b5",
            "navajowhite": "#ffdead",
            "navy": "#000080",
            "oldlace": "#fdf5e6",
            "olive": "#808000",
            "olivedrab": "#6b8e23",
            "orange": "#ffa500",
            "orangered": "#ff4500",
            "orchid": "#da70d6",
            "palegoldenrod": "#eee8aa",
            "palegreen": "#98fb98",
            "paleturquoise": "#afeeee",
            "palevioletred": "#d87093",
            "papayawhip": "#ffefd5",
            "peachpuff": "#ffdab9",
            "peru": "#cd853f",
            "pink": "#ffc0cb",
            "plum": "#dda0dd",
            "powderblue": "#b0e0e6",
            "purple": "#800080",
            "red": "#ff0000",
            "rosybrown": "#bc8f8f",
            "royalblue": "#4169e1",
            "saddlebrown": "#8b4513",
            "salmon": "#fa8072",
            "sandybrown": "#f4a460",
            "seagreen": "#2e8b57",
            "seashell": "#fff5ee",
            "sienna": "#a0522d",
            "silver": "#c0c0c0",
            "skyblue": "#87ceeb",
            "slateblue": "#6a5acd",
            "slategray": "#708090",
            "snow": "#fffafa",
            "springgreen": "#00ff7f",
            "steelblue": "#4682b4",
            "tan": "#d2b48c",
            "teal": "#008080",
            "thistle": "#d8bfd8",
            "tomato": "#ff6347",
            "turquoise": "#40e0d0",
            "violet": "#ee82ee",
            "wheat": "#f5deb3",
            "white": "#ffffff",
            "whitesmoke": "#f5f5f5",
            "yellow": "#ffff00",
            "yellowgreen": "#9acd32"
          };
        }
      });
      _myTrait_.rgbToHex = function(p) {
        var me = this;
        return "#" + me.componentToHex(p.r) + me.componentToHex(p.g) + me.componentToHex(p.b);
      }
      _myTrait_.rgbToHsv = function(c) {
        var rr, gg, bb,
          r = c.r / 255,
          g = c.g / 255,
          b = c.b / 255,
          h, s,
          v = Math.max(r, g, b),
          diff = v - Math.min(r, g, b),
          diffc = function(c) {
            return (v - c) / 6 / diff + 1 / 2;
          };

        if (diff == 0) {
          h = s = 0;
        } else {
          s = diff / v;
          rr = diffc(r);
          gg = diffc(g);
          bb = diffc(b);

          if (r === v) {
            h = bb - gg;
          } else if (g === v) {
            h = (1 / 3) + rr - bb;
          } else if (b === v) {
            h = (2 / 3) + gg - rr;
          }
          if (h < 0) {
            h += 1;
          } else if (h > 1) {
            h -= 1;
          }
        }
        return {
          h: Math.round(h * 360),
          s: Math.round(s * 100),
          v: Math.round(v * 100)
        };
      }
      _myTrait_.rgbToYuv = function(c) {
        var R = c.r / 255;
        var G = c.g / 255;
        var B = c.b / 255;
        return {
          y: 0.299 * R + 0.587 * G + 0.114 * B,
          u: -0.14713 * R - 0.28885 * G + 0.436 * B,
          v: 0.615 * R - 0.51499 * G - 0.10001 * B
        }
      }
      _myTrait_.toRGB = function(c) {
        if (typeof(c) == "object") return c;
        var me = this;

        var hex = me.colourNameToHex(c);
        if (!hex) {
          hex = me.colorToHex(c);
        }
        return me.hexToRgb(hex);
      }
      _myTrait_.toRSpace = function(v) {
        return Math.max(0, Math.min(255, Math.round(v)));
      }
      _myTrait_.yuvConversion = function(c, fn) {
        var me = this;
        var yuv = me.rgbToYuv(me.toRGB(c));
        yuv = fn(yuv);
        var rgb = me.yuvToRgb(yuv);
        return me.rgbToHex(rgb);
      }
      _myTrait_.yuvConversion2 = function(c1, c2, fn) {
        var me = this;
        var yuv = me.rgbToYuv(me.toRGB(c1));
        var yuv2 = me.rgbToYuv(me.toRGB(c2));
        yuv = fn(yuv, yuv2);
        var rgb = me.yuvToRgb(yuv);
        return me.rgbToHex(rgb);
      }
      _myTrait_.yuvPixelConversion = function(c, fn) {
        var yuv = me.rgbToYuv(c);
        yuv = fn(yuv);
        var rgb = me.yuvToRgb(yuv);
        c.r = rgb.r;
        c.g = rgb.g;
        c.b = rgb.b;
        return c;
      }
      _myTrait_.yuvToRgb = function(c) {
        var Y = c.y;
        var U = c.u;
        var V = c.v;

        return {
          r: this.toRSpace(255 * (Y + 0 * U + 1.13983 * V)),
          g: this.toRSpace(255 * (Y - 0.39465 * U - 0.58060 * V)),
          b: this.toRSpace(255 * (Y + 2.03211 * U))
        }
      }
    }(this));;
    (function(_myTrait_) {
      var _eg;
      var _ee_;
      var guid;
      var _screenInit;
      var _svgElems;
      var _registry;
      var _elemNames;
      var _hasRemoted;
      _myTrait_.__singleton = function(t) {
        return _eg;
      }
      if (!_myTrait_.hasOwnProperty('__factoryClass')) _myTrait_.__factoryClass = []
      _myTrait_.__factoryClass.push(function(elemName, into) {

        if (elemName) {
          if (_registry && _registry[elemName]) {
            var classConst = _registry[elemName];
            return new classConst(elemName, into);
          }
        }

      });
      _myTrait_._loadRemoteUrls = function(t) {


        if (_hasRemoted) return;

        _hasRemoted = true;

        var all = document.querySelectorAll("[data-url]");
        for (var i = 0; i < all.length; i++) {
          var domWithData = all[i];

          var getTheFish = function(domWithData) {

            var url = domWithData.getAttribute("data-url");

            var parts1 = url.split("://");
            var protocol = parts1.shift(),
              rest = parts1.shift();
            var serverParts = rest.split("/"),
              ipAndPort = serverParts.shift(),
              iParts = ipAndPort.split(":"),
              ip = iParts[0],
              port = iParts[1],
              sandbox = serverParts.shift(),
              fileName = serverParts.pop(),
              path = serverParts.join("/");
            var reqData = {
              channel: {
                ip: ip,
                port: port,
                sandbox: sandbox,
                path: path,
                file: fileName,
                auth: {
                  u: "abba",
                  p: "nowp"
                }
              }
            };


            var loadData = _data({}, reqData);
            loadData.then(function() {
              var html = domWithData.innerHTML;
              html = html.trim();
              console.log("*** the html ");
              console.log(html);
              console.log("*** the data");
              console.log(loadData.toData());
              var resDiv = _e(domWithData);
              resDiv.renderTemplate(loadData, html);
            });

          }
          getTheFish(domWithData);

        }
      }
      _myTrait_.extendAll = function(name, fn) {

        if (this.isObject(name)) {

          for (var n in name) {
            if (name.hasOwnProperty(n)) this.extendAll(n, name[n]);
          }

          return this;
        }

        if (!_myTrait_[name]) {
          _myTrait_[name] = fn;
        }
        return this;
      }
      _myTrait_.getComponentRegistry = function(t) {
        return _registry;
      }
      _myTrait_.globalState = function(t) {

        if (!String.prototype.trim) {
          (function() {
            // Make sure we trim BOM and NBSP
            var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
            String.prototype.trim = function() {
              return this.replace(rtrim, '');
            };
          })();
        }

        var _eg = _ee_ = (function() {

          var o = {};
          var _compreg = {};

          var _dataId = 1;
          var _dataReg = {};
          var _dataBinds = {};

          var _listeners = {};

          var _dragging = false;
          var _dragItem = null;
          var _draggableItems = [];
          var _mouseDown = false;
          var _mouse = {
            x: 0,
            y: 0
          };
          var _dragVector = {
            sx: 0,
            sy: 0,
            dx: 0,
            dy: 0
          };

          o._cssfactor = 1;

          o.domIndex = {};

          var domGuidName = "data-egid";
          var domGuidPrefix = "huNqe7q1";
          var domGuidIndex = 1;

          // component or object which responds to evens...
          o.addListener = function(name, obj) {

            if (!_listeners[name]) _listeners[name] = [];
            var was = false;
            _listeners[name].forEach(function(l) {
              if (l == obj) was = true;
            });
            if (was) return;

            // Allow now only one listener... sorry...
            if (_listeners[name].length > 0) {
              _listeners[name][0] = obj;
            } else {
              _listeners[name].push(obj);
            }
            console.log("Addded listeners");
            console.log(_listeners);
            return o;

          }

          o.removeListener = function(name, obj) {

            if (!_listeners[name]) return;
            var list = _listeners[name];
            var len = list.length;
            for (var i = 0; i < len; i++) {
              var oo = list[i];
              if (oo == obj) {
                _listeners[name].splice(i, 1);
                break;
              }
            }
            return o;
          }


          var _popZStart = 2;
          o.popZ = function() {
            return _popZStart++;
          }


          o.msg = o.sendEvent = function(name, eventName, a, b, c, d, e, f, g) {

            if (!_listeners[name]) {
              return;
            }
            _listeners[name].forEach(function(l) {

              l.trigger(eventName, a, b, c, d, e, f, g);
            });
          }


          o.onmsg = function(msgtype, msgname, fn) {

            o.addListener(msgtype, {
              trigger: function(name, a, b, c, d, e) {
                if (name == msgname) fn(a, b, c, d, e);
              }
            })
          }



          o.addToDomIndex = function(dom, obj) {

            var id;
            if (id = dom.getAttribute(domGuidName)) return id;

            var id = domGuidPrefix + domGuidIndex;
            domGuidIndex++;
            o.domIndex[id] = obj;
            dom.setAttribute(domGuidName, id);
          }


          o.searchDomIndex = function(id) {
            if (!id) return;
            if (typeof(id) == "string") {
              return o.domIndex[id];
            }
            if (id.getAttribute) id = id.getAttribute(domGuidName);
            if (!id) return;
            return o.domIndex[id];
          }

          o.addEventListener = function(dom, en, fn) {

            en = en.toLowerCase();

            if (dom.attachEvent) {
              dom.attachEvent("on" + en, fn);
            } else {
              dom.addEventListener(en, fn);
            }
            return true;
          }

          o.mouse = function() {
            return _mouse;
          }

          o.pxParam = function(v) {

            if (typeof(v) == "string") {
              return parseInt(v) + "px";
            } else {
              var i = parseInt(v);
              if (!isNaN(i)) {
                // this._dom.style.width = i+"px";
                return i + "px";
              }
            }
          }

          o.bexp = function(p, v) {
            var str = "";
            str += "-o-" + p + ":" + v + ";\n";
            str += "-moz-" + p + ":" + v + ";\n";
            str += "-webkit-" + p + ":" + v + ";\n";
            str += p + ":" + v + ";\n";
            return str;
          }

          // Should we add event listener for the page?



          o.addEventListener(document, "mousemove", function(e) {

            e = e || window.event;

            if (!e.pageX) {

              _mouse.x = e.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft);
              _mouse.y = e.clientY + (document.documentElement.scrollTop || document.body.scrollTop);

            } else {
              _mouse.x = e.pageX;
              _mouse.y = e.pageY;
            }

            // console.log("Mousemove ", _dragging);
            if (_dragging) {

              if (e.stopPropagation) e.stopPropagation();
              if (e.preventDefault) e.preventDefault();
              e.cancelBubble = true;
              e.returnValue = false;

              _dragVector.dx = _mouse.x - _dragVector.sx;
              _dragVector.dy = _mouse.y - _dragVector.sy;
              if (_dragItem) _dragItem.trigger("drag", _dragVector);
              //console.log(_mouse.x);
              //console.log(_dragVector.sx);
              //console.log(_dragVector.dx);
              //console.log(_dragItem);
            }
          });

          o.setDragged = function(i) {
            _dragging = true;
            _dragItem = i;
          }

          o.dragMouseUp = function() {
            if (_dragItem) {
              // enddrag
              _dragItem.trigger("enddrag", _dragVector);
            }
            _dragging = false;
            _dragItem = null;
          }

          o.dragMouseDown = function(forceElem) {
            _mouseDown = true;
            if (_dragging) return;
            var found = false;

            var candidates = [];
            if (forceElem) {
              candidates.push(forceElem);
            } else {
              _draggableItems.forEach(function(e) {
                if (e.isHovering()) {
                  candidates.push(e);
                }
              });
              candidates.sort(function(a, b) {
                if (a.z && b.z) return b.z() - a.z();
                return 0;
              });
            }

            if (candidates[0]) {
              var e = candidates[0];
              // console.log("Could start drag");
              var off = e.offset();
              o.setDragged(e);
              _dragVector.sx = _mouse.x;
              _dragVector.sy = _mouse.y;
              _dragVector.dx = 0;
              _dragVector.dy = 0;
              _dragVector.x = _mouse.x - off.left;
              _dragVector.y = _mouse.y - off.top;
              found = true;
              e.trigger("startdrag", _dragVector);
              //console.log(_dragVector);
              return true;
            }
          }

          o.addEventListener(document, "mouseup", function() {
            o.dragMouseUp();
          });

          o.addEventListener(document, "mousedown", function(e) {
            if (o.dragMouseDown()) {
              e = e || window.event;
              if (e.stopPropagation) e.stopPropagation();
              if (e.preventDefault) e.preventDefault();
              e.cancelBubble = true;
              e.returnValue = false;
            }
          });






          o.draggable = function(e) {
            _draggableItems.push(e);
            e.isHovering();

            // Remove touch events for now
            // return;

            var me = e;

            e.trigger("msg", "set item draggable");

            e.touchevents();
            e.on("touchstart", function() {

              var off = me.offset();

              var t = e.touch(0);
              _dragVector.sx = t.startX;
              _dragVector.sy = t.startY;
              _dragVector.dx = 0;
              _dragVector.dy = 0;

              _dragVector.x = t.startX - off.left;
              _dragVector.y = t.startY - off.top;
              _dragging = true;
              e.trigger("startdrag", _dragVector);
            });
            e.on("touchmove", function() {
              //e.trigger("msg", "got touchmove");
              var t = e.touch(0);
              //e.trigger("msg", "got touchmove 2");
              _dragVector.dx = t.dx;
              _dragVector.dy = t.dy;
              _dragging = true;
              e.trigger("drag", _dragVector);
              //e.trigger("msg", "got touchmove 3");
            });
            e.on("touchend", function() {

              var t = e.touch(0);
              _dragVector.dx = t.dx;
              _dragVector.dy = t.dy;

              e.trigger("enddrag", _dragVector);
              _dragging = false;
            });


          }

          o.findData = function() {}

          var _imSending = false;
          o.send = function(d, vname, event, from) {

            if (_imSending) return; // no circular 

            if (!d.__id) {
              return;
            }

            // just prevent circular
            _imSending = true;
            var id = d.__id();
            var vb = _dataBinds[id];
            // console.log("ID was "+id)
            if (vb) {
              var b = vb[vname];
              if (b) {
                // console.log(b);
                b.forEach(function(oo) {
                  if (oo == from) return;
                  oo.trigger(event);
                });
              }

            }
            _imSending = false;

          }
          o.bind = function(d, vname, obj) {

            if (!d.__id) o.data(d);
            var id = d.__id();
            var vb = _dataBinds[id];
            if (!vb) {
              _dataBinds[id] = {};
              vb = _dataBinds[id];
            }

            var b = vb[vname];
            if (!b) {
              vb[vname] = [];
              b = vb[vname];
            }
            var was = false;
            var dbL = b.length;
            for (var i = 0; i < dbL; i++) {
              if (b[i] == obj) return o;
            }
            b.push(obj);
            return o;
          }

          o.data = function(d) {
            if (!d.__fn) {
              _dataId++;
              var t = function(_dataId) {
                d.__id = function() {
                  return "gd" + _dataId;
                }
              }(_dataId);
              _dataReg[d.__id()] = d;
            }
            return d;
          }

          // 
          o.register = function(name, component) {
            _compreg[name] = component;
          }

          o.find = function(name) {
            return _compreg[name];
          }


          o.trigger = function(en, data, fn) {

            if (!o._ev) return;
            if (!o._ev[en]) return;
            var me = o;
            o._ev[en].forEach(function(cb) {
              cb(me, data, fn)
            });
            return o;
          }

          o.on = function(en, ef) {

            if (!o._ev) o._ev = {};
            if (!o._ev[en]) o._ev[en] = [];
            o._ev[en].push(ef);
          }


          var keyCodeMap = {
            8: "backspace",
            9: "tab",
            13: "return",
            16: "shift",
            17: "ctrl",
            18: "alt",
            19: "pausebreak",
            20: "capslock",
            27: "escape",
            32: " ",
            33: "pageup",
            34: "pagedown",
            35: "end",
            36: "home",
            37: "left",
            38: "up",
            39: "right",
            40: "down",
            43: "+",
            44: "printscreen",
            45: "insert",
            46: "delete",
            48: "0",
            49: "1",
            50: "2",
            51: "3",
            52: "4",
            53: "5",
            54: "6",
            55: "7",
            56: "8",
            57: "9",
            59: ";",
            61: "=",
            65: "a",
            66: "b",
            67: "c",
            68: "d",
            69: "e",
            70: "f",
            71: "g",
            72: "h",
            73: "i",
            74: "j",
            75: "k",
            76: "l",
            77: "m",
            78: "n",
            79: "o",
            80: "p",
            81: "q",
            82: "r",
            83: "s",
            84: "t",
            85: "u",
            86: "v",
            87: "w",
            88: "x",
            89: "y",
            90: "z",
            96: "0",
            97: "1",
            98: "2",
            99: "3",
            100: "4",
            101: "5",
            102: "6",
            103: "7",
            104: "8",
            105: "9",
            106: "*",
            107: "+",
            109: "-",
            110: ".",
            111: "/",
            112: "f1",
            113: "f2",
            114: "f3",
            115: "f4",
            116: "f5",
            117: "f6",
            118: "f7",
            119: "f8",
            120: "f9",
            121: "f10",
            122: "f11",
            123: "f12",
            144: "numlock",
            145: "scrolllock",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'"
          };

          var modifiedByShift = {
            192: "~",
            48: ")",
            49: "!",
            50: "@",
            51: "#",
            52: "$",
            53: "%",
            54: "^",
            55: "&",
            56: "*",
            57: "(",
            109: "_",
            61: "+",
            219: "{",
            221: "}",
            220: "|",
            59: ":",
            222: "\"",
            188: "<",
            189: ">",
            191: "?",
            96: "insert",
            97: "end",
            98: "down",
            99: "pagedown",
            100: "left",
            102: "right",
            103: "home",
            104: "up",
            105: "pageup"
          };

          var _listeningKeyboard = false;
          o.listenKeyboard = function() {
            if (_listeningKeyboard) return;
            _listeningKeyboard = true;
            o.getKeyEventName = function(eName, k, e) {
              var kName = "";
              if (e.ctrlKey) eName += "ctrl-";
              if (e.shiftKey) eName += "shift-";

              if (typeof(keyCodeMap[k]) != "undefined") {
                kName = keyCodeMap[k];
                if (e.shiftKey) {
                  if (typeof(modifiedByShift[k]) != "undefined") {
                    kName = modifiedByShift[k];
                  }
                }
              }
              return eName + kName;
            }

            o._shiftKeyDown = false;

            o.addEventListener(document, "keydown", function(e) {
              var code = e.charCode || e.keyCode || e.which;
              var k = code;
              o._keyup = k;
              var kName = "";

              if (k == 16) {
                o._shiftKeyDown = true;
              }

              if (typeof(keyCodeMap[k]) != "undefined") {
                kName = keyCodeMap[k];
                if (o._shiftKeyDown) {
                  if (typeof(modifiedByShift[k]) != "undefined") {
                    kName = modifiedByShift[k];
                  }
                }
              }
              o.trigger("keydown", k);
              o.trigger(o.getKeyEventName("keydown-", k, e));
              o.msg("keyboard", o.getKeyEventName("keydown-", k, e));

            });
            o.addEventListener(document, "keyup", function(e) {

              e = e || window.event;
              var code = e.charCode || e.keyCode || e.which;
              var k = code;

              o._keyup = k;
              var kName = "";

              if (k == 16) {
                o._shiftKeyDown = false;
              }
              if (typeof(keyCodeMap[k]) != "undefined") {
                kName = keyCodeMap[k];
                if (o._shiftKeyDown) {
                  if (typeof(modifiedByShift[k]) != "undefined") {
                    kName = modifiedByShift[k];
                  }
                }
              }
              o.trigger("keyup", k);
              o.trigger(o.getKeyEventName("keyup-", k, e));
              o.msg("keyboard", o.getKeyEventName("keyup-", k, e));

            });

          }



          // http://stackoverflow.com/questions/728360/most-elegant-way-to-clone-a-javascript-object
          o.copy = function(obj) {
            // Handle the 3 simple types, and null or undefined
            if (null == obj || "object" != typeof obj) return obj;

            // Handle Date
            if (obj instanceof Date) {
              var copy = new Date();
              copy.setTime(obj.getTime());
              return copy;
            }

            // Handle Array
            if (obj instanceof Array) {
              var copy = [];
              for (var i = 0, len = obj.length; i < len; i++) {
                copy[i] = o.copy(obj[i]);
              }
              return copy;
            }

            // Handle Object
            if (obj instanceof Object) {
              var copy = {};
              for (var attr in obj) {
                if (obj.hasOwnProperty(attr)) copy[attr] = o.copy(obj[attr]);
              }
              return copy;
            }

            throw new Error("Unable to copy obj! Its type isn't supported.");
          }





          return o;
        }());

        return _eg;
      }
      _myTrait_.guid = function(t) {
        function s4() {
          return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
        }

        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
          s4() + '-' + s4() + s4() + s4();

      }
      if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
        _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
      if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
      _myTrait_.__traitInit.push(function(elemName, into) {

        this.initAsTag(elemName, into);

        this._loadRemoteUrls();
      });
      _myTrait_.initAsTag = function(elemName, into, force) {

        if (this.isObject(elemName)) {
          this._dom = elemName;
          elemName = this._dom.tagName;

          if (elemName == "input") {
            if (this._dom.getAttribute("type") == "checkbox") {
              elemName = "checkbox";
            }
          }

          // ---- might be DOM object...
        } else {
          if (elemName && elemName.charAt) {
            if (elemName.charAt(0) == "#") {
              console.log("Searching for the element name..." + elemName);
              var ee = document.getElementById(elemName.substring(1));
              if (ee) {
                console.log("Found it!!!");
                console.log(ee.tagName);
                elemName = ee.tagName;
                this._dom = ee;
              }
            }
          }
        }

        if (!_registry) _registry = {};

        if (!elemName) elemName = "div";
        if (!_eg) {
          this.initElemNames();
          _eg = _ee_ = this.globalState();
          _svgElems = {
            "circle": "true",
            "rect": true,
            "path": true,
            "svg": true,
            "image": true,
            "line": true,
            "text": true,
            "tspan": true,
            "g": true,
            "pattern": true,
            "polygon": true,
            "polyline": true,
            "clippath": true,
            "defs": true,
            "feoffset": true,
            "femerge": true,
            "femergenode": true,
            "fegaussianblur": true,
            "filter": true
          }

        }
        var svgNS = "http://www.w3.org/2000/svg";
        var origElemName = elemName;
        elemName = elemName.toLowerCase()

        if (force) {

        } else {
          if (!_elemNames[elemName] && !_svgElems[elemName]) {
            this._invalidTag = elemName;
            return;
          }
        }

        if (!_screenInit) {
          this.initScreenEvents();
          _screenInit = true;
        }

        if (_svgElems[elemName]) {
          this._svgElem = true;
          this._svg = true;
        }

        // 
        this._type = elemName;
        this._tag = elemName.toLowerCase();
        if (this._type == "checkbox") {
          this._checked = false;
          this._tag = "input";
        }
        this._children = [];

        if (elemName == "svg") this._svg = true;

        if (!this._dom) {
          if (elemName == "svg") {
            this._dom = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            // xmlns="http://www.w3.org/2000/svg" xmlns:xlink= "http://www.w3.org/1999/xlink"
            this._dom.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            this._dom.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
          } else {
            if (this._svgElem) {
              this._dom = document.createElementNS(svgNS, origElemName);
            } else {
              this._dom = document.createElement(this._tag);
            }
          }
        }

        // jQuery emulation might be removed...
        this.q = new _qc(this._dom, this);


        if (elemName == "svg") {
          // xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
          //this.q.attr("xmlns", "http://www.w3.org/2000/svg");
          //this.q.attr("xmlns:xlink", "http://www.w3.org/1999/xlink");

        }

        if (this._type == "checkbox") {
          this.q.attr("type", "checkbox");
        }

        if (!this._component && into) {
          if (typeof(into.appendChild) != "undefined")
            into.appendChild(this._dom);
        }
      }
      _myTrait_.initElemNames = function(t) {
        if (_elemNames) return;
        var list = ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio",
          "b", "base", "basefont", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas",
          "caption", "center", "cite", "code", "col", "colgroup", "datalist", "dd", "del", "details",
          "dfn", "dialog", "dir", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "font",
          "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup",
          "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link",
          "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noframes", "noscript", "object",
          "ol", "optgroup", "option", "output", "p", "param", "pre", "progress", "q", "rp", "rt", "ruby",
          "s", "sampe", "script", "section", "select", "small", "source", "span", "strike", "strong", "style",
          "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title",
          "tr", "track", "tt", "u", "ul", "var", "video", "wbr"
        ];
        _elemNames = {};
        list.forEach(function(n) {
          _elemNames[n] = true;
        })

      }
      _myTrait_.registerComponent = function(name, classDef) {

        if (!_registry[name]) {
          _registry[name] = classDef;
        }
      }
    }(this));
  }
  var _e = function(a, b, c, d, e, f, g, h) {
    if (this instanceof _e) {
      var args = [a, b, c, d, e, f, g, h];
      if (this.__factoryClass) {
        var m = this;
        var res;
        this.__factoryClass.forEach(function(initF) {
          res = initF.apply(m, args);
        });
        if (Object.prototype.toString.call(res) == '[object Function]') {
          if (res._classInfo.name != _e._classInfo.name) return new res(a, b, c, d, e, f, g, h);
        } else {
          if (res) return res;
        }
      }
      if (this.__traitInit) {
        var m = this;
        this.__traitInit.forEach(function(initF) {
          initF.apply(m, args);
        })
      } else {
        if (typeof this.init == 'function')
          this.init.apply(this, args);
      }
    } else return new _e(a, b, c, d, e, f, g, h);
  };
  _e._classInfo = {
    name: '_e'
  };
  if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("_e", _e)
  _e.prototype = new _e_prototype();
  if (typeof(window) != 'undefined') window['_e'] = _e;
  if (typeof(window) != 'undefined') window['_e_prototype'] = _e_prototype;;
  (function(_myTrait_) {
    if (_myTrait_.__traitInit && !_myTrait_.hasOwnProperty("__traitInit"))
      _myTrait_.__traitInit = _myTrait_.__traitInit.slice();
    if (!_myTrait_.__traitInit) _myTrait_.__traitInit = []
    _myTrait_.__traitInit.push(function(main) {


    });
  }(this));
}
var jeejee = function(a, b, c, d, e, f, g, h) {
  if (this instanceof jeejee) {
    var args = [a, b, c, d, e, f, g, h];
    if (this.__factoryClass) {
      var m = this;
      var res;
      this.__factoryClass.forEach(function(initF) {
        res = initF.apply(m, args);
      });
      if (Object.prototype.toString.call(res) == '[object Function]') {
        if (res._classInfo.name != jeejee._classInfo.name) return new res(a, b, c, d, e, f, g, h);
      } else {
        if (res) return res;
      }
    }
    if (this.__traitInit) {
      var m = this;
      this.__traitInit.forEach(function(initF) {
        initF.apply(m, args);
      })
    } else {
      if (typeof this.init == 'function')
        this.init.apply(this, args);
    }
  } else return new jeejee(a, b, c, d, e, f, g, h);
};
jeejee._classInfo = {
  name: 'jeejee'
};
if (typeof(ocNamespaces) != "undefined") ocNamespaces("").registerComponent("jeejee", jeejee)
jeejee.prototype = new jeejee_prototype();
if (typeof(window) != 'undefined') window['jeejee'] = jeejee;
if (typeof(window) != 'undefined') window['jeejee_prototype'] = jeejee_prototype;